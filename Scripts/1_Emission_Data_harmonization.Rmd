---
title: "0_Emission_Set_Up"
output: html_document
date: "2025-09-26"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "Emission_Analysis")
})
author:
  - name: "Lolita Muller"
    email: "m.lolita@cgiar.org"
    orcid: "0009-0002-8345-7219"
  - name: "Peter Steward"
    email: "p.steward@cgiar.org"
    orcid: "0000-0003-3985-4911"
  - name: "Namita Joshi"
    email: "n.joshi@cgiar.org"
    orcid: "0000-0002-1623-6910"
  - name: "Todd Rosenstock"
    email: "t.rosenstock@cgiar.org"
    orcid: "0000-0002-1958-9500"
  html_document:
    toc: true
    toc_float: true
    code_folding: show

---


```{r}

library(ERAg)
library(stringr)
library(knitr)
library(dplyr)
library(DT)
library(readxl)
library(tidyr)
library(arrow)
library(ggplot2)
library(data.table)
library(purrr)
library(janitor)
library(ggalt)
merged_metadata <- readRDS("~/Emission_Analysis/data/merged_metadata.rds")
```


## 1.1 Correct T.Control

When t control is yes for one of the diets then automatically enter No for the other diets of the same paper. Also for missing t control if the name of the diet contains control or Con or Zero then automatically deduce this is a control diet and others are treatment diets. 

```{r}

MT <- copy(merged_metadata$MT.Out)


MT[, T.Control := tolower(trimws(as.character(T.Control))) ]


MT[
  ## diet name suggests a control …
  grepl("\\bzero\\b|\\bcon\\b|control", A.Level.Name, ignore.case = TRUE) &

  ## … but flag is still empty / ambiguous
  (is.na(T.Control) | T.Control %in% c("0", "false","na")),

  T.Control := "yes"
]



MT[, T.Control := {
  has_ctrl <- any(T.Control == "yes", na.rm = TRUE)          # does study have a control?
  
  if (has_ctrl) {
    # 4·a  normalise obvious “no” variants
    flag <- fifelse(
      T.Control %in% c("false", "0", "n", "no"), "no", T.Control
    )
    # 4·b  ensure exactly one category: yes / no
    fifelse(flag == "yes", "yes", "no")
    
  } else {
    # keep whatever was there (even "0", "false", NA, …)
    T.Control
  }
}, by = B.Code]


MT[, T.Control := fifelse(
  (is.na(T.Control) | T.Control %in% c("", "na")) & any(T.Control == "yes", na.rm = TRUE),
  "no",
  T.Control
), by = B.Code]


merged_metadata$MT.Out <- MT


controls_multi <- MT[
  T.Control == "yes", 
  .SD[uniqueN(A.Level.Name) > 1], 
  by = B.Code
]

controls_multi[, .(B.Code, A.Level.Name, T.Control)]

rm(controls_multi,MT)
```

## 1.2) Correct A.Level.Name
Some feed intake entries are not matched to any ingredient data due to discrepancies in A.Level.Name between the feed intake and ingredient datasets for the same study codes. In this section, we build a table to flag studies where diet names do not align, helping to identify cases that may require manual review or correction.


```{r}
# --- Diet name alignment across Feed Intake, Diet Comp, and Digest -----------
# Uses Ingredient (Animals.Diet$A.Level.Name) as the canonical diet name.
# In Diet Comp and Digest, the diet name lives in D.Item, and we only consider rows with is.entire.diet == TRUE.


# -------- Helpers -------------------------------------------------------------
clean_name <- function(x) x %>% str_squish()  # add tolower() if you want case-insensitive matching

# Build a safe 1–1 mapping per B.Code between Ingredient name and a target source name.
# Expects data.frames with columns: B.Code and Diet (already cleaned).
build_mapping <- function(ingredient_df, target_df, target_label) {
  combined <- bind_rows(
    ingredient_df %>% mutate(Source = "Ingredient"),
    target_df     %>% mutate(Source = target_label)
  ) %>% distinct()

  comparison <- combined %>%
    group_by(B.Code, Diet) %>%
    summarise(Sources = paste(sort(unique(Source)), collapse = " & "), .groups = "drop") %>%
    mutate(
      Match_Status = dplyr::case_when(
        grepl(target_label, Sources) & grepl("Ingredient", Sources) ~ "Match",
        Sources == "Ingredient" ~ "Only in Ingredient",
        Sources == target_label  ~ paste("Only in", target_label),
        TRUE ~ "Other"
      )
    )

  comparison %>%
    filter(Match_Status %in% c("Only in Ingredient", paste("Only in", target_label))) %>%
    group_by(B.Code) %>%
    summarise(
      n_ing  = sum(Match_Status == "Only in Ingredient"),
      n_tar  = sum(Match_Status == paste("Only in", target_label)),
      Ingredient_Name = Diet[Match_Status == "Only in Ingredient"][1],
      Target_Name     = Diet[Match_Status == paste("Only in", target_label)][1],
      .groups = "drop"
    ) %>%
    filter(n_ing == 1, n_tar == 1)
}

# -------- 1) Collect cleaned diet names from each source ----------------------
ingredient_names <- merged_metadata$Animals.Diet %>%
  transmute(B.Code, Diet = clean_name(A.Level.Name)) %>%
  distinct()

feedintake_names <- merged_metadata$Data.Out %>%
  filter(Out.Subind == "Feed Intake", !is.na(A.Level.Name)) %>%
  transmute(B.Code, Diet = clean_name(A.Level.Name)) %>%
  distinct()

dietcomp_names <- merged_metadata$Animals.Diet.Comp %>%
  filter(is_entire_diet == TRUE) %>%
  transmute(B.Code, Diet = clean_name(D.Item)) %>%
  distinct()

digest_names <- merged_metadata$Animals.Diet.Digest %>%
  filter(is_entire_diet == TRUE) %>%
  transmute(B.Code, Diet = clean_name(D.Item)) %>%
  distinct()

# Presence BEFORE corrections (per (B.Code, Diet))
presence_before <- bind_rows(
  ingredient_names %>% mutate(Source = "Ingredient"),
  feedintake_names %>% mutate(Source = "FeedIntake"),
  dietcomp_names %>% mutate(Source = "DietComp"),
  digest_names %>% mutate(Source = "Digest")
) %>%
  mutate(val = 1L) %>%
  pivot_wider(names_from = Source, values_from = val, values_fill = 0L) %>%
  arrange(B.Code, Diet)

# -------- 2) Build 1–1 mappings vs Ingredient --------------------------------
to_correct_FI <- build_mapping(ingredient_names, feedintake_names, "FeedIntake")
to_correct_DC <- build_mapping(ingredient_names, dietcomp_names,  "DietComp")
to_correct_DG <- build_mapping(ingredient_names, digest_names,    "Digest")

# Optional: preview reports of what WILL change (before applying)
corrections_report_FI <- merged_metadata$Data.Out %>%
  filter(Out.Subind == "Feed Intake", !is.na(A.Level.Name)) %>%
  mutate(A.Level.Name_clean = clean_name(A.Level.Name)) %>%
  left_join(to_correct_FI, by = c("B.Code", "A.Level.Name_clean" = "Target_Name")) %>%
  transmute(B.Code, Old = A.Level.Name, New = dplyr::coalesce(Ingredient_Name, A.Level.Name)) %>%
  distinct() %>% filter(Old != New)

corrections_report_DC <- merged_metadata$Animals.Diet.Comp %>%
  filter(is_entire_diet == TRUE) %>%
  mutate(D.Item_clean = clean_name(D.Item)) %>%
  left_join(to_correct_DC, by = c("B.Code", "D.Item_clean" = "Target_Name")) %>%
  transmute(B.Code, Old = D.Item, New = dplyr::coalesce(Ingredient_Name, D.Item)) %>%
  distinct() %>% filter(Old != New)

corrections_report_DG <- merged_metadata$Animals.Diet.Digest %>%
  filter(is_entire_diet == TRUE) %>%
  mutate(D.Item_clean = clean_name(D.Item)) %>%
  left_join(to_correct_DG, by = c("B.Code", "D.Item_clean" = "Target_Name")) %>%
  transmute(B.Code, Old = D.Item, New = dplyr::coalesce(Ingredient_Name, D.Item)) %>%
  distinct() %>% filter(Old != New)

# -------- 3) Apply corrections (rename targets to Ingredient names) -----------
# FEED INTAKE
merged_metadata$Data.Out <- merged_metadata$Data.Out %>%
  mutate(A.Level.Name_clean = clean_name(A.Level.Name)) %>%
  left_join(to_correct_FI, by = c("B.Code", "A.Level.Name_clean" = "Target_Name")) %>%
  mutate(A.Level.Name = dplyr::coalesce(Ingredient_Name, A.Level.Name)) %>%
  select(-A.Level.Name_clean, -Ingredient_Name)

# DIET COMP (only where is.entire.diet == TRUE)
merged_metadata$Animals.Diet.Comp <- merged_metadata$Animals.Diet.Comp %>%
  mutate(D.Item_clean = clean_name(D.Item)) %>%
  left_join(to_correct_DC, by = c("B.Code", "D.Item_clean" = "Target_Name")) %>%
  mutate(
    D.Item = if_else(is_entire_diet == TRUE, dplyr::coalesce(Ingredient_Name, D.Item), D.Item)
  ) %>%
  select(-D.Item_clean, -Ingredient_Name)

# DIGEST (only where is.entire.diet == TRUE)
merged_metadata$Animals.Diet.Digest <- merged_metadata$Animals.Diet.Digest %>%
  mutate(D.Item_clean = clean_name(D.Item)) %>%
  left_join(to_correct_DG, by = c("B.Code", "D.Item_clean" = "Target_Name")) %>%
  mutate(
    D.Item = if_else(is_entire_diet == TRUE, dplyr::coalesce(Ingredient_Name, D.Item), D.Item)
  ) %>%
  select(-D.Item_clean, -Ingredient_Name)

# -------- 4) Presence AFTER corrections --------------------------------------
ingredient_names_after <- merged_metadata$Animals.Diet %>%
  transmute(B.Code, Diet = clean_name(A.Level.Name)) %>% distinct()

feedintake_names_after <- merged_metadata$Data.Out %>%
  filter(Out.Subind == "Feed Intake", !is.na(A.Level.Name)) %>%
  transmute(B.Code, Diet = clean_name(A.Level.Name)) %>% distinct()

dietcomp_names_after <- merged_metadata$Animals.Diet.Comp %>%
  filter(is_entire_diet == TRUE) %>%
  transmute(B.Code, Diet = clean_name(D.Item)) %>% distinct()

digest_names_after <- merged_metadata$Animals.Diet.Digest %>%
  filter(is_entire_diet == TRUE) %>%
  transmute(B.Code, Diet = clean_name(D.Item)) %>% distinct()

presence_after <- bind_rows(
  ingredient_names_after %>% mutate(Source = "Ingredient"),
  feedintake_names_after %>% mutate(Source = "FeedIntake"),
  dietcomp_names_after %>% mutate(Source = "DietComp"),
  digest_names_after %>% mutate(Source = "Digest")
) %>%
  mutate(val = 1L) %>%
  pivot_wider(names_from = Source, values_from = val, values_fill = 0L) %>%
  arrange(B.Code, Diet)

# Optional quick summaries
alignment_summary_before <- presence_before %>%
  summarise(
    n_rows = n(),
    full_matches = sum(Ingredient==1 & FeedIntake==1 & DietComp==1 & Digest==1),
    any_missing = sum(Ingredient + FeedIntake + DietComp + Digest < 4)
  )

alignment_summary_after <- presence_after %>%
  summarise(
    n_rows = n(),
    full_matches = sum(Ingredient==1 & FeedIntake==1 & DietComp==1 & Digest==1),
    any_missing = sum(Ingredient + FeedIntake + DietComp + Digest < 4)
  )

rm(alignment_summary_after,alignment_summary_before,corrections_report_DC,corrections_report_DG,corrections_report_FI,dietcomp_names,dietcomp_names_after,digest_names,digest_names_after,feedintake_names,feedintake_names_after,ingredient_names,ingredient_names_after,presence_after,presence_before,to_correct_DC,to_correct_DG,to_correct_FI)
```


## implement basal diets 

```{r}
library(dplyr)
library(tidyr)

df <- merged_metadata$Animals.Diet   # replace with your object name

# ---------------------------------------------------------
# 1. Separate non-ingredient rows (metadata)
# ---------------------------------------------------------
non_ingredient_rows <- df %>%
  filter(is.na(D.Item))

ingredient_rows <- df %>%
  filter(!is.na(D.Item))

# ---------------------------------------------------------
# 2. Extract true basal ingredients for each study (B.Code)
# ---------------------------------------------------------
basal_tbl <- ingredient_rows %>%
  filter(D.Item.Group == "Base") %>%
  distinct(B.Code, D.Item, .keep_all = TRUE)

# ---------------------------------------------------------
# 3. Identify all treatments per study
# ---------------------------------------------------------
treatments_tbl <- df %>%
  distinct(B.Code, Treatment = A.Level.Name)

# ---------------------------------------------------------
# 4. Replicate basal ingredients across all treatments
# ---------------------------------------------------------
basal_expanded <- basal_tbl %>%
  select(-A.Level.Name) %>%          # remove original treatment
  right_join(treatments_tbl, by = "B.Code") %>%
  rename(A.Level.Name = Treatment) %>%
  distinct()

# ---------------------------------------------------------
# 5. Remove incorrect basal rows from ingredient dataset
# ---------------------------------------------------------
ingredient_no_basal <- ingredient_rows %>%
  filter(!(D.Item.Group == "Base" & !is.na(D.Item.Group)))

# ---------------------------------------------------------
# 6. Recombine to get the fixed dataset
# ---------------------------------------------------------
merged_metadata$Animals.Diet <- bind_rows(
  non_ingredient_rows,      # keep metadata rows unchanged
  ingredient_no_basal,      # keep supplement items unchanged
  basal_expanded            # correct basal items across treatments
) %>%
  distinct()


rm(basal_expanded,basal_tbl,df,ingredient_no_basal,ingredient_rows,non_ingredient_rows,treatments_tbl)

```
## get amounts for adlib ingredients 

```{r}
merged_metadata$Animals.Diet <- merged_metadata$Animals.Diet %>%
  filter(!(D.Ad.lib == "Yes" & is.na(D.Item)))


## remove all the rows for which we have entire diet and ad lib because no matter what we are going to infer it from feed intake 


```

## 1.3) Correct ingredient units 

Some ingredients appear multiple times with amounts reported in different units. In this section, we prioritize entries that are already in preferred units to minimize the need for conversions.

```{r,message=FALSE,warning=FALSE}
## keep ingredient that appear twice with different units only once 

# Define your unit preferences
preferred_units <- c("g", "kg")
preferred_time <- "day"
preferred_animals <- "individual"

# Prioritize and deduplicate
merged_metadata$Animals.Diet <- merged_metadata$Animals.Diet %>%
  # Add a priority score to sort by best rows
  mutate(
    priority = case_when(
      D.Unit.Amount %in% preferred_units &
        D.Unit.Time == preferred_time &
        D.Unit.Animals == preferred_animals ~ 1,
      TRUE ~ 2  # lower priority
    )
  ) %>%
  group_by(B.Code, A.Level.Name, D.Item) %>%
  slice_min(order_by = priority, with_ties = FALSE) %>%
  ungroup() %>%
  select(-priority)  # optional: drop helper column

rm(preferred_units,preferred_time,preferred_animals)


### correct extraction errors 

merged_metadata$Animals.Diet.Comp <- merged_metadata$Animals.Diet.Comp %>%
  mutate(
    DC.Value = ifelse(
      B.Code == "BO1006" &
      DC.Variable == "Ash" &
      D.Item == "Ration 2" & 
      as.numeric(DC.Value) == 628,
      6.28,
      DC.Value
    )
  )


```

```{r}

# Define species of interest
species_list <- c("Cattle", "Sheep", "Goat")

# Initialize result containers
species_summary <- list()
bcode_table <- list()

# Loop over each species
for (species in species_list) {
  
  # All B.Codes for this species
  species_bcodes <- merged_metadata$Prod.Out %>%
    filter(P.Product == species) %>%
    pull(B.Code) %>%
    unique()
  
  # Feed intake B.Codes
  feed_data <- merged_metadata$Data.Out %>%
    filter(B.Code %in% species_bcodes, !is.na(ED.Mean.T)) %>%
    filter(Out.Subind=="Feed Intake")%>%
    select(B.Code, D.Item = ED.Intake.Item)
  
  feed_bcodes <- unique(feed_data$B.Code)
  
  # GE B.Codes
  ge_data <- merged_metadata$Animals.Diet.Comp %>%
    filter(B.Code %in% species_bcodes, DC.Variable == "GE", !is.na(DC.Value)) %>%
    select(B.Code, D.Item)
  
  ge_bcodes <- unique(ge_data$B.Code)
  
  # Matched B.Codes (join on both B.Code and D.Item)
  matched_bcodes <- inner_join(feed_data, ge_data, by = c("B.Code", "D.Item")) %>%
    pull(B.Code) %>%
    unique()
  
  # Store species-level summary
  species_summary[[species]] <- tibble(
    Species = species,
    Total_BCodes = length(species_bcodes),
    With_FEED = length(feed_bcodes),
    With_GE = length(ge_bcodes),
    With_BOTH = length(matched_bcodes)
  )
  
  # Store long-format bcode list
  bcode_table[[species]] <- tibble(
    B.Code = c(species_bcodes, feed_bcodes, ge_bcodes, matched_bcodes),
    Category = rep(c("All", "With_FEED", "With_GE", "With_BOTH"), 
                   times = c(length(species_bcodes), length(feed_bcodes), length(ge_bcodes), length(matched_bcodes))),
    Species = species
  ) %>% distinct()
}

# Bind results
species_summary_df <- bind_rows(species_summary)
bcode_table_df <- bind_rows(bcode_table)

```



### to do 
```{r}
to_be_categorized<-merged_metadata$Animals.Diet%>%
  filter(is.na(D.Item))%>%
  filter(D.Type!="Entire Diet")

```


## 1.5) Summary of the data 
```{r,message=FALSE,warning=FALSE}

# Define species of interest
species_list <- c("Cattle", "Sheep", "Goat")

# Initialize result containers
species_summary <- list()
bcode_table <- list()

# Loop over each species
for (species in species_list) {
  
  # All B.Codes for this species
  species_bcodes <- merged_metadata$Prod.Out %>%
    filter(P.Product == species) %>%
    pull(B.Code) %>%
    unique()
  
  # Feed intake B.Codes
  feed_data <- merged_metadata$Data.Out %>%
    filter(B.Code %in% species_bcodes, !is.na(ED.Mean.T)) %>%
    filter(Out.Subind=="Feed Intake")%>%
    select(B.Code, D.Item = ED.Intake.Item)
  
  feed_bcodes <- unique(feed_data$B.Code)
  
  # GE B.Codes
  ge_data <- merged_metadata$Animals.Diet.Comp %>%
    filter(B.Code %in% species_bcodes, DC.Variable == "GE", !is.na(DC.Value)) %>%
    select(B.Code, D.Item)
  
  ge_bcodes <- unique(ge_data$B.Code)
  
  # Matched B.Codes (join on both B.Code and D.Item)
  matched_bcodes <- inner_join(feed_data, ge_data, by = c("B.Code", "D.Item")) %>%
    pull(B.Code) %>%
    unique()
  
  # Store species-level summary
  species_summary[[species]] <- tibble(
    Species = species,
    Total_BCodes = length(species_bcodes),
    With_FEED = length(feed_bcodes),
    With_GE = length(ge_bcodes),
    With_BOTH = length(matched_bcodes)
  )
  
  # Store long-format bcode list
  bcode_table[[species]] <- tibble(
    B.Code = c(species_bcodes, feed_bcodes, ge_bcodes, matched_bcodes),
    Category = rep(c("All", "With_FEED", "With_GE", "With_BOTH"), 
                   times = c(length(species_bcodes), length(feed_bcodes), length(ge_bcodes), length(matched_bcodes))),
    Species = species
  ) %>% distinct()
}

# Bind results
species_summary_df <- bind_rows(species_summary)
bcode_table_df <- bind_rows(bcode_table)

```



## 2) Harmonize units of ingredient amounts
This step standardizes ingredient amount units (e.g., from mg, kg, %, etc.) to a consistent base (usually grams per individual per day), ensuring reliable downstream calculations and comparisons.

```{r,message=FALSE,warning=FALSE}
# Diet ingredients: breakdown of all ingredients within each diet
ingredients <- merged_metadata$Animals.Diet %>%
  mutate(D.Amount = as.numeric(D.Amount))%>% 
  filter(!is.na(D.Item))  # those are for entire diets 

# Function to harmonize diet ingredient units (only change: kg/t handling)
harmonize_units <- function(df) {
  df %>%
    mutate(
      # Record original units
      Units = paste(D.Unit.Amount, D.Unit.Time, D.Unit.Animals, sep = ";"),

      # Harmonize weight and volume units to a consistent base
      D.Amount = case_when(
        D.Unit.Amount %in% c("kg", "mg", "g/100g", "l", "kg/t", "g/300l",
                             "mg/kg", "kg/100kg", "kg/100kg body weight",
                             "kg/kg metabolic weight", "g/kg metabolic weight (0.75)",
                             "g/kg DMI", "g/L", "g/kg DM") ~ {
          case_when(
            D.Unit.Amount == "kg" ~ D.Amount * 1000,
            D.Unit.Amount == "mg" ~ D.Amount / 1000,
            D.Unit.Amount == "g/100g" ~ D.Amount * 10,
            D.Unit.Amount == "l" ~ D.Amount * 1000,
            D.Unit.Amount == "kg/t" ~ D.Amount,
            D.Unit.Amount == "g/300l" ~ D.Amount / 300,
            D.Unit.Amount == "mg/kg" ~ D.Amount / 1000,
            D.Unit.Amount %in% c("kg/100kg", "kg/100kg body weight") ~ D.Amount * 10,
            D.Unit.Amount == "kg/kg metabolic weight" ~ D.Amount * 1000,
            D.Unit.Amount %in% c("g/kg body weight (0.75)", "g/kg Body Weight (0.75)") ~ D.Amount,
            D.Unit.Amount == "g/kg DMI" ~ D.Amount,
            D.Unit.Amount == "g/kg DM" ~ D.Amount,
            TRUE ~ D.Amount
          )
        },
        TRUE ~ D.Amount
      ),

      # Update D.Unit.Amount
      D.Unit.Amount = case_when(
        D.Unit.Amount == "kg" ~ "g",
        D.Unit.Amount == "mg" ~ "g",
        D.Unit.Amount == "g/100g" ~ "g/kg",
        D.Unit.Amount == "l" ~ "ml",
        D.Unit.Amount == "kg/t" ~ "g/kg",
        D.Unit.Amount == "g/300l" ~ "g/L",
        D.Unit.Amount == "mg/kg" ~ "g/kg",
        D.Unit.Amount %in% c("kg/100kg", "kg/100kg body weight") ~ "g/kg body weight",
        D.Unit.Amount %in% c("g/kg body weight (0.75)", "g/kg Body Weight (0.75)", "g/kg metabolic weight (0.75)") ~ "g/kg metabolic weight",
        D.Unit.Amount == "kg/kg metabolic weight" ~ "g/kg metabolic weight",
        D.Unit.Amount == "g/kg DMI" ~ "g/kg",
        D.Unit.Amount == "g/kg DM" ~ "g/kg",
        D.Unit.Amount == "g/L" ~ "g/L",
        D.Unit.Amount == "g/kg Body Weight" ~ "g/kg body weight",
        TRUE ~ D.Unit.Amount
      ),

      # Harmonize time units to day (excluding "individual", only changing "experiment")
    D.Amount = case_when(
  D.Unit.Time == "week" ~ D.Amount / 7,
  D.Unit.Time == "month" ~ D.Amount / 30,
  D.Unit.Time == "2 weeks" ~ D.Amount / 14,
  D.Unit.Time == "4 days interval" ~ D.Amount / 4,
  D.Unit.Time == "2x/day" ~ D.Amount * 2,
  TRUE ~ D.Amount  # Leave "experiment" and others untouched
),

      

      D.Unit.Time = case_when(
        D.Unit.Time %in% c("week", "month", "2 weeks", "4 days interval", "2x/day") ~ "day",
        D.Unit.Time == "experiment" ~ D.Unit.Time,
        TRUE ~ D.Unit.Time
      ),

      # Remove units if amount is NA
      D.Unit.Amount = ifelse(is.na(D.Amount), NA_character_, D.Unit.Amount),
      D.Unit.Time = ifelse(is.na(D.Amount), NA_character_, D.Unit.Time),
      D.Unit.Animals = ifelse(is.na(D.Amount), NA_character_, D.Unit.Animals)
    )
}

# Apply harmonization
ingredients <- harmonize_units(ingredients)

# Load replicate info
reps <- merged_metadata$MT.Out %>%
  mutate(T.Animals = as.numeric(T.Animals)) %>%
  distinct(B.Code, A.Level.Name, .keep_all = TRUE)

# Adjust for 'all animals in replicate'
ingredients <- ingredients %>%
  left_join(reps %>% dplyr::select(B.Code, A.Level.Name, T.Animals), by = c("B.Code", "A.Level.Name")) %>%
  mutate(
    D.Amount = case_when(
      D.Unit.Animals == "all animals in replicate" & !is.na(T.Animals) ~ D.Amount / T.Animals,
      TRUE ~ D.Amount
    ),
    D.Unit.Animals = ifelse(D.Unit.Animals == "all animals in replicate", "individual", D.Unit.Animals)
  )

# Refresh Units column
ingredients <- ingredients %>%
  mutate(Units = paste(D.Unit.Amount, D.Unit.Time, D.Unit.Animals, sep = ";"))

# Cleanup
rm(harmonize_units,reps,feed_data)

```


### 1.6) remove experimental scales because no times and then amounts are too big 

```{r}
# ingredients<-ingredients%>%
#   filter(D.Unit.Time!="experiment")
# 
# # --- Fix unit representation for LM0128 to "g day individual" -------------------
# ingredients <- ingredients %>%
#   mutate(
#     # Convert mg → g for LM0128
#     D.Amount = if_else(B.Code == "LM0128" & D.Unit.Amount == "mg",
#                        D.Amount / 1000,   # convert mg to g
#                        D.Amount),
#     # Update all relevant unit fields for LM0128
#     D.Unit.Amount = if_else(B.Code == "LM0128", "g", D.Unit.Amount),
#     D.Unit.Time = if_else(B.Code == "LM0128", "day", D.Unit.Time),
#     D.Unit.Animals = if_else(B.Code == "LM0128", "individual", D.Unit.Animals),
#     # Combine them into a single standardized unit descriptor
#     D.Unit.Standard = if_else(B.Code == "LM0128",
#                               "g day individual",
#                               paste(D.Unit.Amount, D.Unit.Time, D.Unit.Animals))
#   )
# 
# merged_metadata$Animals.Diet <- merged_metadata$Animals.Diet %>%
#   mutate(
#     # Convert mg → g for LM0128
#     D.Amount = if_else(B.Code == "LM0128" & D.Unit.Amount == "mg",
#                        D.Amount / 1000,   # convert mg to g
#                        D.Amount),
#     # Update all relevant unit fields for LM0128
#     D.Unit.Amount = if_else(B.Code == "LM0128", "g", D.Unit.Amount),
#     D.Unit.Time = if_else(B.Code == "LM0128", "day", D.Unit.Time),
#     D.Unit.Animals = if_else(B.Code == "LM0128", "individual", D.Unit.Animals),
#     # Combine them into a single standardized unit descriptor
#     D.Unit.Standard = if_else(B.Code == "LM0128",
#                               "g day individual",
#                               paste(D.Unit.Amount, D.Unit.Time, D.Unit.Animals))
#   )

```

### 2.1) Suspicious dry amounts TO DO ADD IN ERA DEV 

This chunk systematically fills in missing “DC.Is.Dry” flags by combining three complementary sources—analytical moisture/DM thresholds, name‐based cues (e.g. “dried,” “meal”), and broad feed/supplement rules—and then, where every measurable ingredient in a treatment is already known to be dry, assumes the lab used the same dry‐prep protocol for all feeds in that trial. By layering data‑driven thresholds, text mining, and a diet‑level consistency override, we ensure that no ingredient in a truly dried regimen slips through unflagged, while still preserving fresh‐vs.‐dry distinctions in mixed rations.

```{r}
# ------------------------------------------------------------
# DRY flag with strict rule:
# 1) Use Moisture/DM thresholds when available (authoritative).
# 2) If NO Moisture/DM for an item, assume DRY ("Yes").
# 3) Diet-arm propagation: if all flagged items in the arm are "Yes",
#    fill any remaining NA in that arm with "Yes".
# 4) Drop "water" rows.
# No name/blanket/majority heuristics.
# ------------------------------------------------------------

# --- 1) Moisture/DM-based evidence per (B.Code, D.Item) ---------------------
dry_evidence <- bind_rows(
  # a) Moisture rules
  merged_metadata$Animals.Diet.Comp %>%
    filter(str_to_lower(DC.Variable) %in% c("moisture","moist")) %>%
    transmute(
      B.Code, D.Item,
      Predictor = "Moisture",
      Value = suppressWarnings(as.numeric(DC.Value)),
      Unit  = str_to_lower(str_squish(DC.Unit)),
      Dry_Prediction = dplyr::case_when(
        Unit %in% c("%","% dm","g/100g") ~ dplyr::case_when(
          Value <  15 ~ TRUE,   # low moisture ⇒ dry
          Value >  50 ~ FALSE,  # very wet     ⇒ not dry
          TRUE        ~ NA
        ),
        Unit == "g/kg" ~ dplyr::case_when(
          Value < 150 ~ TRUE,
          Value > 500 ~ FALSE,
          TRUE        ~ NA
        ),
        TRUE ~ NA
      )
    ),
  # b) DM rules
  merged_metadata$Animals.Diet.Comp %>%
    filter(str_to_lower(DC.Variable) == "dm") %>%
    transmute(
      B.Code, D.Item,
      Predictor = "DM",
      Value = suppressWarnings(as.numeric(DC.Value)),
      Unit  = str_to_lower(str_squish(DC.Unit)),
      Dry_Prediction = dplyr::case_when(
        Unit %in% c("%","% dm","g/100g") ~ dplyr::case_when(
          Value >  85 ~ TRUE,   # high DM ⇒ dry
          Value <  50 ~ FALSE,  # low  DM ⇒ not dry
          TRUE        ~ NA
        ),
        Unit == "g/kg" ~ dplyr::case_when(
          Value > 850 ~ TRUE,
          Value < 500 ~ FALSE,
          TRUE        ~ NA
        ),
        TRUE ~ NA
      )
    )
) %>%
  # keep one prediction per predictor per key (first non-NA)
  distinct(B.Code, D.Item, Predictor, Dry_Prediction) %>%
  group_by(B.Code, D.Item, Predictor) %>%
  summarise(Dry_Prediction = dplyr::first(na.omit(Dry_Prediction)), .groups = "drop") %>%
  # wide: Dry_Prediction_Moisture, Dry_Prediction_DM
  tidyr::pivot_wider(
    names_from = Predictor,
    values_from = Dry_Prediction,
    names_prefix = "Dry_Prediction_"
  ) %>%
  mutate(
    has_evidence = !is.na(Dry_Prediction_Moisture) | !is.na(Dry_Prediction_DM),
    # precedence: DM beats Moisture when both exist
    Dry_from_evidence = dplyr::case_when(
      !is.na(Dry_Prediction_DM)        ~ Dry_Prediction_DM,
      is.na(Dry_Prediction_DM) &
        !is.na(Dry_Prediction_Moisture) ~ Dry_Prediction_Moisture,
      TRUE                              ~ NA
    )
  ) %>%
  select(B.Code, D.Item, has_evidence, Dry_from_evidence)

# --- 2) Apply evidence to ingredients ---------------------------------------
ingredients <- ingredients %>%
  left_join(dry_evidence, by = c("B.Code","D.Item")) %>%
  mutate(
    # Evidence (DM/Moisture) is authoritative when present
    DC.Is.Dry = dplyr::case_when(
      Dry_from_evidence == TRUE  ~ "Yes",
      Dry_from_evidence == FALSE ~ "No",
      TRUE                       ~ DC.Is.Dry
    )
  )

# --- 3) Diet-level propagation (only fills NA when all flagged in arm are Yes)
ingredients <- ingredients %>%
  group_by(B.Code, A.Level.Name) %>%
  mutate(
    any_flag   = any(!is.na(DC.Is.Dry), na.rm = TRUE),
    all_dry    = all(DC.Is.Dry[!is.na(DC.Is.Dry)] == "Yes")
  ) %>%
  ungroup() %>%
  mutate(
    DC.Is.Dry = dplyr::case_when(
      any_flag & all_dry & is.na(DC.Is.Dry) ~ "Yes",
      TRUE                                  ~ DC.Is.Dry
    )
  ) %>%
  select(-any_flag, -all_dry)

# --- 4) Fallback: assume DRY only when NO Moisture/DM evidence --------------
# (i.e., we cannot decide because there is no proximate data)
ingredients <- ingredients %>%
  mutate(
    DC.Is.Dry = dplyr::case_when(
      is.na(DC.Is.Dry) & (has_evidence %in% c(FALSE, NA)) ~ "Yes",
      TRUE                                                ~ DC.Is.Dry
    )
  ) %>%
  select(-has_evidence, -Dry_from_evidence)

# --- 5) Drop pure "water" rows ----------------------------------------------
ingredients <- ingredients %>%
  filter(!(str_to_lower(D.Item) == "water"))


```




### 2.2) Filter data with acceptable units

We filter the dataset to retain only ingredients with acceptable units. Uncommon or unexpected unit formats are excluded to ensure consistency and simplify downstream processing

```{r,message=FALSE,warning=FALSE}


# Define a list of acceptable units
acceptable_units <- c(
  "g/kg", "g", "%", "ml", "L", "kg", "g/L",
  "g/kg metabolic weight", "% Diet", 
  "g/kg body weight", "ml/kg", "% Body Mass", 
  "% Concentrate", "g/kg body weight"  # leave only one if repeated
)


# Filter rows to keep only acceptable units
ingredients <- ingredients %>%
  filter(D.Unit.Amount %in% acceptable_units | is.na(D.Unit.Amount)) %>%
  mutate(D.Item = ifelse(is.na(D.Item), "Unspecified", D.Item))

#tracking paper loss because of harmnozied units
#total_studies_harmonized<- length(unique(ingredients_harmonized$B.Code))
#total_ingredients_harmonized<- length(unique(ingredients_harmonized$D.Item))
#total_diets_harmonized<- length(unique(ingredients_harmonized$A.Level.Name))

rm(acceptable_units)
```

### 2.3) Convert body weight units by linking animals weight to data
```{r}

# Pre-filter Data.Out to keep only the first non-NA weight per group
# Step 1: From Data.Out — compute unique weights
weights_data <- merged_metadata$Data.Out %>%
  filter(Out.Subind == "Weight Gain") %>%
  mutate(
    Out.WG.Unit = tolower(Out.WG.Unit),
    Out.WG.Start = case_when(
      Out.WG.Unit == "g" ~ Out.WG.Start / 1000,
      Out.WG.Unit == "mg" ~ Out.WG.Start / 1e6,
      Out.WG.Unit %in% c("kg", "unspecified", NA) ~ Out.WG.Start,
      TRUE ~ NA_real_
    ),
    Out.WG.Unit = ifelse(!is.na(Out.WG.Start), "kg", NA_character_)
  ) %>%
  filter(!is.na(Out.WG.Start)) %>%
  group_by(B.Code, A.Level.Name) %>%
  summarise(
    Out.WG.Start = mean(Out.WG.Start, na.rm = TRUE),
    Out.WG.Unit = "kg",
    .groups = "drop"
  )

# Step 2: From MT.Out — extract matching weight data
weights_mt <- merged_metadata$MT.Out %>%
  select(B.Code, A.Level.Name, Out.WG.Start, Out.WG.Unit) %>%
  filter(!is.na(Out.WG.Start)) %>%
  mutate(
    Out.WG.Start = as.numeric(Out.WG.Start),              # <- force numeric
    Out.WG.Unit = tolower(as.character(Out.WG.Unit)),     # <- force character and lowercase
    Out.WG.Start = case_when(
      Out.WG.Unit == "g" ~ Out.WG.Start / 1000,
      Out.WG.Unit == "mg" ~ Out.WG.Start / 1e6,
      Out.WG.Unit %in% c("kg", "unspecified", NA) ~ Out.WG.Start,
      TRUE ~ NA_real_
    ),
    Out.WG.Unit = ifelse(!is.na(Out.WG.Start), "kg", NA_character_)
  ) %>%
  distinct(B.Code, A.Level.Name, .keep_all = TRUE)


# Step 3: Combine both sources, then de-duplicate (keep priority if desired)
weights_unique <- bind_rows(weights_data, weights_mt) %>%
  arrange(B.Code, A.Level.Name) %>%
  distinct(B.Code, A.Level.Name, .keep_all = TRUE)




# Step 3: Join body weight and keep only ingredients with weight
ingredients <- ingredients %>%
  left_join(
    weights_unique,
    by = c("B.Code", "A.Level.Name")) 


# Step 4: Convert D.Amount to grams based on body weight and update unit accordingly
ingredients <- ingredients %>%
  mutate(
    # Recalculate D.Amount using body weight or metabolic weight, result in kg
    D.Amount = case_when(
      D.Unit.Amount == "g/kg body weight" & !is.na(Out.WG.Start) ~ (D.Amount * Out.WG.Start) / 1000,
      D.Unit.Amount == "g/kg metabolic weight" & !is.na(Out.WG.Start) ~ (D.Amount * Out.WG.Start^0.75) / 1000,
      D.Unit.Amount == "% Body Mass" & !is.na(Out.WG.Start) ~ ((D.Amount / 100) * Out.WG.Start),
      TRUE ~ D.Amount  # unchanged if not convertible
    ),

    # Update unit to "kg" if recalculated
    D.Unit.Amount = case_when(
      D.Unit.Amount %in% c("g/kg body weight", "g/kg metabolic weight", "% Body Mass") &
        !is.na(Out.WG.Start) ~ "kg",
      TRUE ~ D.Unit.Amount
    )
  )


```

### 2.4) Estimate amounts using feed intake

For ingredients reported in relative units such as %, % Diet, or g/kg, we can estimate their absolute amounts when total diet feed intake is available. This allows us to convert proportions into standardized quantities.


```{r}
missing_unit_feed_intake<- merged_metadata$Data.Out %>%
  select(B.Code, A.Level.Name, ED.Intake.Item, ED.Intake.Item.Raw,
         ED.Mean.T, ED.Error, Out.Unit, Out.Subind,is_entire_diet,Source,Out.Code.Joined) %>%
  filter(Out.Subind == "Feed Intake") %>%
  filter(is.na(Out.Unit))

#correection of errors ientitief by below script on intakes units suspicious 
# ─────────────────────────────────────────────────────────────
#  PRE-CLEANING: Fix known feed-intake unit inconsistencies
# ─────────────────────────────────────────────────────────────
# ─────────────────────────────────────────────────────────────
#  PRE-CLEANING: Fix known feed-intake unit inconsistencies
# ─────────────────────────────────────────────────────────────
# ─────────────────────────────────────────────────────────────
#  PRE-CLEANING (applied directly to merged_metadata$Data.Out)
# ─────────────────────────────────────────────────────────────

merged_metadata$Data.Out <- merged_metadata$Data.Out %>%
  mutate(
    Out.Unit = tolower(trimws(Out.Unit))
  ) %>%
  mutate(
    # AG0051: feed intake units should be kg/day (values 8–9 kg realistic)
    Out.Unit = if_else(
      B.Code == "AG0051" & str_detect(Out.Unit, "^g")&  str_detect(Out.Code.Joined, "^Feed Intake"),
      "kg/individual/day", Out.Unit
    ),

    # NN0212: entire-diet feed intake given in g/day (~70 g/day realistic)
    Out.Unit = if_else(
      B.Code == "NN0212" & str_detect(Out.Unit, "^g") &  str_detect(Out.Code.Joined, "^Feed Intake"),
      "g dm/kg body weight (0.75)", Out.Unit
    ),

    # NN0217: some rows use kg/day but actually g/kg metabolic weight
    Out.Unit = case_when(
      B.Code == "NN0217" & str_detect(Out.Unit, "kg dm/individual/day") &  str_detect(Out.Code.Joined, "^Feed Intake") ~
        "g dm/individual/day",
      TRUE ~ Out.Unit
    ),
     Out.Unit = case_when(
      B.Code == "NN0234" & str_detect(Out.Unit, "kg dm/individual/day") &  str_detect(Out.Code.Joined, "^Feed Intake") ~
        "g dm/individual/day",
      TRUE ~ Out.Unit
    ),

    # Generic cleanup for all cases
    Out.Unit = str_replace_all(Out.Unit, "dm\\s*/", "dm/"),
    Out.Unit = str_replace_all(Out.Unit, "//", "/"),
    Out.Unit = str_trim(Out.Unit)
  )


```


#### 2.4.1) Harmonization of feed intake data

```{r}

feed_intake <- merged_metadata$Data.Out %>%
  select(B.Code, A.Level.Name, ED.Intake.Item, ED.Intake.Item.Raw,
         ED.Mean.T, ED.Error, Out.Unit, Out.Subind,P.Product,
         is_entire_diet, is_group, T.Animals) %>%
  filter(Out.Subind == "Feed Intake") %>%
  filter(!is.na(ED.Mean.T)) %>%
  # ───────────────────────────────────────────────────────────────────────
  mutate(
    is_entire = is.na(ED.Intake.Item.Raw) | ED.Intake.Item.Raw == "",
    ED.Intake.Item.Raw = if_else(is_entire, "Entire Diet", ED.Intake.Item.Raw),
    ED.Intake.Item     = if_else(is_entire, "Entire Diet", ED.Intake.Item)
  ) %>%
  select(-is_entire) %>%
  # ───────────────────────────────────────────────────────────────────────
  mutate(
    Out.Unit = tolower(trimws(Out.Unit)),
    # default when unit is NA or empty: g/individual/day
    Out.Unit = if_else(is.na(Out.Unit) | Out.Unit == "", "g/individual/day", Out.Unit),
    Out.Unit.Animals = str_extract(Out.Unit, "\\b(individual|replicate|animal replicate)\\b"),
    Out.Unit.Time    = str_extract(Out.Unit, "\\b(day|d|yr|year|experiment)\\b"),
    Out.Unit.Amount  = Out.Unit %>%
      str_remove_all("\\b(individual|replicate|animal replicate)\\b") %>%
      str_remove_all("\\b(day|d|yr|year)\\b") %>%
      str_replace_all("/+", "/") %>%
      str_trim() %>%
      str_remove("/$")
  )
  


# Step 3: Convert replicate-level intake to individual-level when possible
feed_intake <- feed_intake %>%
  mutate(
    # Ensure numeric type
    ED.Mean.T = as.numeric(ED.Mean.T),
    T.Animals = as.numeric(T.Animals),

    # Convert intake and update unit
    ED.Mean.T = case_when(
      Out.Unit.Animals == "replicate" & !is.na(T.Animals) & T.Animals > 0 ~ ED.Mean.T / T.Animals,
      TRUE ~ ED.Mean.T
    ),
    Out.Unit.Animals = case_when(
      Out.Unit.Animals == "replicate" & !is.na(T.Animals) & T.Animals > 0 ~ "individual",
      TRUE ~ Out.Unit.Animals
    )
  ) %>%
  mutate(
  Out.Unit = case_when(
    !is.na(Out.Unit.Amount) & !is.na(Out.Unit.Animals) & !is.na(Out.Unit.Time) ~
      paste0(Out.Unit.Amount, "/", Out.Unit.Animals, "/", Out.Unit.Time),
    !is.na(Out.Unit.Amount) & !is.na(Out.Unit.Animals) ~
      paste0(Out.Unit.Amount, "/", Out.Unit.Animals),
    TRUE ~ Out.Unit  # fallback to whatever was already there
  )
)




# 1) Normalize parsed unit parts so matching works
feed_intake_norm <- feed_intake %>%
  mutate(
    Out.Unit.Animals = tolower(Out.Unit.Animals) %>%
      str_replace("^animal replicate$", "replicate"),
    Out.Unit.Time = tolower(Out.Unit.Time) %>%
      recode("d" = "day", "yr" = "year"),
    Out.Unit.Amount = tolower(Out.Unit.Amount) %>%
      str_squish()
  )

# 1️⃣ Define preferences
preferred_units   <- c("kg dm", "kg", "g dm", "g")  # dm first, then fresh
preferred_time    <- "day"
preferred_animals <- "individual"

# 2️⃣ Prioritize and keep one row per (paper × diet item)
feed_intake <- feed_intake_norm %>%
  mutate(
    priority = case_when(
      Out.Unit.Amount %in% preferred_units &
        Out.Unit.Time == preferred_time &
        Out.Unit.Animals == preferred_animals &
        !is.na(ED.Error) ~ 1L,
      Out.Unit.Amount %in% preferred_units &
        Out.Unit.Time == preferred_time &
        Out.Unit.Animals == preferred_animals ~ 2L,
      TRUE ~ 3L
    ),
    # numeric ranking for the preferred_units order
    unit_rank = match(Out.Unit.Amount, preferred_units)
  ) %>%
  group_by(B.Code, A.Level.Name, ED.Intake.Item) %>%
  arrange(
    priority,                          # 1 < 2 < 3
    desc(Out.Unit.Time == "day"),      # prefer daily if all are prio 3
    desc(Out.Unit.Animals == "individual"),
    unit_rank,                         # follow kg dm > kg > g dm > g
    !is.na(ED.Error)
  ) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority, -unit_rank)


### keep unique units of ingredients 


# Step 3: Join body weight
feed_intake <- feed_intake %>%
  left_join(
    weights_unique %>%
      select(B.Code, A.Level.Name, Out.WG.Start, Out.WG.Unit),
    by = c("B.Code", "A.Level.Name")
  ) %>%
  group_by(A.Level.Name) %>%
  mutate(
    Out.WG.Start = ifelse(is.na(Out.WG.Start),
                          first(na.omit(Out.WG.Start)),
                          Out.WG.Start)
  ) %>%
  ungroup() %>%
  distinct()

# Step 4: Convert ED.Mean.T to kg/day
feed_intake <- feed_intake %>%
  mutate(
    Out.Unit = trimws(tolower(Out.Unit)),
    Out.Unit.Amount = trimws(str_remove(Out.Unit.Amount, "/$")),
    
    # Convert ED.Mean.T to kg/day where possible
    ED.Mean.T = case_when(
      Out.Unit.Amount %in% c("g", "g dm") ~ ED.Mean.T / 1000,
      Out.Unit.Amount %in% c("kg", "kg dm") ~ ED.Mean.T,
      Out.Unit.Amount == "g dm/100 g" ~ ED.Mean.T * 10 / 1000,
      Out.Unit.Amount == "g/week" ~ ED.Mean.T / 7 / 1000,
      Out.Unit.Amount == "mg" ~ ED.Mean.T / 1e6,
      
      # Body weight–based conversions only if Out.WG.Start is not NA
      Out.Unit.Amount %in% c("g dm/kg metabolic weight", "g/kg metabolic weight", "g dm/kg metabolic weight") & !is.na(Out.WG.Start) ~ 
        (ED.Mean.T * Out.WG.Start^0.75) / 1000,

      Out.Unit.Amount == "kg dm/kg metabolic weight" & !is.na(Out.WG.Start) ~ 
        ED.Mean.T * Out.WG.Start^0.75,

      Out.Unit.Amount %in% c("g dm/kg body weight", "g/kg body weight", "g/g body weight") & !is.na(Out.WG.Start) ~ 
        (ED.Mean.T * Out.WG.Start) / 1000,

      Out.Unit.Amount %in% c("g/kg body weight (0.75)", "g dm/kg body weight (0.75)") & !is.na(Out.WG.Start) ~ 
        (ED.Mean.T * Out.WG.Start^0.75) / 1000,

      Out.Unit.Amount %in% c("% body weight", "dm % body weight") & !is.na(Out.WG.Start) ~ 
        (ED.Mean.T / 100) * Out.WG.Start,

      TRUE ~ ED.Mean.T  # fallback: leave unchanged
    ),

    # Only update unit if we were able to convert to kg
    Out.Unit.Amount = case_when(
      Out.Unit.Amount %in% c("g", "g dm", "g dm/100 g", "g/week", "mg","kg dm") ~ "kg",
      Out.Unit.Amount %in% c("g/kg body weight", "g dm/kg body weight", "g/g body weight") & !is.na(Out.WG.Start) ~ "kg",
      Out.Unit.Amount %in% c("g/kg metabolic weight", "g dm/kg metabolic weight", "g dm/kg metabolic weight") & !is.na(Out.WG.Start) ~ "kg",
      Out.Unit.Amount %in% c("kg dm/kg metabolic weight") & !is.na(Out.WG.Start) ~ "kg",
      Out.Unit.Amount %in% c("g/kg body weight (0.75)", "g dm/kg body weight (0.75)") & !is.na(Out.WG.Start) ~ "kg",
      Out.Unit.Amount %in% c("% body weight", "dm % body weight") & !is.na(Out.WG.Start) ~ "kg",
      TRUE ~ Out.Unit.Amount  # keep the original if no conversion
    )
  ) %>%
  select(-Out.Unit)

# Retain most interpretable row per intake item
feed_intake <- feed_intake %>%
  group_by(B.Code, A.Level.Name, ED.Intake.Item.Raw) %>%
  arrange(
    desc(!is.na(ED.Mean.T)), 
    desc(Out.Unit.Amount == "kg"),
    desc(Out.Unit.Animals == "individual"),
    desc(Out.Unit.Time == "day")
  ) %>%
  slice(1) %>%
  ungroup()

```

#### 2.4.2) Unit error check on feed intake
Performs basic outlier checks on feed intake data, identifying suspiciously high or low intake values based on predefined unit thresholds.

```{r,message=FALSE,warning=FALSE}

# Assuming your data is stored in a data frame named `feed_intake_data`

# Filter for units that imply kg/day/individual and check if ED.Mean.T > 50
# Identify suspicious feed intake values
## ---- detect_suspicious_feed_intake -----------------------------------------
# Thresholds
high_kg <- 50      # > 50 kg d-1 animal-1  ⟹ unrealistically high
low_kg  <- 0.1     # < 0.1 kg d-1 animal-1 ⟹ unrealistically low
low_g_min <- 1     # 1–20 g range unlikely for daily intake
low_g_max <- 20

suspicious_feed_intake <- feed_intake %>% 
  mutate(
    flag = case_when(
      Out.Unit.Amount %in% c("kg", "kg dm") &
      Out.Unit.Time   == "day"              &
      Out.Unit.Animals == "individual" & ED.Mean.T >  high_kg ~ "too_high_kg",

      Out.Unit.Amount %in% c("kg", "kg dm") &
      Out.Unit.Time   == "day"              &
      Out.Unit.Animals == "individual" & ED.Mean.T <  low_kg  ~ "too_low_kg",

      Out.Unit.Amount %in% c("g",  "g dm")  &
      ED.Mean.T >= low_g_min & ED.Mean.T <= low_g_max          ~ "implausibly_low_g",

      TRUE ~ NA_character_
    )
  ) %>% 
  filter(!is.na(flag))%>%
  filter(P.Product %in% c("Cattle","Sheep","Goat"))%>%
  filter(is_entire_diet=="TRUE")

print(suspicious_feed_intake)





```



#### 2.4.3) Use of feed intake for ingredient amounts

If feed intake data is there for the entire diet and that the ingredients in ingredients dataset are in % or % of diet or g/kg we can convert 

When we translate relative inclusion rates (“% of diet”, “g kg⁻¹ diet”) into absolute grams of dry matter, the correct denominator depends on how feed‑intake data are structured.  The table below summarises every layout we encounter, what it looks like in the two raw data frames (`feed_intake` and `ingredients`), how the percentages should be interpreted, and therefore which intake value—total diet or group‑level mix—must be used for the conversion.



| Scenario | What you see in **feed_intake** | What you see in **ingredients** | What the % or g kg⁻¹ actually mean | Correct denominator for conversion |
|----------|---------------------------------|---------------------------------|------------------------------------|------------------------------------|
| **A — No diet groups** | One row per diet level marked *Entire Diet* | Every ingredient row has `D.Item.Group = NA` | “%” = % of whole diet<br>“g/kg” = g per kg whole diet | **Total‑diet intake** (`intake_total`) |
| **B — Mix is *part* of diet** | Two + rows per diet level:<br>• `is_group = TRUE` for each mix (with its own intake)<br>• `is_entire_diet = TRUE` | Rows inside the mix have `D.Item.Group = mix name`; stand‑alone ingredients have `NA` | Inside‑mix “%” = % of **mix**<br>Stand‑alone “%” = % of **whole diet** | Inside‑mix → **group intake** (`intake_group`)<br>Stand‑alone → **total‑diet intake** |
| **C — Mix *is* the whole diet** | Only one `is_group = TRUE` row and that diet level has **no** stand‑alone ingredients | Every ingredient has the same `D.Item.Group` | “%” = % of whole diet, even though recorded under a group label | **Total‑diet intake** (because group = total) |
| **D — Group intake duplicated in ingredients** | — | A row like `D.Item == "Unspecified"` in kg day⁻¹ that repeats the group’s intake | Not a nutrient source → should be **removed** | **Drop the row** entirely |
| **E — Ingredient in feed_intake but not in ingredients** | A stand‑alone `is_group = FALSE` row | Missing ingredient row | We still need this ingredient and its intake | **Create a synthetic ingredient row** with grams = `ED.Mean.T × 1000` |


```{r}
library(dplyr)
library(stringr)

## ----------------------------------------------------------
## 0. Ensure Source column exists
## ----------------------------------------------------------
ingredients <- ingredients %>%
  { if (!"Source" %in% names(.)) mutate(., Source = NA_character_) else . }

## ----------------------------------------------------------
## 1. Mark entire diet rows in feed_intake only
## ----------------------------------------------------------
feed_intake <- feed_intake %>%
  mutate(
    ED_item_clean = tolower(coalesce(ED.Intake.Item, ED.Intake.Item.Raw, "")),
    is_entire_diet = grepl("^\\s*entire\\s*diet\\s*$", ED_item_clean)
                     | ED.Intake.Item == A.Level.Name
  )

## ----------------------------------------------------------
## 2. Lookup tables for direct intakes
## ----------------------------------------------------------
intake_total <- feed_intake %>%
  filter(is_entire_diet) %>%
  transmute(
    B.Code, A.Level.Name,
    total_intake = ED.Mean.T,
    total_unit_amount = Out.Unit.Amount,
    total_unit_time   = Out.Unit.Time,
    total_unit_animals= Out.Unit.Animals
  )

intake_ing <- feed_intake %>%
  filter(!is_entire_diet) %>%   ## <--- EVERYTHING that is not entire-diet
  transmute(
    B.Code, A.Level.Name,
    D.Item = ED.Intake.Item,
    ing_intake      = ED.Mean.T,
    ing_unit_amount = Out.Unit.Amount,
    ing_unit_time   = Out.Unit.Time,
    ing_unit_animals= Out.Unit.Animals
  )

## ----------------------------------------------------------
## 3. Drop container rows (original logic)
## ----------------------------------------------------------
group_lookup <- ingredients %>%
  filter(!is.na(D.Item.Group)) %>%
  distinct(B.Code, A.Level.Name, grp_name = str_trim(D.Item.Group))

ingredients_clean <- ingredients %>%
  left_join(group_lookup, by = c("B.Code","A.Level.Name")) %>%
  filter(!(D.Item=="Unspecified" &
           D.Unit.Amount=="kg" &
           D.Unit.Time=="day" &
           !is.na(grp_name) &
           str_trim(D.Type)==grp_name)) %>%
  select(-grp_name)

## ----------------------------------------------------------
## 4. Attach direct ingredient-level feed-intake
## ----------------------------------------------------------
ingredients_fi <- ingredients_clean %>%
  left_join(intake_ing, by = c("B.Code","A.Level.Name","D.Item")) %>%
  left_join(intake_total, by = c("B.Code","A.Level.Name"))

## ----------------------------------------------------------
## 5. Replace amounts using feed_intake priority
## ----------------------------------------------------------
ingredients_fi <- ingredients_fi %>%
  mutate(
    has_ing   = !is.na(ing_intake),
    has_total = !is.na(total_intake),

    # compute final amount
    D.Amount_new = case_when(
      has_ing ~ ing_intake,
      !has_ing & D.Unit.Amount %in% c("%","% Diet") & has_total ~ (D.Amount/100)*total_intake,
      !has_ing & D.Unit.Amount=="g/kg" & has_total ~ D.Amount * total_intake,
      TRUE ~ D.Amount
    ),

    # final units
    D.Unit.Amount_new = case_when(
      has_ing ~ ing_unit_amount,
      !has_ing & D.Unit.Amount %in% c("%","% Diet") & has_total ~ total_unit_amount,
      !has_ing & D.Unit.Amount=="g/kg" & has_total ~ "g",
      TRUE ~ D.Unit.Amount
    ),

    D.Unit.Time_new = coalesce(ing_unit_time, D.Unit.Time),
    D.Unit.Animals_new = coalesce(ing_unit_animals, D.Unit.Animals),

    intake_source = case_when(
      has_ing ~ "ingredient_intake",
      !has_ing & has_total ~ "diet_intake",
      TRUE ~ "original"
    ),

    Source = coalesce(Source,"extracted")
  ) %>%
  mutate(
    D.Amount = D.Amount_new,
    D.Unit.Amount = D.Unit.Amount_new,
    D.Unit.Time = D.Unit.Time_new,
    D.Unit.Animals = D.Unit.Animals_new
  ) %>%
  select(-any_of(c(
    "has_ing","has_total",
    "ing_intake","ing_unit_amount","ing_unit_time","ing_unit_animals",
    "total_intake","total_unit_amount","total_unit_time","total_unit_animals",
    "ED_item_clean",
    "D.Amount_new","D.Unit.Amount_new","D.Unit.Time_new","D.Unit.Animals_new"
  )))

## ----------------------------------------------------------
## 6. IMPORT ALL MISSING FEED-INTAKE ITEMS (YOUR NEW RULE!)
## ----------------------------------------------------------
missing_ing <- feed_intake %>%
  filter(!is_entire_diet) %>%      # everything except entire diet
  anti_join(
    ingredients_fi,
    by = c("B.Code","A.Level.Name","ED.Intake.Item"="D.Item")
  )

imported_from_fi <- missing_ing %>%
  transmute(
    B.Code, A.Level.Name,
    D.Item         = ED.Intake.Item,
    D.Type         = "Imported_from_feed_intake",
    D.Amount       = ED.Mean.T,
    D.Unit.Amount  = Out.Unit.Amount,
    D.Unit.Time    = Out.Unit.Time,
    D.Unit.Animals = Out.Unit.Animals,
    DC.Is.Dry      = NA,
    D.Ad.lib       = NA,
    D.Item.Group   = NA_character_,
    D.Item.AOM     = NA_character_,
    AOM.Scientific.Name = NA_character_,
    Source         = "feed_intake",
    intake_source  = "feed_intake_only"
  )

## ----------------------------------------------------------
## FINAL OUTPUT
## ----------------------------------------------------------
ingredients_final <- bind_rows(ingredients_fi, imported_from_fi) %>%
  distinct()


```
## diet groups 

Some basal diet ingredients feed intake are given in the data out tab but for group of ingredients. The aim of this chunck is to give for each of those ingredient the right correponsing intake . 

harmonize names 
```{r}
library(readxl)
library(dplyr)
library(stringr)
library(tidyr)
library(purrr)

###############################################################################
### 0) Load master-sheet
###############################################################################

url <- "https://github.com/Mlolita26/ERA_Docs/raw/main/era_master_sheet(15).xlsx"
temp_file <- tempfile(fileext = ".xlsx")

download.file(url, destfile = temp_file, mode = "wb")
mastersheet <- read_excel(temp_file, sheet = "ani_diet")

###############################################################################
### 1) Build master-sheet token lookup
###############################################################################

master_token_table <- mastersheet %>%
  mutate(
    D.Item.full  = D.Item,
    D.Item.token = str_split(D.Item, ";")
  ) %>%
  unnest_longer(D.Item.token) %>%
  mutate(
    D.Item.token   = trimws(tolower(D.Item.token)),
    canonical_name = D.Item.Root.Comp.Proc_Major
  ) %>%
  filter(D.Item.token != "")

###############################################################################
### 2) Expand grouped ingredients and handle special process tokens
###############################################################################

special_processes <- c("drying", "fresh", "ensilation")

ingredients_groups <- ingredients_final %>%
  filter(str_detect(D.Item, ";")) %>%
  mutate(
    D.Item.original = D.Item,
    raw_tokens      = str_split(D.Item, ";")
  ) %>%
  mutate(
    raw_tokens = map(raw_tokens, function(tokens) {

      cleaned <- character(0)

      for (t in tokens) {

        t_clean <- trimws(t)
        t_low   <- trimws(tolower(t_clean))

        if (length(cleaned) == 0) {

          cleaned <- c(cleaned, t_clean)

        } else if (t_low %in% special_processes) {

          # Append processing to previous ingredient
          cleaned[length(cleaned)] <- paste0(
            cleaned[length(cleaned)], "||", tools::toTitleCase(t_low)
          )

        } else {
          cleaned <- c(cleaned, t_clean)
        }
      }

      cleaned
    })
  ) %>%
  select(-D.Item) %>%
  unnest_longer(raw_tokens, values_to = "token_raw") %>%
  mutate(
    token_raw   = trimws(token_raw),
    token_match = trimws(tolower(token_raw))
  )

###############################################################################
### 3) Match tokens to master-sheet
###############################################################################

ingredients_matched <- ingredients_groups %>%
  left_join(master_token_table,
            by = c("token_match" = "D.Item.token"),
            multiple = "all") %>%
  mutate(
    matched       = !is.na(canonical_name),
    unmatched     =  is.na(canonical_name),
    token_cleaned = ifelse(matched, canonical_name, token_raw)
  )

###############################################################################
### 4) Split D.Amount proportionally across grouped items
###############################################################################

ingredients_matched <- ingredients_matched %>%
  group_by(B.Code, A.Level.Name, D.Item.original) %>%
  mutate(
    n_items  = n(),
    D.Amount = D.Amount / n_items
  ) %>%
  ungroup()

###############################################################################
### 5) Build cleaned expanded ingredient table
###############################################################################

ingredients_cleaned_expanded <- ingredients_matched %>%
  mutate(D.Item = token_cleaned) %>%
  select(
    B.Code, A.Level.Name, D.Item,
    D.Type, D.Amount, D.Unit.Amount, D.Unit.Time, D.Unit.Animals,
    DC.Is.Dry, D.Ad.lib, D.Item.Group, AOM.Scientific.Name,
    Source, Units, T.Animals, Out.WG.Start, Out.WG.Unit,
    intake_source,
    D.Item.original,
    token_raw, token_cleaned,
    matched, unmatched,
    D.Item.full
  )

###############################################################################
### 6) Add original rows without ";" unchanged
###############################################################################

ingredients_expanded <- bind_rows(
  ingredients_final %>% filter(!str_detect(D.Item, ";")),
  ingredients_cleaned_expanded
)


ingredients_expanded <- ingredients_expanded %>%
  group_by(B.Code, A.Level.Name) %>%
  mutate(
    # all ingredients actually present in the diet before feed-intake imports
    diet_items = list(unique(D.Item[D.Type != "Imported_from_feed_intake"])),

    # identify feed-intake rows introducing NEW ingredients
    is_new_feedintake_item =
      D.Type == "Imported_from_feed_intake" &
      !(D.Item %in% diet_items[[1]])
  ) %>%
  ungroup() %>%
  filter(!is_new_feedintake_item) %>%
  select(-diet_items, -is_new_feedintake_item)


###############################################################################
### 7) Build original ingredient name universe
###############################################################################

original_items <- ingredients_final %>%
  mutate(D.Item.clean = trimws(tolower(D.Item))) %>%
  distinct(B.Code, A.Level.Name, D.Item.clean)

###############################################################################
### 8) Identify extracted items NOT in original ingredient list
###############################################################################

ingredients_expanded2 <- ingredients_expanded %>%
  mutate(D.Item.clean = trimws(tolower(D.Item)))

ingredients_extracted_only <- ingredients_expanded2 %>%
  anti_join(original_items,
            by = c("B.Code", "A.Level.Name", "D.Item.clean"))

###############################################################################
### 9) Keep only items originally present in ingredient list
###############################################################################

ingredients_expanded_clean <- ingredients_expanded2 %>%
  semi_join(original_items,
            by = c("B.Code", "A.Level.Name", "D.Item.clean"))

###############################################################################
### 10) Deduplicate: prioritize ingredient rows over feed intake rows
###############################################################################

ingredients <- ingredients_expanded_clean %>%
  group_by(B.Code, A.Level.Name, D.Item) %>%
  arrange(
    desc(intake_source == "feed_intake_only" & !is.na(D.Amount)),
    desc(!is.na(D.Amount)),
    intake_source == "feed_intake_only"
  ) %>%
  slice(1) %>%
  ungroup()

```



### 4.2) Use Feed intake at the diet level  

added a final step that automatically fills exactly one missing ingredient amount per diet by subtracting the sum of known ingredient amounts from the total diet intake, ensuring every diet is mass-balanced when complete feed-intake data exist.
So when amount is missing use complete diet feed intake info 

```{r}

###############################################################################
###  COMPLEMENT FILL FOR MISSING INGREDIENT AMOUNTS
###  (Place this at the very END of the script, after you create `ingredients`)
###############################################################################

# --- 1) Prepare diet-level intake lookup ------------------------------------
diet_intake_lookup <- feed_intake %>%
  filter(is_entire_diet=="TRUE")%>%
  select(B.Code, A.Level.Name, ED.Mean.T)

# --- 2) Identify diets with exactly ONE missing ingredient amount ------------

complement_info <- ingredients %>%
  group_by(B.Code, A.Level.Name) %>%
  # attach total intake
  left_join(diet_intake_lookup,
            by = c("B.Code","A.Level.Name")) %>%
  summarise(
    total_intake = first(na.omit(ED.Mean.T)),        # kg/day
    n_missing    = sum(is.na(D.Amount)),
    missing_item = first(D.Item[is.na(D.Amount)]),
    sum_known    = sum(D.Amount, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  # Only fill when exactly ONE missing entry AND total intake exists
  filter(!is.na(total_intake), n_missing == 1) %>%
  mutate(
    complement_value = total_intake - sum_known,
    complement_value = ifelse(complement_value < 0, 0, complement_value)
  )

# --- 3) Merge complement back into `ingredients` -----------------------------

ingredients <- ingredients %>%
  left_join(
    complement_info %>%
      select(B.Code, A.Level.Name, missing_item, complement_value),
    by = c("B.Code", "A.Level.Name", "D.Item" = "missing_item")
  ) %>%
  mutate(
    # fill missing amount
    D.Amount = ifelse(is.na(D.Amount) & !is.na(complement_value),
                      complement_value,
                      D.Amount),
    
    # set harmonized units for the filled amount
    D.Unit.Amount  = ifelse(!is.na(complement_value), "kg", D.Unit.Amount),
    D.Unit.Time    = ifelse(!is.na(complement_value), "day", D.Unit.Time),
    D.Unit.Animals = ifelse(!is.na(complement_value), "individual", D.Unit.Animals),

    # flag the origin of these values
    D.Type = ifelse(!is.na(complement_value),
                           "complement_filled",
                           D.Type)
  ) %>%
  select(-complement_value)

###############################################################################
### END COMPLEMENT BLOCK
###############################################################################


```



## 9) Tagg ingredient with control or trt 

```{r}
##— build the control key from your merged MT.Out
ctrl_key <- merged_metadata$MT.Out[, .(
  B.Code,
  A.Level.Name,
  T.Name,
  T.Control
)]

##— example join back onto your ingredient table
# (assuming your ingredients DT has B.Code + A.Level.Name)
ingredients <- merge(
  x = ingredients, 
  y = ctrl_key, 
  by = c("B.Code","A.Level.Name"), 
  all.x = TRUE, 
  sort = FALSE
)%>%
  distinct()

```

```{r}

# ─────────────────────────────────────────────────────────────────────────────
# 1 ▸ diet-level intake DIRECTLY from feed_intake -----------------------------
feed_intake_diet <- feed_intake %>%
  filter(is_entire_diet) %>%                         # just the whole-diet rows
  transmute(B.Code, A.Level.Name,
            diet_intake_kg = ED.Mean.T,              # already in kg DM d-1
            Source = "feed_intake")

# ─────────────────────────────────────────────────────────────────────────────
# 2 ▸ diet-level intake CALCULATED from ingredients_final --------------------
diet_intake_calc <- ingredients %>%
  group_by(B.Code, A.Level.Name) %>%
  summarise(diet_intake_kg = sum(D.Amount, na.rm = TRUE) / 1000,  # g → kg
            .groups = "drop") %>%
  mutate(Source = "sum_ingredients")

# ─────────────────────────────────────────────────────────────────────────────
# 3 ▸ combine, giving precedence to the direct value -------------------------
feed_intake_diet <- feed_intake_diet %>%
  full_join(diet_intake_calc,
            by = c("B.Code", "A.Level.Name"),
            suffix = c("_feed", "_calc")) %>%
  transmute(
    B.Code, A.Level.Name,
    diet_intake_kg = coalesce(diet_intake_kg_feed, diet_intake_kg_calc),
    Source = ifelse(!is.na(diet_intake_kg_feed),
                    "feed_intake", "sum_ingredients")
  )

# diet_intake_final is ready to use

```

```{r}
# ==== Save outputs for downstream scripts =====================================



saveRDS(merged_metadata, "~/Emission_Analysis/data/merged_metadata_harmonized.rds")


saveRDS(ingredients, "~/Emission_Analysis/data/ingredients_harmonized.rds")
write.csv(ingredients, "~/Emission_Analysis/data/ingredients_harmonized.csv")


write.csv(feed_intake, "~/Emission_Analysis/data/feed_intake_harmonized.csv")

write.csv(feed_intake, "~/Emission_Analysis/data/feed_intake_ingredients_harmonized.csv")
write.csv(feed_intake, "~/Emission_Analysis/data/feed_intake_diet_harmonized.csv")

write.csv(feed_intake_diet, "~/Emission_Analysis/data/diet_intake_final.csv")

write.csv(weights_unique, "~/Emission_Analysis/data/weights_unique.csv")






# ==============================================================================

```


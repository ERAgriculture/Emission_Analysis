---
title: "0_Emission_Set_Up"
output: html_document
date: "2025-09-26"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "Emission_Analysis")
})
author:
  - name: "Lolita Muller"
    email: "m.lolita@cgiar.org"
    orcid: "0009-0002-8345-7219"
  - name: "Peter Steward"
    email: "p.steward@cgiar.org"
    orcid: "0000-0003-3985-4911"
  - name: "Namita Joshi"
    email: "n.joshi@cgiar.org"
    orcid: "0000-0002-1623-6910"
  - name: "Todd Rosenstock"
    email: "t.rosenstock@cgiar.org"
    orcid: "0000-0002-1958-9500"
  html_document:
    toc: true
    toc_float: true
    code_folding: show

---


```{r}

library(ERAg)
library(stringr)
library(knitr)
library(dplyr)
library(DT)
library(readxl)
library(tidyr)
library(arrow)
library(ggplot2)
library(data.table)
library(purrr)
library(janitor)
library(ggalt)
merged_metadata <- readRDS("C:/Users/mlolita/OneDrive - CGIAR/Alliance - ClimateActionNetZero - 1_Projects/G227-A1712_SAAF/2_Technical & Data/Lolita Emissions Paper/Emission_Analysis/data/merged_metadata.rds")
```


##duplicate code 

```{r}
merged_metadata$Animals.Diet<-merged_metadata$Animals.Diet%>%
  filter(B.Code!="0")

merged_metadata$Data.Out<-merged_metadata$Data.Out%>%
  filter(B.Code!="0")
```

## 1.1 Correct T.Control

When t control is yes for one of the diets then automatically enter No for the other diets of the same paper. Also for missing t control if the name of the diet contains control or Con or Zero then automatically deduce this is a control diet and others are treatment diets. 

```{r}

MT <- copy(merged_metadata$MT.Out)


MT[, T.Control := tolower(trimws(as.character(T.Control))) ]


MT[
  ## diet name suggests a control …
  grepl("\\bzero\\b|\\bcon\\b|control", A.Level.Name, ignore.case = TRUE) &

  ## … but flag is still empty / ambiguous
  (is.na(T.Control) | T.Control %in% c("0", "false","na")),

  T.Control := "yes"
]



MT[, T.Control := {
  has_ctrl <- any(T.Control == "yes", na.rm = TRUE)          # does study have a control?
  
  if (has_ctrl) {
    # 4·a  normalise obvious “no” variants
    flag <- fifelse(
      T.Control %in% c("false", "0", "n", "no"), "no", T.Control
    )
    # 4·b  ensure exactly one category: yes / no
    fifelse(flag == "yes", "yes", "no")
    
  } else {
    # keep whatever was there (even "0", "false", NA, …)
    T.Control
  }
}, by = B.Code]


MT[, T.Control := fifelse(
  (is.na(T.Control) | T.Control %in% c("", "na")) & any(T.Control == "yes", na.rm = TRUE),
  "no",
  T.Control
), by = B.Code]


merged_metadata$MT.Out <- MT


controls_multi <- MT[
  T.Control == "yes", 
  .SD[uniqueN(A.Level.Name) > 1], 
  by = B.Code
]

controls_multi[, .(B.Code, A.Level.Name, T.Control)]

rm(controls_multi,MT)
```

## 1.2) Correct A.Level.Name
Some feed intake entries are not matched to any ingredient data due to discrepancies in A.Level.Name between the feed intake and ingredient datasets for the same study codes. In this section, we build a table to flag studies where diet names do not align, helping to identify cases that may require manual review or correction.


```{r}
# --- Diet name alignment across Feed Intake, Diet Comp, and Digest -----------
# Uses Ingredient (Animals.Diet$A.Level.Name) as the canonical diet name.
# In Diet Comp and Digest, the diet name lives in D.Item, and we only consider rows with is.entire.diet == TRUE.


# -------- Helpers -------------------------------------------------------------
clean_name <- function(x) x %>% str_squish()  # add tolower() if you want case-insensitive matching

# Build a safe 1–1 mapping per B.Code between Ingredient name and a target source name.
# Expects data.frames with columns: B.Code and Diet (already cleaned).
build_mapping <- function(ingredient_df, target_df, target_label) {
  combined <- bind_rows(
    ingredient_df %>% mutate(Source = "Ingredient"),
    target_df     %>% mutate(Source = target_label)
  ) %>% distinct()

  comparison <- combined %>%
    group_by(B.Code, Diet) %>%
    summarise(Sources = paste(sort(unique(Source)), collapse = " & "), .groups = "drop") %>%
    mutate(
      Match_Status = dplyr::case_when(
        grepl(target_label, Sources) & grepl("Ingredient", Sources) ~ "Match",
        Sources == "Ingredient" ~ "Only in Ingredient",
        Sources == target_label  ~ paste("Only in", target_label),
        TRUE ~ "Other"
      )
    )

  comparison %>%
    filter(Match_Status %in% c("Only in Ingredient", paste("Only in", target_label))) %>%
    group_by(B.Code) %>%
    summarise(
      n_ing  = sum(Match_Status == "Only in Ingredient"),
      n_tar  = sum(Match_Status == paste("Only in", target_label)),
      Ingredient_Name = Diet[Match_Status == "Only in Ingredient"][1],
      Target_Name     = Diet[Match_Status == paste("Only in", target_label)][1],
      .groups = "drop"
    ) %>%
    filter(n_ing == 1, n_tar == 1)
}

# -------- 1) Collect cleaned diet names from each source ----------------------
ingredient_names <- merged_metadata$Animals.Diet %>%
  transmute(B.Code, Diet = clean_name(A.Level.Name)) %>%
  distinct()

feedintake_names <- merged_metadata$Data.Out %>%
  filter(Out.Subind == "Feed Intake", !is.na(A.Level.Name)) %>%
  transmute(B.Code, Diet = clean_name(A.Level.Name)) %>%
  distinct()

dietcomp_names <- merged_metadata$Animals.Diet.Comp %>%
  filter(is_entire_diet == TRUE) %>%
  transmute(B.Code, Diet = clean_name(D.Item)) %>%
  distinct()

digest_names <- merged_metadata$Animals.Diet.Digest %>%
  filter(is_entire_diet == TRUE) %>%
  transmute(B.Code, Diet = clean_name(D.Item)) %>%
  distinct()

# Presence BEFORE corrections (per (B.Code, Diet))
presence_before <- bind_rows(
  ingredient_names %>% mutate(Source = "Ingredient"),
  feedintake_names %>% mutate(Source = "FeedIntake"),
  dietcomp_names %>% mutate(Source = "DietComp"),
  digest_names %>% mutate(Source = "Digest")
) %>%
  mutate(val = 1L) %>%
  pivot_wider(names_from = Source, values_from = val, values_fill = 0L) %>%
  arrange(B.Code, Diet)

# -------- 2) Build 1–1 mappings vs Ingredient --------------------------------
to_correct_FI <- build_mapping(ingredient_names, feedintake_names, "FeedIntake")
to_correct_DC <- build_mapping(ingredient_names, dietcomp_names,  "DietComp")
to_correct_DG <- build_mapping(ingredient_names, digest_names,    "Digest")

# Optional: preview reports of what WILL change (before applying)
corrections_report_FI <- merged_metadata$Data.Out %>%
  filter(Out.Subind == "Feed Intake", !is.na(A.Level.Name)) %>%
  mutate(A.Level.Name_clean = clean_name(A.Level.Name)) %>%
  left_join(to_correct_FI, by = c("B.Code", "A.Level.Name_clean" = "Target_Name")) %>%
  transmute(B.Code, Old = A.Level.Name, New = dplyr::coalesce(Ingredient_Name, A.Level.Name)) %>%
  distinct() %>% filter(Old != New)

corrections_report_DC <- merged_metadata$Animals.Diet.Comp %>%
  filter(is_entire_diet == TRUE) %>%
  mutate(D.Item_clean = clean_name(D.Item)) %>%
  left_join(to_correct_DC, by = c("B.Code", "D.Item_clean" = "Target_Name")) %>%
  transmute(B.Code, Old = D.Item, New = dplyr::coalesce(Ingredient_Name, D.Item)) %>%
  distinct() %>% filter(Old != New)

corrections_report_DG <- merged_metadata$Animals.Diet.Digest %>%
  filter(is_entire_diet == TRUE) %>%
  mutate(D.Item_clean = clean_name(D.Item)) %>%
  left_join(to_correct_DG, by = c("B.Code", "D.Item_clean" = "Target_Name")) %>%
  transmute(B.Code, Old = D.Item, New = dplyr::coalesce(Ingredient_Name, D.Item)) %>%
  distinct() %>% filter(Old != New)

# -------- 3) Apply corrections (rename targets to Ingredient names) -----------
# FEED INTAKE
merged_metadata$Data.Out <- merged_metadata$Data.Out %>%
  mutate(A.Level.Name_clean = clean_name(A.Level.Name)) %>%
  left_join(to_correct_FI, by = c("B.Code", "A.Level.Name_clean" = "Target_Name")) %>%
  mutate(A.Level.Name = dplyr::coalesce(Ingredient_Name, A.Level.Name)) %>%
  select(-A.Level.Name_clean, -Ingredient_Name)

# DIET COMP (only where is.entire.diet == TRUE)
merged_metadata$Animals.Diet.Comp <- merged_metadata$Animals.Diet.Comp %>%
  mutate(D.Item_clean = clean_name(D.Item)) %>%
  left_join(to_correct_DC, by = c("B.Code", "D.Item_clean" = "Target_Name")) %>%
  mutate(
    D.Item = if_else(is_entire_diet == TRUE, dplyr::coalesce(Ingredient_Name, D.Item), D.Item)
  ) %>%
  select(-D.Item_clean, -Ingredient_Name)

# DIGEST (only where is.entire.diet == TRUE)
merged_metadata$Animals.Diet.Digest <- merged_metadata$Animals.Diet.Digest %>%
  mutate(D.Item_clean = clean_name(D.Item)) %>%
  left_join(to_correct_DG, by = c("B.Code", "D.Item_clean" = "Target_Name")) %>%
  mutate(
    D.Item = if_else(is_entire_diet == TRUE, dplyr::coalesce(Ingredient_Name, D.Item), D.Item)
  ) %>%
  select(-D.Item_clean, -Ingredient_Name)

# -------- 4) Presence AFTER corrections --------------------------------------
ingredient_names_after <- merged_metadata$Animals.Diet %>%
  transmute(B.Code, Diet = clean_name(A.Level.Name)) %>% distinct()

feedintake_names_after <- merged_metadata$Data.Out %>%
  filter(Out.Subind == "Feed Intake", !is.na(A.Level.Name)) %>%
  transmute(B.Code, Diet = clean_name(A.Level.Name)) %>% distinct()

dietcomp_names_after <- merged_metadata$Animals.Diet.Comp %>%
  filter(is_entire_diet == TRUE) %>%
  transmute(B.Code, Diet = clean_name(D.Item)) %>% distinct()

digest_names_after <- merged_metadata$Animals.Diet.Digest %>%
  filter(is_entire_diet == TRUE) %>%
  transmute(B.Code, Diet = clean_name(D.Item)) %>% distinct()

presence_after <- bind_rows(
  ingredient_names_after %>% mutate(Source = "Ingredient"),
  feedintake_names_after %>% mutate(Source = "FeedIntake"),
  dietcomp_names_after %>% mutate(Source = "DietComp"),
  digest_names_after %>% mutate(Source = "Digest")
) %>%
  mutate(val = 1L) %>%
  pivot_wider(names_from = Source, values_from = val, values_fill = 0L) %>%
  arrange(B.Code, Diet)

# Optional quick summaries
alignment_summary_before <- presence_before %>%
  summarise(
    n_rows = n(),
    full_matches = sum(Ingredient==1 & FeedIntake==1 & DietComp==1 & Digest==1),
    any_missing = sum(Ingredient + FeedIntake + DietComp + Digest < 4)
  )

alignment_summary_after <- presence_after %>%
  summarise(
    n_rows = n(),
    full_matches = sum(Ingredient==1 & FeedIntake==1 & DietComp==1 & Digest==1),
    any_missing = sum(Ingredient + FeedIntake + DietComp + Digest < 4)
  )

rm(alignment_summary_after,alignment_summary_before,corrections_report_DC,corrections_report_DG,corrections_report_FI,dietcomp_names,dietcomp_names_after,digest_names,digest_names_after,feedintake_names,feedintake_names_after,ingredient_names,ingredient_names_after,presence_after,presence_before,to_correct_DC,to_correct_DG,to_correct_FI)
```


## implement basal diets 

```{r}
library(dplyr)
library(tidyr)

df <- merged_metadata$Animals.Diet   # replace with your object name

# ---------------------------------------------------------
# 1. Separate non-ingredient rows (metadata)
# ---------------------------------------------------------
non_ingredient_rows <- df %>%
  filter(is.na(D.Item))

ingredient_rows <- df %>%
  filter(!is.na(D.Item))

# ---------------------------------------------------------
# 2. Extract true basal ingredients for each study (B.Code)
# ---------------------------------------------------------
basal_tbl <- ingredient_rows %>%
  filter(D.Item.Group == "Base") %>%
  distinct(B.Code, D.Item, .keep_all = TRUE)

# ---------------------------------------------------------
# 3. Identify all treatments per study
# ---------------------------------------------------------
treatments_tbl <- df %>%
  distinct(B.Code, Treatment = A.Level.Name)

# ---------------------------------------------------------
# 4. Replicate basal ingredients across all treatments
# ---------------------------------------------------------
basal_expanded <- basal_tbl %>%
  select(-A.Level.Name) %>%          # remove original treatment
  right_join(treatments_tbl, by = "B.Code") %>%
  rename(A.Level.Name = Treatment) %>%
  distinct()

# ---------------------------------------------------------
# 5. Remove incorrect basal rows from ingredient dataset
# ---------------------------------------------------------
ingredient_no_basal <- ingredient_rows %>%
  filter(!(D.Item.Group == "Base" & !is.na(D.Item.Group)))

# ---------------------------------------------------------
# 6. Recombine to get the fixed dataset
# ---------------------------------------------------------
merged_metadata$Animals.Diet <- bind_rows(
  non_ingredient_rows,      # keep metadata rows unchanged
  ingredient_no_basal,      # keep supplement items unchanged
  basal_expanded            # correct basal items across treatments
) %>%
  distinct()


rm(basal_expanded,basal_tbl,df,ingredient_no_basal,ingredient_rows,non_ingredient_rows,treatments_tbl)

```
## get amounts for adlib ingredients 

```{r}
merged_metadata$Animals.Diet <- merged_metadata$Animals.Diet %>%
  filter(!(D.Ad.lib == "Yes" & is.na(D.Item)))


## remove all the rows for which we have entire diet and ad lib because no matter what we are going to infer it from feed intake 


```

## 1.3) Correct ingredient units 

Some ingredients appear multiple times with amounts reported in different units. In this section, we prioritize entries that are already in preferred units to minimize the need for conversions.

```{r,message=FALSE,warning=FALSE}
## keep ingredient that appear twice with different units only once 

# Define your unit preferences
preferred_units <- c("g", "kg")
preferred_time <- "day"
preferred_animals <- "individual"

# Prioritize and deduplicate
merged_metadata$Animals.Diet <- merged_metadata$Animals.Diet %>%
  # Add a priority score to sort by best rows
  mutate(
    priority = case_when(
      D.Unit.Amount %in% preferred_units &
        D.Unit.Time == preferred_time &
        D.Unit.Animals == preferred_animals ~ 1,
      TRUE ~ 2  # lower priority
    )
  ) %>%
  group_by(B.Code, A.Level.Name, D.Item) %>%
  slice_min(order_by = priority, with_ties = FALSE) %>%
  ungroup() %>%
  select(-priority)  # optional: drop helper column

rm(preferred_units,preferred_time,preferred_animals)


### correct extraction errors 

merged_metadata$Animals.Diet.Comp <- merged_metadata$Animals.Diet.Comp %>%
  mutate(
    DC.Value = ifelse(
      B.Code == "BO1006" &
      DC.Variable == "Ash" &
      D.Item == "Ration 2" & 
      as.numeric(DC.Value) == 628,
      6.28,
      DC.Value
    )
  )


```

```{r}

# Define species of interest
species_list <- c("Cattle", "Sheep", "Goat")

# Initialize result containers
species_summary <- list()
bcode_table <- list()

# Loop over each species
for (species in species_list) {
  
  # All B.Codes for this species
  species_bcodes <- merged_metadata$Prod.Out %>%
    filter(P.Product == species) %>%
    pull(B.Code) %>%
    unique()
  
  # Feed intake B.Codes
  feed_data <- merged_metadata$Data.Out %>%
    filter(B.Code %in% species_bcodes, !is.na(ED.Mean.T)) %>%
    filter(Out.Subind=="Feed Intake")%>%
    select(B.Code, D.Item = ED.Intake.Item)
  
  feed_bcodes <- unique(feed_data$B.Code)
  
  # GE B.Codes
  ge_data <- merged_metadata$Animals.Diet.Comp %>%
    filter(B.Code %in% species_bcodes, DC.Variable == "GE", !is.na(DC.Value)) %>%
    select(B.Code, D.Item)
  
  ge_bcodes <- unique(ge_data$B.Code)
  
  # Matched B.Codes (join on both B.Code and D.Item)
  matched_bcodes <- inner_join(feed_data, ge_data, by = c("B.Code", "D.Item")) %>%
    pull(B.Code) %>%
    unique()
  
  # Store species-level summary
  species_summary[[species]] <- tibble(
    Species = species,
    Total_BCodes = length(species_bcodes),
    With_FEED = length(feed_bcodes),
    With_GE = length(ge_bcodes),
    With_BOTH = length(matched_bcodes)
  )
  
  # Store long-format bcode list
  bcode_table[[species]] <- tibble(
    B.Code = c(species_bcodes, feed_bcodes, ge_bcodes, matched_bcodes),
    Category = rep(c("All", "With_FEED", "With_GE", "With_BOTH"), 
                   times = c(length(species_bcodes), length(feed_bcodes), length(ge_bcodes), length(matched_bcodes))),
    Species = species
  ) %>% distinct()
}

# Bind results
species_summary_df <- bind_rows(species_summary)
bcode_table_df <- bind_rows(bcode_table)

```



### to do 
```{r}
to_be_categorized<-merged_metadata$Animals.Diet%>%
  filter(is.na(D.Item))%>%
  filter(D.Type!="Entire Diet")

```


## 1.5) Summary of the data 
```{r,message=FALSE,warning=FALSE}

# Define species of interest
species_list <- c("Cattle", "Sheep", "Goat")

# Initialize result containers
species_summary <- list()
bcode_table <- list()

# Loop over each species
for (species in species_list) {
  
  # All B.Codes for this species
  species_bcodes <- merged_metadata$Prod.Out %>%
    filter(P.Product == species) %>%
    pull(B.Code) %>%
    unique()
  
  # Feed intake B.Codes
  feed_data <- merged_metadata$Data.Out %>%
    filter(B.Code %in% species_bcodes, !is.na(ED.Mean.T)) %>%
    filter(Out.Subind=="Feed Intake")%>%
    select(B.Code, D.Item = ED.Intake.Item)
  
  feed_bcodes <- unique(feed_data$B.Code)
  
  # GE B.Codes
  ge_data <- merged_metadata$Animals.Diet.Comp %>%
    filter(B.Code %in% species_bcodes, DC.Variable == "GE", !is.na(DC.Value)) %>%
    select(B.Code, D.Item)
  
  ge_bcodes <- unique(ge_data$B.Code)
  
  # Matched B.Codes (join on both B.Code and D.Item)
  matched_bcodes <- inner_join(feed_data, ge_data, by = c("B.Code", "D.Item")) %>%
    pull(B.Code) %>%
    unique()
  
  # Store species-level summary
  species_summary[[species]] <- tibble(
    Species = species,
    Total_BCodes = length(species_bcodes),
    With_FEED = length(feed_bcodes),
    With_GE = length(ge_bcodes),
    With_BOTH = length(matched_bcodes)
  )
  
  # Store long-format bcode list
  bcode_table[[species]] <- tibble(
    B.Code = c(species_bcodes, feed_bcodes, ge_bcodes, matched_bcodes),
    Category = rep(c("All", "With_FEED", "With_GE", "With_BOTH"), 
                   times = c(length(species_bcodes), length(feed_bcodes), length(ge_bcodes), length(matched_bcodes))),
    Species = species
  ) %>% distinct()
}

# Bind results
species_summary_df <- bind_rows(species_summary)
bcode_table_df <- bind_rows(bcode_table)

```



## 2) Harmonize units of ingredient amounts
This step standardizes ingredient amount units (e.g., from mg, kg, %, etc.) to a consistent base (usually grams per individual per day), ensuring reliable downstream calculations and comparisons.

```{r,message=FALSE,warning=FALSE}
# Diet ingredients: breakdown of all ingredients within each diet
ingredients <- merged_metadata$Animals.Diet %>%
  mutate(D.Amount = as.numeric(D.Amount)) %>% 
  filter(!is.na(D.Item))  # keep only ingredient rows (no "entire diet" metadata)

# Function to harmonize diet ingredient units
harmonize_units <- function(df) {
  df %>%
    mutate(
      # Record original units
      Units = paste(D.Unit.Amount, D.Unit.Time, D.Unit.Animals, sep = ";")
    ) %>%
    
    # ------------------------------------------------------------------
    # 1) Harmonise weight / volume units (may change D.Amount)
    # ------------------------------------------------------------------
    mutate(
      D.Amount = case_when(
        D.Unit.Amount %in% c("kg", "mg", "g/100g", "l", "kg/t", "g/300l",
                             "mg/kg", "kg/100kg", "kg/100kg body weight",
                             "kg/kg metabolic weight", "g/kg metabolic weight (0.75)",
                             "g/kg DMI", "g/L", "g/kg DM") ~ {
          case_when(
            D.Unit.Amount == "kg"                         ~ D.Amount * 1000,
            D.Unit.Amount == "mg"                         ~ D.Amount / 1000,
            D.Unit.Amount == "g/100g"                     ~ D.Amount * 10,
            D.Unit.Amount == "l"                          ~ D.Amount * 1000,
            D.Unit.Amount == "kg/t"                       ~ D.Amount,          # already g/kg after relabel
            D.Unit.Amount == "g/300l"                     ~ D.Amount / 300,
            D.Unit.Amount == "mg/kg"                      ~ D.Amount / 1000,
            D.Unit.Amount %in% c("kg/100kg",
                                 "kg/100kg body weight")  ~ D.Amount * 10,
            D.Unit.Amount == "kg/kg metabolic weight"     ~ D.Amount * 1000,
            D.Unit.Amount %in% c("g/kg body weight (0.75)",
                                 "g/kg Body Weight (0.75)",
                                 "g/kg metabolic weight (0.75)") ~ D.Amount,
            D.Unit.Amount == "g/kg DMI"                   ~ D.Amount,
            D.Unit.Amount == "g/kg DM"                    ~ D.Amount,
            TRUE                                          ~ D.Amount
          )
        },
        TRUE ~ D.Amount
      ),
      
      # Canonical D.Unit.Amount labels
      D.Unit.Amount = case_when(
        D.Unit.Amount == "kg"                 ~ "g",
        D.Unit.Amount == "mg"                 ~ "g",
        D.Unit.Amount == "g/100g"             ~ "g/kg",
        D.Unit.Amount == "l"                  ~ "ml",
        D.Unit.Amount == "kg/t"               ~ "g/kg",
        D.Unit.Amount == "g/300l"             ~ "g/L",
        D.Unit.Amount == "mg/kg"              ~ "g/kg",
        D.Unit.Amount %in% c("kg/100kg",
                             "kg/100kg body weight") ~ "g/kg body weight",
        D.Unit.Amount %in% c("g/kg body weight (0.75)",
                             "g/kg Body Weight (0.75)",
                             "g/kg metabolic weight (0.75)") ~ "g/kg metabolic weight",
        D.Unit.Amount == "kg/kg metabolic weight" ~ "g/kg metabolic weight",
        D.Unit.Amount == "g/kg DMI"          ~ "g/kg",
        D.Unit.Amount == "g/kg DM"           ~ "g/kg",
        D.Unit.Amount == "g/L"               ~ "g/L",
        D.Unit.Amount == "g/kg Body Weight"  ~ "g/kg body weight",
        TRUE                                 ~ D.Unit.Amount
      )
    ) %>%
    
    # ------------------------------------------------------------------
    # 2) Define “relative / composition” units where time/animal do NOT
    #    affect the numeric amount
    # ------------------------------------------------------------------
    mutate(
      is_relative = D.Unit.Amount %in% c(
        "%", "% Diet", "% Concentrate",
        "g/kg", "g/kg DM", "g/kg DMI",
        "g/L"
      )
    ) %>%
    
    # ------------------------------------------------------------------
    # 3) Harmonise time units to "day"
    #    → Only change D.Amount when NOT relative
    # ------------------------------------------------------------------
    mutate(
      D.Amount = case_when(
        !is_relative & D.Unit.Time == "week"            ~ D.Amount / 7,
        !is_relative & D.Unit.Time == "month"           ~ D.Amount / 30,
        !is_relative & D.Unit.Time == "2 weeks"         ~ D.Amount / 14,
        !is_relative & D.Unit.Time == "4 days interval" ~ D.Amount / 4,
        !is_relative & D.Unit.Time == "2x/day"          ~ D.Amount * 2,
        TRUE                                            ~ D.Amount
      ),
      D.Unit.Time = case_when(
        D.Unit.Time %in% c("week", "month", "2 weeks",
                           "4 days interval", "2x/day") ~ "day",
        D.Unit.Time == "experiment"                     ~ D.Unit.Time,
        TRUE                                            ~ D.Unit.Time
      )
    ) %>%
    
    # ------------------------------------------------------------------
    # 4) Standardise animal unit labels (no scaling here)
    #    → we’ll do numeric scaling later and *skip* relative units
    # ------------------------------------------------------------------
    mutate(
      D.Unit.Animals = case_when(
        is_relative & is.na(D.Unit.Animals) ~ "individual",
        TRUE                                ~ D.Unit.Animals
      )
    ) %>%
    
    # ------------------------------------------------------------------
    # 5) Drop units if amount is NA
    # ------------------------------------------------------------------
    mutate(
      D.Unit.Amount  = ifelse(is.na(D.Amount), NA_character_, D.Unit.Amount),
      D.Unit.Time    = ifelse(is.na(D.Amount), NA_character_, D.Unit.Time),
      D.Unit.Animals = ifelse(is.na(D.Amount), NA_character_, D.Unit.Animals)
    )
}

# Apply harmonization
ingredients <- harmonize_units(ingredients)

# Load replicate info
reps <- merged_metadata$MT.Out %>%
  mutate(T.Animals = as.numeric(T.Animals)) %>%
  distinct(B.Code, A.Level.Name, .keep_all = TRUE)

# Adjust for 'all animals in replicate'
# → Only scale for *absolute* units (NOT for composition units)
ingredients <- ingredients %>%
  left_join(reps %>% dplyr::select(B.Code, A.Level.Name, T.Animals),
            by = c("B.Code", "A.Level.Name")) %>%
  mutate(
    is_relative = D.Unit.Amount %in% c(
      "%", "% Diet", "% Concentrate",
      "g/kg", "g/kg DM", "g/kg DMI",
      "g/L"
    ),
    D.Amount = case_when(
      D.Unit.Animals == "all animals in replicate" &
        !is.na(T.Animals) & !is_relative ~ D.Amount / T.Animals,
      TRUE ~ D.Amount
    ),
    D.Unit.Animals = ifelse(D.Unit.Animals == "all animals in replicate",
                            "individual", D.Unit.Animals)
  ) %>%
  select(-is_relative)

# Refresh Units column
ingredients <- ingredients %>%
  mutate(Units = paste(D.Unit.Amount, D.Unit.Time, D.Unit.Animals, sep = ";"))

# Cleanup
rm(harmonize_units, reps)

```


### 1.6) remove experimental scales because no times and then amounts are too big 

```{r}
# 1) Define relative / composition units
relative_units <- c(
  "%", "% Diet", "% Basal Diet", "% Body Mass", "% Herbaceous Cover",
  "% Shrub Species", "% of concentrate", "% concentrate", "% Concentrate",
  "% of supplement", "% Grass Hay Mixture", "% of Total Grazing Area",
  "% of Control Diet(Natural Pasture Hay)", "% single cell protein",
  "estimated % Body Mass",
  "g/kg", "g/kg metabolic weight", "g/kg body weight", "g/kg  Maize Grain",
  "g/kg DM", "g/kg DMI",
  "g/L", "g/10 L water", "g/Nitrogen",
  "ml/L of water"  # also relative to a carrier
)

# 2) Drop only *absolute* experiment-scale doses
ingredients <- ingredients %>%
  filter(
    # keep all rows that are NOT experiment-scale
    D.Unit.Time != "experiment" |
      # or, if they are experiment-scale, keep only if the unit is relative
      D.Unit.Amount %in% relative_units
  )


# --- Fix unit representation for LM0128 to "g day individual" -------------------
ingredients <- ingredients %>%
  mutate(
    # Convert mg → g for LM0128
    D.Amount = if_else(B.Code == "LM0128" & D.Unit.Amount == "mg",
                       D.Amount / 1000,   # convert mg to g
                       D.Amount),
    # Update all relevant unit fields for LM0128
    D.Unit.Amount = if_else(B.Code == "LM0128", "g", D.Unit.Amount),
    D.Unit.Time = if_else(B.Code == "LM0128", "day", D.Unit.Time),
    D.Unit.Animals = if_else(B.Code == "LM0128", "individual", D.Unit.Animals),
    # Combine them into a single standardized unit descriptor
    D.Unit.Standard = if_else(B.Code == "LM0128",
                              "g day individual",
                              paste(D.Unit.Amount, D.Unit.Time, D.Unit.Animals))
  )

merged_metadata$Animals.Diet <- merged_metadata$Animals.Diet %>%
  mutate(
    # Convert mg → g for LM0128
    D.Amount = if_else(B.Code == "LM0128" & D.Unit.Amount == "mg",
                       D.Amount / 1000,   # convert mg to g
                       D.Amount),
    # Update all relevant unit fields for LM0128
    D.Unit.Amount = if_else(B.Code == "LM0128", "g", D.Unit.Amount),
    D.Unit.Time = if_else(B.Code == "LM0128", "day", D.Unit.Time),
    D.Unit.Animals = if_else(B.Code == "LM0128", "individual", D.Unit.Animals),
    # Combine them into a single standardized unit descriptor
    D.Unit.Standard = if_else(B.Code == "LM0128",
                              "g day individual",
                              paste(D.Unit.Amount, D.Unit.Time, D.Unit.Animals))
  )

```

### 2.1) Suspicious dry amounts TO DO ADD IN ERA DEV 

This chunk systematically fills in missing “DC.Is.Dry” flags by combining three complementary sources—analytical moisture/DM thresholds, name‐based cues (e.g. “dried,” “meal”), and broad feed/supplement rules—and then, where every measurable ingredient in a treatment is already known to be dry, assumes the lab used the same dry‐prep protocol for all feeds in that trial. By layering data‑driven thresholds, text mining, and a diet‑level consistency override, we ensure that no ingredient in a truly dried regimen slips through unflagged, while still preserving fresh‐vs.‐dry distinctions in mixed rations.

```{r}
# ------------------------------------------------------------
# DRY flag with strict rule:
# 1) Use Moisture/DM thresholds when available (authoritative).
# 2) If NO Moisture/DM for an item, assume DRY ("Yes").
# 3) Diet-arm propagation: if all flagged items in the arm are "Yes",
#    fill any remaining NA in that arm with "Yes".
# 4) Drop "water" rows.
# No name/blanket/majority heuristics.
# ------------------------------------------------------------

# --- 1) Moisture/DM-based evidence per (B.Code, D.Item) ---------------------
dry_evidence <- bind_rows(
  # a) Moisture rules
  merged_metadata$Animals.Diet.Comp %>%
    filter(str_to_lower(DC.Variable) %in% c("moisture","moist")) %>%
    transmute(
      B.Code, D.Item,
      Predictor = "Moisture",
      Value = suppressWarnings(as.numeric(DC.Value)),
      Unit  = str_to_lower(str_squish(DC.Unit)),
      Dry_Prediction = dplyr::case_when(
        Unit %in% c("%","% dm","g/100g") ~ dplyr::case_when(
          Value <  15 ~ TRUE,   # low moisture ⇒ dry
          Value >  50 ~ FALSE,  # very wet     ⇒ not dry
          TRUE        ~ NA
        ),
        Unit == "g/kg" ~ dplyr::case_when(
          Value < 150 ~ TRUE,
          Value > 500 ~ FALSE,
          TRUE        ~ NA
        ),
        TRUE ~ NA
      )
    ),
  # b) DM rules
  merged_metadata$Animals.Diet.Comp %>%
    filter(str_to_lower(DC.Variable) == "dm") %>%
    transmute(
      B.Code, D.Item,
      Predictor = "DM",
      Value = suppressWarnings(as.numeric(DC.Value)),
      Unit  = str_to_lower(str_squish(DC.Unit)),
      Dry_Prediction = dplyr::case_when(
        Unit %in% c("%","% dm","g/100g") ~ dplyr::case_when(
          Value >  85 ~ TRUE,   # high DM ⇒ dry
          Value <  50 ~ FALSE,  # low  DM ⇒ not dry
          TRUE        ~ NA
        ),
        Unit == "g/kg" ~ dplyr::case_when(
          Value > 850 ~ TRUE,
          Value < 500 ~ FALSE,
          TRUE        ~ NA
        ),
        TRUE ~ NA
      )
    )
) %>%
  # keep one prediction per predictor per key (first non-NA)
  distinct(B.Code, D.Item, Predictor, Dry_Prediction) %>%
  group_by(B.Code, D.Item, Predictor) %>%
  summarise(Dry_Prediction = dplyr::first(na.omit(Dry_Prediction)), .groups = "drop") %>%
  # wide: Dry_Prediction_Moisture, Dry_Prediction_DM
  tidyr::pivot_wider(
    names_from = Predictor,
    values_from = Dry_Prediction,
    names_prefix = "Dry_Prediction_"
  ) %>%
  mutate(
    has_evidence = !is.na(Dry_Prediction_Moisture) | !is.na(Dry_Prediction_DM),
    # precedence: DM beats Moisture when both exist
    Dry_from_evidence = dplyr::case_when(
      !is.na(Dry_Prediction_DM)        ~ Dry_Prediction_DM,
      is.na(Dry_Prediction_DM) &
        !is.na(Dry_Prediction_Moisture) ~ Dry_Prediction_Moisture,
      TRUE                              ~ NA
    )
  ) %>%
  select(B.Code, D.Item, has_evidence, Dry_from_evidence)

# --- 2) Apply evidence to ingredients ---------------------------------------
ingredients <- ingredients %>%
  left_join(dry_evidence, by = c("B.Code","D.Item")) %>%
  mutate(
    # Evidence (DM/Moisture) is authoritative when present
    DC.Is.Dry = dplyr::case_when(
      Dry_from_evidence == TRUE  ~ "Yes",
      Dry_from_evidence == FALSE ~ "No",
      TRUE                       ~ DC.Is.Dry
    )
  )

# --- 3) Diet-level propagation (only fills NA when all flagged in arm are Yes)
ingredients <- ingredients %>%
  group_by(B.Code, A.Level.Name) %>%
  mutate(
    any_flag   = any(!is.na(DC.Is.Dry), na.rm = TRUE),
    all_dry    = all(DC.Is.Dry[!is.na(DC.Is.Dry)] == "Yes")
  ) %>%
  ungroup() %>%
  mutate(
    DC.Is.Dry = dplyr::case_when(
      any_flag & all_dry & is.na(DC.Is.Dry) ~ "Yes",
      TRUE                                  ~ DC.Is.Dry
    )
  ) %>%
  select(-any_flag, -all_dry)

# --- 4) Fallback: assume DRY only when NO Moisture/DM evidence --------------
# (i.e., we cannot decide because there is no proximate data)
ingredients <- ingredients %>%
  mutate(
    DC.Is.Dry = dplyr::case_when(
      is.na(DC.Is.Dry) & (has_evidence %in% c(FALSE, NA)) ~ "Yes",
      TRUE                                                ~ DC.Is.Dry
    )
  ) %>%
  select(-has_evidence, -Dry_from_evidence)

# --- 5) Drop pure "water" rows ----------------------------------------------
ingredients <- ingredients %>%
  filter(!(str_to_lower(D.Item) == "water"))


```




### 2.2) Filter data with acceptable units

We filter the dataset to retain only ingredients with acceptable units. Uncommon or unexpected unit formats are excluded to ensure consistency and simplify downstream processing

```{r,message=FALSE,warning=FALSE}


# Define a list of acceptable units
acceptable_units <- c(
  "g/kg", "g", "%", "ml", "L", "kg", "g/L",
  "g/kg metabolic weight", "% Diet", 
  "g/kg body weight", "ml/kg", "% Body Mass", 
  "% Concentrate", "g/kg body weight"  # leave only one if repeated
)


# Filter rows to keep only acceptable units
ingredients <- ingredients %>%
  filter(D.Unit.Amount %in% acceptable_units | is.na(D.Unit.Amount)) %>%
  mutate(D.Item = ifelse(is.na(D.Item), "Unspecified", D.Item))

#tracking paper loss because of harmnozied units
#total_studies_harmonized<- length(unique(ingredients_harmonized$B.Code))
#total_ingredients_harmonized<- length(unique(ingredients_harmonized$D.Item))
#total_diets_harmonized<- length(unique(ingredients_harmonized$A.Level.Name))

rm(acceptable_units)
```

### 2.3) Convert body weight units by linking animals weight to data
```{r}

# Pre-filter Data.Out to keep only the first non-NA weight per group
# Step 1: From Data.Out — compute unique weights
weights_data <- merged_metadata$Data.Out %>%
  filter(Out.Subind == "Weight Gain") %>%
  mutate(
    Out.WG.Unit = tolower(Out.WG.Unit),
    Out.WG.Start = case_when(
      Out.WG.Unit == "g" ~ Out.WG.Start / 1000,
      Out.WG.Unit == "mg" ~ Out.WG.Start / 1e6,
      Out.WG.Unit %in% c("kg", "unspecified", NA) ~ Out.WG.Start,
      TRUE ~ NA_real_
    ),
    Out.WG.Unit = ifelse(!is.na(Out.WG.Start), "kg", NA_character_)
  ) %>%
  filter(!is.na(Out.WG.Start)) %>%
  group_by(B.Code, A.Level.Name) %>%
  summarise(
    Out.WG.Start = mean(Out.WG.Start, na.rm = TRUE),
    Out.WG.Unit = "kg",
    .groups = "drop"
  )

# Step 2: From MT.Out — extract matching weight data
weights_mt <- merged_metadata$MT.Out %>%
  select(B.Code, A.Level.Name, Out.WG.Start, Out.WG.Unit) %>%
  filter(!is.na(Out.WG.Start)) %>%
  mutate(
    Out.WG.Start = as.numeric(Out.WG.Start),              # <- force numeric
    Out.WG.Unit = tolower(as.character(Out.WG.Unit)),     # <- force character and lowercase
    Out.WG.Start = case_when(
      Out.WG.Unit == "g" ~ Out.WG.Start / 1000,
      Out.WG.Unit == "mg" ~ Out.WG.Start / 1e6,
      Out.WG.Unit %in% c("kg", "unspecified", NA) ~ Out.WG.Start,
      TRUE ~ NA_real_
    ),
    Out.WG.Unit = ifelse(!is.na(Out.WG.Start), "kg", NA_character_)
  ) %>%
  distinct(B.Code, A.Level.Name, .keep_all = TRUE)


# Step 3: Combine both sources, then de-duplicate (keep priority if desired)
weights_unique <- bind_rows(weights_data, weights_mt) %>%
  arrange(B.Code, A.Level.Name) %>%
  distinct(B.Code, A.Level.Name, .keep_all = TRUE)




# Step 3: Join body weight and keep only ingredients with weight
ingredients <- ingredients %>%
  left_join(
    weights_unique,
    by = c("B.Code", "A.Level.Name")) 


# Step 4: Convert D.Amount to grams based on body weight and update unit accordingly
ingredients <- ingredients %>%
  mutate(
    # Recalculate D.Amount using body weight or metabolic weight, result in kg
    D.Amount = case_when(
      D.Unit.Amount == "g/kg body weight" & !is.na(Out.WG.Start) ~ (D.Amount * Out.WG.Start) / 1000,
      D.Unit.Amount == "g/kg metabolic weight" & !is.na(Out.WG.Start) ~ (D.Amount * Out.WG.Start^0.75) / 1000,
      D.Unit.Amount == "% Body Mass" & !is.na(Out.WG.Start) ~ ((D.Amount / 100) * Out.WG.Start),
      TRUE ~ D.Amount  # unchanged if not convertible
    ),

    # Update unit to "kg" if recalculated
    D.Unit.Amount = case_when(
      D.Unit.Amount %in% c("g/kg body weight", "g/kg metabolic weight", "% Body Mass") &
        !is.na(Out.WG.Start) ~ "kg",
      TRUE ~ D.Unit.Amount
    )
  )


```

### 2.4) Estimate amounts using feed intake

For ingredients reported in relative units such as %, % Diet, or g/kg, we can estimate their absolute amounts when total diet feed intake is available. This allows us to convert proportions into standardized quantities.


```{r}
missing_unit_feed_intake<- merged_metadata$Data.Out %>%
  select(B.Code, A.Level.Name, ED.Intake.Item, ED.Intake.Item.Raw,
         ED.Mean.T, ED.Error, Out.Unit, Out.Subind,is_entire_diet,Source,Out.Code.Joined) %>%
  filter(Out.Subind == "Feed Intake") %>%
  filter(is.na(Out.Unit))

#correection of errors ientitief by below script on intakes units suspicious 
# ─────────────────────────────────────────────────────────────
#  PRE-CLEANING: Fix known feed-intake unit inconsistencies
# ─────────────────────────────────────────────────────────────
# ─────────────────────────────────────────────────────────────
#  PRE-CLEANING: Fix known feed-intake unit inconsistencies
# ─────────────────────────────────────────────────────────────
# ─────────────────────────────────────────────────────────────
#  PRE-CLEANING (applied directly to merged_metadata$Data.Out)
# ─────────────────────────────────────────────────────────────
merged_metadata$Data.Out <- merged_metadata$Data.Out %>%
  mutate(
    Out.Unit = tolower(trimws(Out.Unit))
  ) %>%
  mutate(
    # AG0051: feed intake units should be kg/day (values 8–9 kg realistic)
    Out.Unit = if_else(
      B.Code == "AG0051" & str_detect(Out.Unit, "^g") & str_detect(Out.Code.Joined, "^Feed Intake"),
      "kg/individual/day", Out.Unit
    ),

    # NN0212: entire-diet feed intake given in g/day (~70 g/day realistic)
    Out.Unit = if_else(
      B.Code == "NN0212" & str_detect(Out.Unit, "^g") & str_detect(Out.Code.Joined, "^Feed Intake"),
      "g dm/kg body weight (0.75)", Out.Unit
    ),

    # LM0104: values stored as kg but actually grams per individual per day
    Out.Unit = if_else(
      B.Code == "LM0104" & str_detect(Out.Unit, "^kg") & str_detect(Out.Code.Joined, "^Feed Intake"),
      "g/individual/day",  # or "g dm/individual/day" if you know it's DM
      Out.Unit
    ),

    # NN0217: some rows use kg/day but actually g/kg metabolic weight
    Out.Unit = case_when(
      B.Code == "NN0217" & str_detect(Out.Unit, "kg dm/individual/day") & str_detect(Out.Code.Joined, "^Feed Intake") ~
        "g dm/individual/day",
      TRUE ~ Out.Unit
    ),
    Out.Unit = case_when(
      B.Code == "NN0234" & str_detect(Out.Unit, "kg dm/individual/day") & str_detect(Out.Code.Joined, "^Feed Intake") ~
        "g dm/individual/day",
      TRUE ~ Out.Unit
    ),

    # Generic cleanup for all cases
    Out.Unit = str_replace_all(Out.Unit, "dm\\s*/", "dm/"),
    Out.Unit = str_replace_all(Out.Unit, "//", "/"),
    Out.Unit = str_trim(Out.Unit)
  )


```


#### 2.4.1) Harmonization of feed intake data

# when there are more than one feed intake for the same thing but different units 

```{r}
# ============================================================
# De-duplicate feed-intake rows in Data.Out by unit preference
# ============================================================

# Work on a lowercase / trimmed version of Out.Unit first
merged_metadata$Data.Out <- merged_metadata$Data.Out %>%
  mutate(
    Out.Unit = tolower(trimws(Out.Unit))
  )

# Split feed-intake vs other outputs
data_out_feed <- merged_metadata$Data.Out %>%
  filter(Out.Subind == "Feed Intake")

data_out_other <- merged_metadata$Data.Out %>%
  filter(Out.Subind != "Feed Intake")

# Define preferences for feed-intake units
# (adjust this list if needed)
data_out_feed <- data_out_feed %>%
  mutate(
    priority = case_when(
      # best: already in kg/individual/day (or DM version)
      Out.Unit %in% c("kg/individual/day", "kg dm/individual/day") ~ 1L,

      # second-best: g per individual per day
      Out.Unit %in% c("g/individual/day", "g dm/individual/day") ~ 2L,

      # everything else (e.g. g dm/kg bw^0.75, %, etc.)
      TRUE ~ 3L
    )
  ) %>%
  group_by(B.Code, A.Level.Name, ED.Intake.Item) %>%
  arrange(
    priority,                 # 1 < 2 < 3
    desc(!is.na(ED.Error))    # within same priority, prefer rows with an SE
  ) %>%
  slice(1) %>%                # keep only the best row per diet
  ungroup() %>%
  select(-priority)

# Recombine with all non-feed-intake rows
merged_metadata$Data.Out <- bind_rows(
  data_out_other,
  data_out_feed
) %>%
  arrange(B.Code, A.Level.Name, Out.Subind)

```


```{r}
# ============================================================
# Build clean feed_intake table (kg DM or kg fresh / animal / day)
# Drop BW-based intakes if no body weight is available
# ============================================================

library(dplyr)
library(stringr)
library(forcats)

# ---- 1) Extract and parse feed-intake rows ------------------

feed_intake <- merged_metadata$Data.Out %>%
  select(
    B.Code, A.Level.Name, ED.Intake.Item, ED.Intake.Item.Raw,
    ED.Mean.T, ED.Error, Out.Unit, Out.Subind, P.Product,
    is_entire_diet, is_group, T.Animals
  ) %>%
  filter(Out.Subind == "Feed Intake") %>%
  filter(!is.na(ED.Mean.T)) %>%
  # normalise "entire diet" label
  mutate(
    is_entire = is.na(ED.Intake.Item.Raw) | ED.Intake.Item.Raw == "",
    ED.Intake.Item.Raw = if_else(is_entire, "Entire Diet", ED.Intake.Item.Raw),
    ED.Intake.Item     = if_else(is_entire, "Entire Diet", ED.Intake.Item)
  ) %>%
  select(-is_entire) %>%
  # parse unit into amount / animals / time
  mutate(
    Out.Unit = tolower(trimws(Out.Unit)),
    # default when unit is NA or empty: g/individual/day
    Out.Unit = if_else(is.na(Out.Unit) | Out.Unit == "", "g/individual/day", Out.Unit),

    Out.Unit.Animals = str_extract(Out.Unit, "\\b(individual|replicate|animal replicate)\\b"),
    Out.Unit.Time    = str_extract(Out.Unit, "\\b(day|d|yr|year|experiment)\\b"),
    Out.Unit.Amount  = Out.Unit %>%
      str_remove_all("\\b(individual|replicate|animal replicate)\\b") %>%
      str_remove_all("\\b(day|d|yr|year|experiment)\\b") %>%
      str_replace_all("/+", "/") %>%
      str_trim() %>%
      str_remove("/$")
  )

# ---- 2) Convert replicate-level intake to individual-level ---

feed_intake <- feed_intake %>%
  mutate(
    ED.Mean.T = as.numeric(ED.Mean.T),
    T.Animals = as.numeric(T.Animals),

    # replicate -> individual
    ED.Mean.T = case_when(
      Out.Unit.Animals == "replicate" & !is.na(T.Animals) & T.Animals > 0 ~ ED.Mean.T / T.Animals,
      TRUE ~ ED.Mean.T
    ),
    Out.Unit.Animals = case_when(
      Out.Unit.Animals == "replicate" & !is.na(T.Animals) & T.Animals > 0 ~ "individual",
      TRUE ~ Out.Unit.Animals
    )
  ) %>%
  mutate(
    Out.Unit = case_when(
      !is.na(Out.Unit.Amount) & !is.na(Out.Unit.Animals) & !is.na(Out.Unit.Time) ~
        paste0(Out.Unit.Amount, "/", Out.Unit.Animals, "/", Out.Unit.Time),
      !is.na(Out.Unit.Amount) & !is.na(Out.Unit.Animals) ~
        paste0(Out.Unit.Amount, "/", Out.Unit.Animals),
      TRUE ~ Out.Unit
    )
  )

# ---- 3) Normalise parsed unit parts for matching -------------

feed_intake_norm <- feed_intake %>%
  mutate(
    Out.Unit.Animals = tolower(Out.Unit.Animals) %>%
      str_replace("^animal replicate$", "replicate"),
    Out.Unit.Time = tolower(Out.Unit.Time) %>%
      recode("d" = "day", "yr" = "year"),
    Out.Unit.Amount = tolower(Out.Unit.Amount) %>%
      str_squish()
  )

# preferences for deduplicating multiple units for same diet item
preferred_units   <- c("kg dm", "kg", "g dm", "g")  # dm first, then fresh
preferred_time    <- "day"
preferred_animals <- "individual"

# ---- 4) Prioritise and keep one row per (paper × diet item) --

feed_intake <- feed_intake_norm %>%
  mutate(
    priority = case_when(
      Out.Unit.Amount %in% preferred_units &
        Out.Unit.Time == preferred_time &
        Out.Unit.Animals == preferred_animals &
        !is.na(ED.Error) ~ 1L,
      Out.Unit.Amount %in% preferred_units &
        Out.Unit.Time == preferred_time &
        Out.Unit.Animals == preferred_animals ~ 2L,
      TRUE ~ 3L
    ),
    unit_rank = match(Out.Unit.Amount, preferred_units)
  ) %>%
  group_by(B.Code, A.Level.Name, ED.Intake.Item) %>%
  arrange(
    priority,
    desc(Out.Unit.Time == "day"),
    desc(Out.Unit.Animals == "individual"),
    unit_rank,
    !is.na(ED.Error)
  ) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority, -unit_rank)

# ---- 5) Join body weight and fill within animal level --------

feed_intake <- feed_intake %>%
  left_join(
    weights_unique %>%
      select(B.Code, A.Level.Name, Out.WG.Start, Out.WG.Unit),
    by = c("B.Code", "A.Level.Name")
  ) %>%
  group_by(A.Level.Name) %>%
  mutate(
    Out.WG.Start = ifelse(
      is.na(Out.WG.Start),
      first(na.omit(Out.WG.Start)),
      Out.WG.Start
    )
  ) %>%
  ungroup() %>%
  distinct()

# ---- 6) Convert ED.Mean.T to kg/day where possible -----------

feed_intake <- feed_intake %>%
  mutate(
    Out.Unit       = trimws(tolower(Out.Unit)),
    Out.Unit.Amount = trimws(str_remove(Out.Unit.Amount, "/$")),

    # numeric conversion
    ED.Mean.T = case_when(
      Out.Unit.Amount %in% c("g", "g dm") ~ ED.Mean.T / 1000,
      Out.Unit.Amount %in% c("kg", "kg dm") ~ ED.Mean.T,
      Out.Unit.Amount == "g dm/100 g" ~ ED.Mean.T * 10 / 1000,
      Out.Unit.Amount == "g/week" ~ ED.Mean.T / 7 / 1000,
      Out.Unit.Amount == "mg" ~ ED.Mean.T / 1e6,

      # body-weight–based conversions only if BW available
      Out.Unit.Amount %in% c("g dm/kg metabolic weight", "g/kg metabolic weight", "g dm/kg metabolic weight") &
        !is.na(Out.WG.Start) ~ (ED.Mean.T * Out.WG.Start^0.75) / 1000,

      Out.Unit.Amount == "kg dm/kg metabolic weight" &
        !is.na(Out.WG.Start) ~ ED.Mean.T * Out.WG.Start^0.75,

      Out.Unit.Amount %in% c("g dm/kg body weight", "g/kg body weight", "g/g body weight") &
        !is.na(Out.WG.Start) ~ (ED.Mean.T * Out.WG.Start) / 1000,

      Out.Unit.Amount %in% c("g/kg body weight (0.75)", "g dm/kg body weight (0.75)") &
        !is.na(Out.WG.Start) ~ (ED.Mean.T * Out.WG.Start^0.75) / 1000,

      Out.Unit.Amount %in% c("% body weight", "dm % body weight") &
        !is.na(Out.WG.Start) ~ (ED.Mean.T / 100) * Out.WG.Start,

      TRUE ~ ED.Mean.T
    ),

    # only update unit if we actually converted to kg
    Out.Unit.Amount = case_when(
      Out.Unit.Amount %in% c("g", "g dm", "g dm/100 g", "g/week", "mg", "kg dm") ~ "kg",
      Out.Unit.Amount %in% c("g/kg body weight", "g dm/kg body weight", "g/g body weight") &
        !is.na(Out.WG.Start) ~ "kg",
      Out.Unit.Amount %in% c("g/kg metabolic weight", "g dm/kg metabolic weight") &
        !is.na(Out.WG.Start) ~ "kg",
      Out.Unit.Amount == "kg dm/kg metabolic weight" &
        !is.na(Out.WG.Start) ~ "kg",
      Out.Unit.Amount %in% c("g/kg body weight (0.75)", "g dm/kg body weight (0.75)") &
        !is.na(Out.WG.Start) ~ "kg",
      Out.Unit.Amount %in% c("% body weight", "dm % body weight") &
        !is.na(Out.WG.Start) ~ "kg",
      TRUE ~ Out.Unit.Amount
    )
  ) %>%
  select(-Out.Unit)

# ---- 7) DROP BW-based rows with NO body weight ---------------

feed_intake <- feed_intake %>%
  filter(
    !(
      str_detect(Out.Unit.Amount, "body weight|metabolic weight") &
      is.na(Out.WG.Start)
    )
  )

# ---- 8) Retain the most interpretable row per intake item ----

feed_intake <- feed_intake %>%
  group_by(B.Code, A.Level.Name, ED.Intake.Item.Raw) %>%
  arrange(
    desc(!is.na(ED.Mean.T)),
    desc(Out.Unit.Amount == "kg"),
    desc(Out.Unit.Animals == "individual"),
    desc(Out.Unit.Time == "day")
  ) %>%
  slice(1) %>%
  ungroup()

# ---- 9) Remove experiment-scale intakes ----------------------

feed_intake <- feed_intake %>%
  filter(Out.Unit.Time != "experiment")

```

#### 2.4.2) Unit error check on feed intake
Performs basic outlier checks on feed intake data, identifying suspiciously high or low intake values based on predefined unit thresholds.

```{r,message=FALSE,warning=FALSE}

# Assuming your data is stored in a data frame named `feed_intake_data`

# Filter for units that imply kg/day/individual and check if ED.Mean.T > 50
# Identify suspicious feed intake values
## ---- detect_suspicious_feed_intake -----------------------------------------
# Thresholds
high_kg <- 50      # > 50 kg d-1 animal-1  ⟹ unrealistically high
low_kg  <- 0.1     # < 0.1 kg d-1 animal-1 ⟹ unrealistically low
low_g_min <- 1     # 1–20 g range unlikely for daily intake
low_g_max <- 20

suspicious_feed_intake <- feed_intake %>% 
  mutate(
    flag = case_when(
      Out.Unit.Amount %in% c("kg", "kg dm") &
      Out.Unit.Time   == "day"              &
      Out.Unit.Animals == "individual" & ED.Mean.T >  high_kg ~ "too_high_kg",

      Out.Unit.Amount %in% c("kg", "kg dm") &
      Out.Unit.Time   == "day"              &
      Out.Unit.Animals == "individual" & ED.Mean.T <  low_kg  ~ "too_low_kg",

      Out.Unit.Amount %in% c("g",  "g dm")  &
      ED.Mean.T >= low_g_min & ED.Mean.T <= low_g_max          ~ "implausibly_low_g",

      TRUE ~ NA_character_
    )
  ) %>% 
  filter(!is.na(flag))%>%
  filter(is_entire_diet=="TRUE")

print(suspicious_feed_intake)





```

## when all in % and one mising ing 


```{r}
# ignore water / minerals / salt when checking "true" missing ingredients
ignore_pattern <- "(?i)water|mineral|salt"

perc_complement <- ingredients %>%
  group_by(B.Code, A.Level.Name) %>%
  summarise(
    # flag salt / mineral / water rows
    is_smw   = grepl(ignore_pattern, D.Item),

    # how many "real" (non-salt/mineral/water) ingredients in this diet?
    n_non_smw = sum(!is_smw),

    # 1) all known amounts in this diet must be % / % Diet
    all_perc = all(D.Unit.Amount[!is.na(D.Amount)] %in% c("%", "% Diet")),

    # 2) count "true" missing ingredients = NA amount and NOT salt/mineral/water
    n_missing = sum(is.na(D.Amount) & !is_smw),

    # 3) name of the (only) missing non-salt/mineral/water ingredient
    missing_item = first(D.Item[is.na(D.Amount) & !is_smw]),

    # 4) sum of all known % amounts (including salt/mineral/water if present)
    sum_known = sum(D.Amount[!is.na(D.Amount)], na.rm = TRUE),

    .groups = "drop"
  ) %>%
  # keep only diets where:
  #  • all known amounts are in %, AND
  #  • exactly one non-SMW ingredient is missing, AND
  #  • there is more than one non-SMW ingredient overall
  filter(all_perc, n_missing == 1, n_non_smw > 1) %>%
  mutate(
    fill_value_raw = 100 - sum_known,
    # drop obviously bad negatives
    fill_value = ifelse(fill_value_raw < 0, NA_real_, fill_value_raw)
  ) %>%
  # do NOT fill if computed % is 0 or 100
  filter(!is.na(fill_value), fill_value > 0, fill_value < 100) %>%
  select(B.Code, A.Level.Name, missing_item, fill_value) %>%
  distinct()

# Apply the complement
ingredients <- ingredients %>%
  left_join(
    perc_complement,
    by = c("B.Code", "A.Level.Name", "D.Item" = "missing_item")
  ) %>%
  mutate(
    # fill only where we have a valid fill_value
    D.Amount = ifelse(is.na(D.Amount) & !is.na(fill_value),
                      fill_value,
                      D.Amount),

    # for those filled rows, standardise unit to "% Diet"
    D.Unit.Amount = ifelse(!is.na(fill_value),
                           "% Diet",
                           D.Unit.Amount)
  ) %>%
  select(-fill_value) %>%
  distinct()

```

#### 2.4.3) Use of feed intake for ingredient amounts

If feed intake data is there for the entire diet and that the ingredients in ingredients dataset are in % or % of diet or g/kg we can convert 

When we translate relative inclusion rates (“% of diet”, “g kg⁻¹ diet”) into absolute grams of dry matter, the correct denominator depends on how feed‑intake data are structured.  The table below summarises every layout we encounter, what it looks like in the two raw data frames (`feed_intake` and `ingredients`), how the percentages should be interpreted, and therefore which intake value—total diet or group‑level mix—must be used for the conversion.



| Scenario | What you see in **feed_intake** | What you see in **ingredients** | What the % or g kg⁻¹ actually mean | Correct denominator for conversion |
|----------|---------------------------------|---------------------------------|------------------------------------|------------------------------------|
| **A — No diet groups** | One row per diet level marked *Entire Diet* | Every ingredient row has `D.Item.Group = NA` | “%” = % of whole diet<br>“g/kg” = g per kg whole diet | **Total‑diet intake** (`intake_total`) |
| **B — Mix is *part* of diet** | Two + rows per diet level:<br>• `is_group = TRUE` for each mix (with its own intake)<br>• `is_entire_diet = TRUE` | Rows inside the mix have `D.Item.Group = mix name`; stand‑alone ingredients have `NA` | Inside‑mix “%” = % of **mix**<br>Stand‑alone “%” = % of **whole diet** | Inside‑mix → **group intake** (`intake_group`)<br>Stand‑alone → **total‑diet intake** |
| **C — Mix *is* the whole diet** | Only one `is_group = TRUE` row and that diet level has **no** stand‑alone ingredients | Every ingredient has the same `D.Item.Group` | “%” = % of whole diet, even though recorded under a group label | **Total‑diet intake** (because group = total) |
| **D — Group intake duplicated in ingredients** | — | A row like `D.Item == "Unspecified"` in kg day⁻¹ that repeats the group’s intake | Not a nutrient source → should be **removed** | **Drop the row** entirely |
| **E — Ingredient in feed_intake but not in ingredients** | A stand‑alone `is_group = FALSE` row | Missing ingredient row | We still need this ingredient and its intake | **Create a synthetic ingredient row** with grams = `ED.Mean.T × 1000` |


```{r}




## ----------------------------------------------------------
## 0. Ensure Source column exists
## ----------------------------------------------------------
ingredients <- ingredients %>%
  { if (!"Source" %in% names(.)) mutate(., Source = NA_character_) else . }

## ----------------------------------------------------------
## 1. Mark entire diet rows in feed_intake only
## ----------------------------------------------------------
feed_intake <- feed_intake %>%
  mutate(
    ED_item_clean = tolower(coalesce(ED.Intake.Item, ED.Intake.Item.Raw, "")),
    is_entire_diet = grepl("^\\s*entire\\s*diet\\s*$", ED_item_clean)
                     | ED.Intake.Item == A.Level.Name
  )

## ----------------------------------------------------------
## 2. Lookup tables for direct intakes
## ----------------------------------------------------------
intake_total <- feed_intake %>%
  filter(is_entire_diet) %>%
  transmute(
    B.Code, A.Level.Name,
    total_intake = ED.Mean.T,
    total_unit_amount = Out.Unit.Amount,
    total_unit_time   = Out.Unit.Time,
    total_unit_animals= Out.Unit.Animals
  )

intake_ing <- feed_intake %>%
  filter(!is_entire_diet) %>%   ## <--- EVERYTHING that is not entire-diet
  transmute(
    B.Code, A.Level.Name,
    D.Item = ED.Intake.Item,
    ing_intake      = ED.Mean.T,
    ing_unit_amount = Out.Unit.Amount,
    ing_unit_time   = Out.Unit.Time,
    ing_unit_animals= Out.Unit.Animals
  )

## ----------------------------------------------------------
## 3. Drop container rows (original logic)
## ----------------------------------------------------------
group_lookup <- ingredients %>%
  filter(!is.na(D.Item.Group)) %>%
  distinct(B.Code, A.Level.Name, grp_name = str_trim(D.Item.Group))

ingredients_clean <- ingredients %>%
  left_join(group_lookup, by = c("B.Code","A.Level.Name")) %>%
  filter(!(D.Item=="Unspecified" &
           D.Unit.Amount=="kg" &
           D.Unit.Time=="day" &
           !is.na(grp_name) &
           str_trim(D.Type)==grp_name)) %>%
  select(-grp_name)

## ----------------------------------------------------------
## 4. Attach direct ingredient-level feed-intake
## ----------------------------------------------------------
ingredients_fi <- ingredients_clean %>%
  left_join(intake_ing, by = c("B.Code","A.Level.Name","D.Item")) %>%
  left_join(intake_total, by = c("B.Code","A.Level.Name"))

## ----------------------------------------------------------
## 5. Replace amounts using feed_intake priority
## ----------------------------------------------------------
ingredients <- ingredients_fi %>%
  mutate(
    has_ing   = !is.na(ing_intake),
    has_total = !is.na(total_intake),

    # compute final amount
    D.Amount_new = case_when(
      has_ing ~ ing_intake,
      !has_ing & D.Unit.Amount %in% c("%","% Diet") & has_total ~ (D.Amount/100)*total_intake,
      !has_ing & D.Unit.Amount=="g/kg" & has_total ~ D.Amount * total_intake,
      TRUE ~ D.Amount
    ),

    # final units
    D.Unit.Amount_new = case_when(
      has_ing ~ ing_unit_amount,
      !has_ing & D.Unit.Amount %in% c("%","% Diet") & has_total ~ total_unit_amount,
      !has_ing & D.Unit.Amount=="g/kg" & has_total ~ "g",
      TRUE ~ D.Unit.Amount
    ),

    D.Unit.Time_new = coalesce(ing_unit_time, D.Unit.Time),
    D.Unit.Animals_new = coalesce(ing_unit_animals, D.Unit.Animals),

    intake_source = case_when(
      has_ing ~ "ingredient_intake",
      !has_ing & has_total ~ "diet_intake",
      TRUE ~ "original"
    ),

    Source = coalesce(Source,"extracted")
  ) %>%
  mutate(
    D.Amount = D.Amount_new,
    D.Unit.Amount = D.Unit.Amount_new,
    D.Unit.Time = D.Unit.Time_new,
    D.Unit.Animals = D.Unit.Animals_new
  ) %>%
  select(-any_of(c(
    "has_ing","has_total",
    "ing_intake","ing_unit_amount","ing_unit_time","ing_unit_animals",
    "total_intake","total_unit_amount","total_unit_time","total_unit_animals",
    "ED_item_clean",
    "D.Amount_new","D.Unit.Amount_new","D.Unit.Time_new","D.Unit.Animals_new"
  )))%>%
  distinct()




```


# when we dont have amount for one element but we have full diet intake 

```{r}
# -------------------------------------------------------------------
# 1) Measured diet-level intake (already in kg / animal / day)
# -------------------------------------------------------------------
diet_intake <- feed_intake %>%
  filter(is_entire_diet) %>%                       # only "Entire Diet" rows
  transmute(
    B.Code,
    A.Level.Name,
    P.Product,
    diet_intake_kg     = ED.Mean.T,                # already harmonised to kg/d
    diet_intake_source = "measured_feed_intake"
  ) %>%
  # ensure one row per diet
  group_by(B.Code, A.Level.Name) %>%
  summarise(
    P.Product       = first(P.Product),
    diet_intake_kg  = mean(diet_intake_kg, na.rm = TRUE),
    diet_intake_source = first(diet_intake_source),
    .groups = "drop"
  )

# -------------------------------------------------------------------
# 2) Complement-fill ONE missing ingredient using total intake
#     (excluding water/mineral/salt as "true" ingredients)
#     + keep tables of where it applies / fails
# -------------------------------------------------------------------
ignore_pattern <- "(?i)water|mineral|salt"

compl_candidates <- ingredients %>%
  # attach measured diet intake
  left_join(diet_intake, by = c("B.Code", "A.Level.Name")) %>%
  mutate(
    # flag water/mineral/salt rows
    is_smw = grepl(ignore_pattern, D.Item),

    # amounts converted to kg for mass-balance (only g / kg are usable)
    amount_kg = case_when(
      !is.na(D.Amount) & D.Unit.Amount == "kg" ~ D.Amount,
      !is.na(D.Amount) & D.Unit.Amount == "g"  ~ D.Amount / 1000,
      TRUE                                    ~ NA_real_
    ),

    # for non-SMW, non-missing rows, we demand g or kg per individual per day
    ok_unit = is.na(D.Amount) | (                             # <- NOTE: "|" not "||"
      D.Unit.Amount %in% c("g", "kg") &
      (is.na(D.Unit.Time)    | D.Unit.Time    == "day") &
      (is.na(D.Unit.Animals) | D.Unit.Animals == "individual")
    )
  ) %>%
  group_by(B.Code, A.Level.Name) %>%
  summarise(
    P.Product       = first(P.Product),
    diet_intake_kg  = first(diet_intake_kg),
    has_diet_intake = !is.na(diet_intake_kg),

    # how many non-SMW ingredients in this diet?
    n_non_smw       = sum(!is_smw),

    # all non-SMW, non-missing ingredients have acceptable units?
    all_ok_units    = all(ok_unit[!is_smw & !is.na(D.Amount)]),

    # number of "true" missing ingredients (non-SMW with NA amount)
    n_missing       = sum(is.na(D.Amount) & !is_smw),

    # name of the (only) missing non-SMW ingredient
    missing_item    = first(D.Item[is.na(D.Amount) & !is_smw]),

    # sum of all known ingredient intakes in kg (including SMW if known)
    sum_known_kg    = sum(amount_kg[!is.na(amount_kg)], na.rm = TRUE),

    .groups = "drop"
  ) %>%
  # We only *consider* complementing when:
  #  - we have measured diet intake
  #  - all "real" ingredients have usable units
  #  - exactly one real ingredient is missing
  #  - there is more than one real ingredient overall
  filter(
    has_diet_intake,
    all_ok_units,
    n_missing == 1,
    n_non_smw > 1
  ) %>%
  mutate(
    complement_kg = diet_intake_kg - sum_known_kg,
    complement_kg = ifelse(complement_kg < 0, 0, complement_kg)
  )

# 🔎 TABLE 1: cases where complement_kg == 0 (nothing left to allocate)
compl_zero_tbl <- compl_candidates %>%
  filter(complement_kg == 0) %>%
  select(B.Code, A.Level.Name, P.Product,
         missing_item, diet_intake_kg, sum_known_kg, complement_kg)

# 🔎 TABLE 2: cases where we *actually* impute an ingredient
compl_use_tbl <- compl_candidates %>%
  filter(complement_kg > 0) %>%
  select(B.Code, A.Level.Name, P.Product,
         missing_item, diet_intake_kg, sum_known_kg, complement_kg)

# This is the table used to update ingredients:
compl_info <- compl_use_tbl %>%
  select(B.Code, A.Level.Name, missing_item, complement_kg)

# -------------------------------------------------------------------
# 3) Apply complement to ingredients table
# -------------------------------------------------------------------
ingredients <- ingredients %>%
  left_join(
    compl_info,
    by = c("B.Code", "A.Level.Name", "D.Item" = "missing_item")
  ) %>%
  mutate(
    # fill missing ingredient amount in kg/day
    D.Amount       = ifelse(!is.na(complement_kg), complement_kg, D.Amount),
    D.Unit.Amount  = ifelse(!is.na(complement_kg), "kg",  D.Unit.Amount),
    D.Unit.Time    = ifelse(!is.na(complement_kg), "day", D.Unit.Time),
    D.Unit.Animals = ifelse(!is.na(complement_kg), "individual", D.Unit.Animals),

    # provenance flag
    D.Type = ifelse(
      !is.na(complement_kg),
      ifelse(is.na(D.Type),
             "complement_from_total_intake",
             paste0(D.Type, ";complement_from_total_intake")),
      D.Type
    )
  ) %>%
  select(-complement_kg)


```




## diet groups 

Some basal diet ingredients feed intake are given in the data out tab but for group of ingredients. The aim of this chunck is to give for each of those ingredient the right correponsing intake . 

harmonize names 
```{r}
# library(readxl)
# library(dplyr)
# library(stringr)
# library(tidyr)
# library(purrr)
# 
# ###############################################################################
# ### 0) Load master-sheet
# ###############################################################################
# 
# url <- "https://github.com/Mlolita26/ERA_Docs/raw/main/era_master_sheet(17).xlsx"
# temp_file <- tempfile(fileext = ".xlsx")
# 
# download.file(url, destfile = temp_file, mode = "wb")
# mastersheet <- read_excel(temp_file, sheet = "ani_diet")
# 
# ###############################################################################
# ### 1) Build master-sheet token lookup
# ###############################################################################
# 
# master_token_table <- mastersheet %>%
#   mutate(
#     D.Item.full  = D.Item,
#     D.Item.token = str_split(D.Item, ";")
#   ) %>%
#   unnest_longer(D.Item.token) %>%
#   mutate(
#     D.Item.token   = trimws(tolower(D.Item.token)),
#     canonical_name = D.Item.Root.Comp.Proc_Major
#   ) %>%
#   filter(D.Item.token != "")
# 
# ###############################################################################
# ### 2) Expand grouped ingredients and handle special process tokens
# ###############################################################################
# 
# special_processes <- c("drying", "fresh", "ensilation")
# 
# ingredients_groups <- ingredients %>%
#   filter(str_detect(D.Item, ";")) %>%
#   mutate(
#     D.Item.original = D.Item,
#     raw_tokens      = str_split(D.Item, ";")
#   ) %>%
#   mutate(
#     raw_tokens = map(raw_tokens, function(tokens) {
# 
#       cleaned <- character(0)
# 
#       for (t in tokens) {
# 
#         t_clean <- trimws(t)
#         t_low   <- trimws(tolower(t_clean))
# 
#         if (length(cleaned) == 0) {
# 
#           cleaned <- c(cleaned, t_clean)
# 
#         } else if (t_low %in% special_processes) {
# 
#           # Append processing to previous ingredient
#           cleaned[length(cleaned)] <- paste0(
#             cleaned[length(cleaned)], "||", tools::toTitleCase(t_low)
#           )
# 
#         } else {
#           cleaned <- c(cleaned, t_clean)
#         }
#       }
# 
#       cleaned
#     })
#   ) %>%
#   select(-D.Item) %>%
#   unnest_longer(raw_tokens, values_to = "token_raw") %>%
#   mutate(
#     token_raw   = trimws(token_raw),
#     token_match = trimws(tolower(token_raw))
#   )
# 
# ###############################################################################
# ### 3) Match tokens to master-sheet
# ###############################################################################
# 
# ingredients_matched <- ingredients_groups %>%
#   left_join(master_token_table,
#             by = c("token_match" = "D.Item.token"),
#             multiple = "all") %>%
#   mutate(
#     matched       = !is.na(canonical_name),
#     unmatched     =  is.na(canonical_name),
#     token_cleaned = ifelse(matched, canonical_name, token_raw)
#   )
# 
# ###############################################################################
# ### 4) Split D.Amount proportionally across grouped items
# ###############################################################################
# 
# ingredients_matched <- ingredients_matched %>%
#   group_by(B.Code, A.Level.Name, D.Item.original) %>%
#   mutate(
#     n_items  = n(),
#     D.Amount = D.Amount / n_items
#   ) %>%
#   ungroup()
# 
# ###############################################################################
# ### 5) Build cleaned expanded ingredient table
# ###############################################################################
# 
# ingredients_cleaned_expanded <- ingredients_matched %>%
#   mutate(D.Item = token_cleaned) %>%
#   select(
#     B.Code, A.Level.Name, D.Item,
#     D.Type, D.Amount, D.Unit.Amount, D.Unit.Time, D.Unit.Animals,
#     DC.Is.Dry, D.Ad.lib, D.Item.Group, AOM.Scientific.Name,
#     Source, Units, T.Animals, Out.WG.Start, Out.WG.Unit,
#     intake_source,
#     D.Item.original,
#     token_raw, token_cleaned,
#     matched, unmatched,
#     D.Item.full
#   )
# 
# ###############################################################################
# ### 6) Add original rows without ";" unchanged
# ###############################################################################
# 
# ingredients_expanded <- bind_rows(
#   ingredients %>% filter(!str_detect(D.Item, ";")),
#   ingredients_cleaned_expanded
# )
# 
# 
# ingredients_expanded <- ingredients_expanded %>%
#   group_by(B.Code, A.Level.Name) %>%
#   mutate(
#     # all ingredients actually present in the diet before feed-intake imports
#     diet_items = list(unique(D.Item[D.Type != "Imported_from_feed_intake"])),
# 
#     # identify feed-intake rows introducing NEW ingredients
#     is_new_feedintake_item =
#       D.Type == "Imported_from_feed_intake" &
#       !(D.Item %in% diet_items[[1]])
#   ) %>%
#   ungroup() %>%
#   filter(!is_new_feedintake_item) %>%
#   select(-diet_items, -is_new_feedintake_item)
# 
# 
# ###############################################################################
# ### 7) Build original ingredient name universe
# ###############################################################################
# 
# original_items <- ingredients %>%
#   mutate(D.Item.clean = trimws(tolower(D.Item))) %>%
#   distinct(B.Code, A.Level.Name, D.Item.clean)
# 
# ###############################################################################
# ### 8) Identify extracted items NOT in original ingredient list
# ###############################################################################
# 
# ingredients_expanded2 <- ingredients_expanded %>%
#   mutate(D.Item.clean = trimws(tolower(D.Item)))
# 
# ingredients_extracted_only <- ingredients_expanded2 %>%
#   anti_join(original_items,
#             by = c("B.Code", "A.Level.Name", "D.Item.clean"))
# 
# ###############################################################################
# ### 9) Keep only items originally present in ingredient list
# ###############################################################################
# 
# ingredients_expanded_clean <- ingredients_expanded2 %>%
#   semi_join(original_items,
#             by = c("B.Code", "A.Level.Name", "D.Item.clean"))
# 
# ###############################################################################
# ### 10) Deduplicate: prioritize ingredient rows over feed intake rows
# ###############################################################################
# 
# ingredients <- ingredients_expanded_clean %>%
#   group_by(B.Code, A.Level.Name, D.Item) %>%
#   arrange(
#     desc(intake_source == "feed_intake_only" & !is.na(D.Amount)),
#     desc(!is.na(D.Amount)),
#     intake_source == "feed_intake_only"
#   ) %>%
#   slice(1) %>%
#   ungroup()

```

### use Andy equations from https://www.cambridge.org/core/journals/animal/article/abs/nutritional-requirements-of-sheep-goats-and-cattle-in-warm-climates-a-metaanalysis/FBD20A80D070721414426A94E87888B8 
then we could get total estimated intake for the missing ones and deduce the missing ingredients. That could also work for the diets for which we only have % and no mentioned amount or intake. 


```{r}
###############################################################################
### 4.2bis) Use Archimède et al. (2014) to estimate total DMI
### and (a) convert % / g·kg⁻¹ diets with no FI,
### (b) complement-fill exactly ONE missing ingredient per diet,
### (c) evaluate prediction vs measured FI where available.
###
### Eq. (1) Archimède et al. 2014, Animal 8:1439–1447:
###   log10(DMI_kg_d) = -1.27 + 0.862 * log10(LW_kg)
###############################################################################

## ---------------------------------------------------------------------------
## 0) Helper: ignore minerals, salt, water in mass-balance steps
## ---------------------------------------------------------------------------
ignore_pattern <- "(?i)mineral|minerals|salt|water"

ingredients <- ingredients %>%
  mutate(
    ignore_for_balance = grepl(ignore_pattern, D.Item)
  )

## ---------------------------------------------------------------------------
## 1) Diet-level intake from measured feed intake (already harmonised to kg/d)
## ---------------------------------------------------------------------------
diet_intake_measured <- feed_intake %>%
  filter(is_entire_diet) %>%                       # only "Entire Diet" rows
  transmute(
    B.Code,
    A.Level.Name,
    P.Product,
    diet_intake_kg      = ED.Mean.T,               # already in kg/d
    diet_intake_source  = "measured_feed_intake"
  ) %>%
  distinct()

## ---------------------------------------------------------------------------
## 2) Predicted DMI using Archimède eq. for ALL diets with BW
##    log10(DMI_kg_d) = -1.27 + 0.862 * log10(LW_kg)
## ---------------------------------------------------------------------------

# weights_unique already has Out.WG.Start in kg per (B.Code, A.Level.Name)
archimede_dmi_all <- ingredients %>%
  distinct(B.Code, A.Level.Name) %>%
  left_join(
    weights_unique %>%
      select(B.Code, A.Level.Name, Out.WG.Start),
    by = c("B.Code", "A.Level.Name")
  ) %>%
  filter(!is.na(Out.WG.Start) & Out.WG.Start > 0) %>%
  mutate(
    pred_diet_intake_kg = 10^(-1.27 + 0.862 * log10(Out.WG.Start)),
    pred_source         = "pred_archimede2014"
  )

# subset used for IMPUTATION: only diets WITHOUT measured intake
archimede_dmi_missing <- archimede_dmi_all %>%
  anti_join(diet_intake_measured, by = c("B.Code", "A.Level.Name")) %>%
  transmute(
    B.Code,
    A.Level.Name,
    diet_intake_kg     = pred_diet_intake_kg,
    diet_intake_source = "pred_archimede2014"
  )

## ---------------------------------------------------------------------------
## 3) Combine measured and predicted diet intakes
##    (measured has precedence; we never overwrite it)
## ---------------------------------------------------------------------------
diet_intake_all <- bind_rows(
  diet_intake_measured,
  archimede_dmi_missing
) %>%
  arrange(
    B.Code, A.Level.Name,
    desc(diet_intake_source == "measured_feed_intake")
  ) %>%
  distinct(B.Code, A.Level.Name, .keep_all = TRUE)

## ---------------------------------------------------------------------------
## ---------------------------------------------------------------------------
## 3bis) Evaluate Archimède predictions vs measured FI (diagnostics only)
##       (with R² and RMSE, overall and by species)
## ---------------------------------------------------------------------------

dmi_eval <- diet_intake_measured %>%
  left_join(
    archimede_dmi_all %>%
      select(B.Code, A.Level.Name, pred_diet_intake_kg),
    by = c("B.Code", "A.Level.Name")
  ) %>%
  filter(!is.na(pred_diet_intake_kg)) %>%
  mutate(
    error_kg = pred_diet_intake_kg - diet_intake_kg
  ) %>%
  left_join(
    merged_metadata$Prod.Out %>%
      distinct(B.Code, P.Product),
    by = "B.Code"
  )

## ---- overall diagnostics (R² & RMSE) --------------------------------------
dmi_eval_overall <- dmi_eval %>%
  summarise(
    n_diets   = n(),
    mean_obs  = mean(diet_intake_kg, na.rm = TRUE),
    mean_pred = mean(pred_diet_intake_kg, na.rm = TRUE),

    # RMSE in kg / d
    rmse_kg = sqrt(mean(error_kg^2, na.rm = TRUE)),

    # R² = 1 - SSE/SST
    sse = sum((diet_intake_kg - pred_diet_intake_kg)^2, na.rm = TRUE),
    sst = sum((diet_intake_kg - mean(diet_intake_kg, na.rm = TRUE))^2, na.rm = TRUE),
    r2  = ifelse(sst > 0, 1 - sse/sst, NA_real_)
  ) %>%
  select(-sse, -sst)   # drop internals

## ---- diagnostics by species (R² & RMSE) -----------------------------------
dmi_eval_by_species <- dmi_eval %>%
  group_by(P.Product.x) %>%
  summarise(
    n_diets   = n(),
    mean_obs  = mean(diet_intake_kg, na.rm = TRUE),
    mean_pred = mean(pred_diet_intake_kg, na.rm = TRUE),

    rmse_kg = sqrt(mean(error_kg^2, na.rm = TRUE)),

    sse = sum((diet_intake_kg - pred_diet_intake_kg)^2, na.rm = TRUE),
    sst = sum((diet_intake_kg - mean(diet_intake_kg, na.rm = TRUE))^2, na.rm = TRUE),
    r2  = ifelse(sst > 0, 1 - sse/sst, NA_real_),

    .groups = "drop"
  ) %>%
  select(-sse, -sst)


library(ggplot2)

dmi_eval_plot <- dmi_eval %>%
  filter(P.Product.x %in% c("Cattle", "Sheep", "Goat"))

p_dmi <- ggplot(
  dmi_eval_plot,
  aes(x = diet_intake_kg,
      y = pred_diet_intake_kg)
) +
  geom_point(alpha = 0.6) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  facet_wrap(~ P.Product.x, scales = "free") +
  labs(
    x = "Measured DMI (kg / animal / day)",
    y = "Predicted DMI (kg / animal / day)",
    title = "DMI prediction vs measured",
    subtitle = "Faceted by species"
  ) +
  theme_bw()

p_dmi

```



## impute feed intake of ingrdients by substracting estimated feed intake by the total feed intake of ingredients 

```{r}
## ---------------------------------------------------------------------------
## 4.2ter) Complement-fill ONE missing absolute ingredient per diet
##         using measured/predicted total DMI (diet_intake_all)
##         (only diets where all non-missing ingredients are NOT in
##          %, % Diet, or g/kg)
## ---------------------------------------------------------------------------

# 1) Summarise diets that qualify for complementing
abs_complement_info <- ingredients %>%
  left_join(diet_intake_all, by = c("B.Code", "A.Level.Name")) %>%
  group_by(B.Code, A.Level.Name) %>%
  summarise(
    # total intake in kg/d (first non-NA if any)
    total_intake_kg = {
      v <- na.omit(diet_intake_kg)
      if (length(v) == 0) NA_real_ else v[1]
    },

    # counts restricted to mass-balance ingredients
    n_missing_abs = sum(
      is.na(D.Amount) &
        !ignore_for_balance &
        !(D.Unit.Amount %in% c("%", "% Diet", "g/kg"))
    ),
    n_rel = sum(
      !is.na(D.Amount) &
        !ignore_for_balance &
        D.Unit.Amount %in% c("%", "% Diet", "g/kg")
    ),
    n_abs_non_missing = sum(
      !is.na(D.Amount) &
        !ignore_for_balance &
        !(D.Unit.Amount %in% c("%", "% Diet", "g/kg"))
    ),

    missing_item = {
      idx <- which(
        is.na(D.Amount) &
          !ignore_for_balance &
          !(D.Unit.Amount %in% c("%", "% Diet", "g/kg"))
      )
      if (length(idx) == 0) NA_character_ else D.Item[idx[1]]
    },

    # sum of known absolute ingredient intakes in kg/d
    sum_known_kg = sum(
      dplyr::case_when(
        !is.na(D.Amount) &
          !ignore_for_balance &
          !(D.Unit.Amount %in% c("%", "% Diet", "g/kg")) &
          D.Unit.Amount == "kg" ~ D.Amount,
        !is.na(D.Amount) &
          !ignore_for_balance &
          !(D.Unit.Amount %in% c("%", "% Diet", "g/kg")) &
          D.Unit.Amount == "g"  ~ D.Amount / 1000,
        TRUE ~ 0
      ),
      na.rm = TRUE
    ),
    .groups = "drop"
  ) %>%
  # keep diets with: total intake known, exactly one missing abs ingredient,
  # no relative-unit ingredients, and at least one known abs ingredient
  filter(
    !is.na(total_intake_kg),
    n_missing_abs == 1,
    n_rel == 0,
    n_abs_non_missing > 0
  ) %>%
  mutate(
    complement_value_kg = pmax(total_intake_kg - sum_known_kg, 0)
  )

# Optional: table to inspect which diets were complemented
one_missing_abs_diets <- abs_complement_info %>%
  select(
    B.Code, A.Level.Name,
    total_intake_kg, sum_known_kg,
    complement_value_kg, n_abs_non_missing
  )

# 2) Apply complement to the missing ingredient rows in `ingredients`
ingredients <- ingredients %>%
  left_join(
    abs_complement_info %>%
      select(B.Code, A.Level.Name, missing_item, complement_value_kg),
    by = c("B.Code", "A.Level.Name", "D.Item" = "missing_item")
  ) %>%
  mutate(
    # fill only where we have a complement_value_kg
    D.Amount = dplyr::if_else(
      is.na(D.Amount) & !is.na(complement_value_kg),
      complement_value_kg,
      D.Amount
    ),
    D.Unit.Amount = dplyr::if_else(
      !is.na(complement_value_kg),
      "kg",
      D.Unit.Amount
    ),
    D.Unit.Time = dplyr::if_else(
      !is.na(complement_value_kg) & is.na(D.Unit.Time),
      "day",
      D.Unit.Time
    ),
    D.Unit.Animals = dplyr::if_else(
      !is.na(complement_value_kg) & is.na(D.Unit.Animals),
      "individual",
      D.Unit.Animals
    ),
    D.Type = dplyr::case_when(
      !is.na(complement_value_kg) & is.na(D.Type) ~
        "complement_from_total_intake_archimede",
      !is.na(complement_value_kg) & !is.na(D.Type) ~
        paste0(D.Type, ";complement_from_total_intake_archimede"),
      TRUE ~ D.Type
    )
  ) %>%
  select(-complement_value_kg)

# If you’re done with mass-balance helpers, you can drop this now:
# ingredients <- ingredients %>% select(-ignore_for_balance)

```

## use full diet intake (estimated) to change % to kg in amounts units 

```{r}
## ============================================================
## 4.x) Convert diets where *all* ingredients are in % / % Diet
##      (no missing amounts) using total intake from diet_intake_all
##      (measured if available, otherwise Archimède prediction)
## ============================================================

# 1) Flag diet-level % properties ------------------------------------
diet_pct_flag <- ingredients %>%
  group_by(B.Code, A.Level.Name) %>%
  summarise(
    # all non-missing amounts in this diet are % or % Diet
    all_in_pct = all(D.Unit.Amount[!is.na(D.Amount)] %in% c("%", "% Diet")),

    # there are no missing amounts in this diet
    no_missing = all(!is.na(D.Amount)),

    # sum of all % / % Diet amounts
    sum_pct = ifelse(
      all_in_pct,
      sum(D.Amount[D.Unit.Amount %in% c("%", "% Diet")], na.rm = TRUE),
      NA_real_
    ),

    n_rows = n(),
    .groups = "drop"
  )

# 2) Keep only diets that are pure-% and well-formed -----------------
#    and attach measured or Archimède intake from diet_intake_all
pct_diets_eligible <- diet_pct_flag %>%
  filter(
    all_in_pct,
    no_missing,
    !is.na(sum_pct),
    sum_pct > 80,    # e.g. sanity window for total %
    sum_pct < 120
  ) %>%
  inner_join(
    diet_intake_all %>%      # IMPORTANT: use measured + Archimède, not diet_intake only
      select(B.Code, A.Level.Name, P.Product,
             diet_intake_kg, diet_intake_source),
    by = c("B.Code", "A.Level.Name")
  )

# optional: keep a log / separate dataset of these diets
pct_diets_log <- pct_diets_eligible %>%
  select(B.Code, A.Level.Name, P.Product,
         all_in_pct, no_missing, sum_pct,
         diet_intake_kg, diet_intake_source, n_rows)

# 3) Apply conversion for those diets only ---------------------------
ingredients <- ingredients %>%
  left_join(
    pct_diets_eligible %>%
      select(B.Code, A.Level.Name, diet_intake_kg, diet_intake_source),
    by = c("B.Code", "A.Level.Name")
  ) %>%
  mutate(
    # we convert only when:
    #  - that diet is flagged as eligible (has diet_intake_kg from the join)
    #  - this row is % or % Diet
    #  - amount is non-missing
    use_pct_conv = !is.na(diet_intake_kg) &
                   D.Unit.Amount %in% c("%", "% Diet") &
                   !is.na(D.Amount),

    # convert % to kg using (pct / 100) * total intake
    D.Amount = case_when(
      use_pct_conv ~ (D.Amount / 100) * diet_intake_kg,
      TRUE         ~ D.Amount
    ),

    # set units for converted rows
    D.Unit.Amount = case_when(
      use_pct_conv ~ "kg",
      TRUE         ~ D.Unit.Amount
    ),
    D.Unit.Time = case_when(
      use_pct_conv & is.na(D.Unit.Time) ~ "day",
      TRUE                              ~ D.Unit.Time
    ),
    D.Unit.Animals = case_when(
      use_pct_conv & is.na(D.Unit.Animals) ~ "individual",
      TRUE                                 ~ D.Unit.Animals
    ),

    # provenance tag: note whether we used measured or archimede
    D.Type = case_when(
      use_pct_conv & is.na(D.Type) ~
        paste0("from_pct_using_", diet_intake_source),
      use_pct_conv & !is.na(D.Type) ~
        paste0(D.Type, ";from_pct_using_", diet_intake_source),
      TRUE ~ D.Type
    )
  ) %>%
  select(-diet_intake_kg, -diet_intake_source, -use_pct_conv)


```
BO1017 remove the ones with NA because the data is here -> extraction pb 
remove all the mineral and salt and water 

BO1018


## diag 

```{r}
ingredients <- ingredients %>%
  filter(
    # keep everything EXCEPT rows that:
    #  - have NA amount
    #  - and are salt / mineral / water
    !( is.na(D.Amount) &
       grepl("(?i)water|mineral|salt", D.Item) )
  )


diagnostics <- ingredients %>%
  group_by(B.Code, A.Level.Name) %>%
  summarise(
    # any ingredients expressed in % or % Diet?
    has_pct      = any(D.Unit.Amount %in% c("%", "% Diet"), na.rm = TRUE),
    n_pct        = sum(D.Unit.Amount %in% c("%", "% Diet"), na.rm = TRUE),

    # missing amounts (any)
    has_missing_any   = any(is.na(D.Amount)),
    n_missing_any     = sum(is.na(D.Amount)),

    # "true" missing amounts = excluding water/mineral/salt rows
    has_missing_true  = any(is.na(D.Amount) & !grepl(ignore_pattern, D.Item)),
    n_missing_true    = sum(is.na(D.Amount) & !grepl(ignore_pattern, D.Item)),

    n_rows = n(),
    .groups = "drop"
  ) %>%
  # keep only diets with % ingredients OR true missing amounts
  filter(has_pct | has_missing_true)

# Optional: ingredient-level view restricted to those diets
diagnostic_ingredients <- ingredients %>%
  inner_join(
    diagnostics %>% select(B.Code, A.Level.Name),
    by = c("B.Code", "A.Level.Name")
  )
```


## 9) Tagg ingredient with control or trt 

```{r}
##— build the control key from your merged MT.Out
ctrl_key <- merged_metadata$MT.Out[, .(
  B.Code,
  A.Level.Name,
  T.Name,
  T.Control
)]

##— example join back onto your ingredient table
# (assuming your ingredients DT has B.Code + A.Level.Name)
ingredients <- merge(
  x = ingredients, 
  y = ctrl_key, 
  by = c("B.Code","A.Level.Name"), 
  all.x = TRUE, 
  sort = FALSE
)%>%
  distinct()

```

```{r}

# ─────────────────────────────────────────────────────────────────────────────
# 1 ▸ diet-level intake DIRECTLY from feed_intake -----------------------------
feed_intake_diet <- feed_intake %>%
  filter(is_entire_diet) %>%                         # just the whole-diet rows
  transmute(B.Code, A.Level.Name,
            diet_intake_kg = ED.Mean.T,              # already in kg DM d-1
            Source = "feed_intake")

# ─────────────────────────────────────────────────────────────────────────────
# 2 ▸ diet-level intake CALCULATED from ingredients_final --------------------
diet_intake_calc <- ingredients %>%
  group_by(B.Code, A.Level.Name) %>%
  summarise(diet_intake_kg = sum(D.Amount, na.rm = TRUE) / 1000,  # g → kg
            .groups = "drop") %>%
  mutate(Source = "sum_ingredients")

# ─────────────────────────────────────────────────────────────────────────────
# 3 ▸ combine, giving precedence to the direct value -------------------------
feed_intake_diet <- feed_intake_diet %>%
  full_join(diet_intake_calc,
            by = c("B.Code", "A.Level.Name"),
            suffix = c("_feed", "_calc")) %>%
  transmute(
    B.Code, A.Level.Name,
    diet_intake_kg = coalesce(diet_intake_kg_feed, diet_intake_kg_calc),
    Source = ifelse(!is.na(diet_intake_kg_feed),
                    "feed_intake", "sum_ingredients")
  )

# diet_intake_final is ready to use

```

```{r}
# ==== Save outputs for downstream scripts =====================================



saveRDS(merged_metadata, "C:/Users/mlolita/OneDrive - CGIAR/Alliance - ClimateActionNetZero - 1_Projects/G227-A1712_SAAF/2_Technical & Data/Lolita Emissions Paper/Emission_Analysis/data/merged_metadata_harmonized.rds")


saveRDS(ingredients, "C:/Users/mlolita/OneDrive - CGIAR/Alliance - ClimateActionNetZero - 1_Projects/G227-A1712_SAAF/2_Technical & Data/Lolita Emissions Paper/Emission_Analysis/data/ingredients_harmonized.rds")
write.csv(ingredients, "~/Emission_Analysis/data/ingredients_harmonized.csv")


write.csv(feed_intake, "C:/Users/mlolita/OneDrive - CGIAR/Alliance - ClimateActionNetZero - 1_Projects/G227-A1712_SAAF/2_Technical & Data/Lolita Emissions Paper/Emission_Analysis/data/feed_intake_harmonized.csv")

write.csv(feed_intake, "C:/Users/mlolita/OneDrive - CGIAR/Alliance - ClimateActionNetZero - 1_Projects/G227-A1712_SAAF/2_Technical & Data/Lolita Emissions Paper/Emission_Analysis/data/feed_intake_ingredients_harmonized.csv")
write.csv(feed_intake, "C:/Users/mlolita/OneDrive - CGIAR/Alliance - ClimateActionNetZero - 1_Projects/G227-A1712_SAAF/2_Technical & Data/Lolita Emissions Paper/Emission_Analysis/data/feed_intake_diet_harmonized.csv")

write.csv(feed_intake_diet, "C:/Users/mlolita/OneDrive - CGIAR/Alliance - ClimateActionNetZero - 1_Projects/G227-A1712_SAAF/2_Technical & Data/Lolita Emissions Paper/Emission_Analysis/data/diet_intake_final.csv")

write.csv(weights_unique, "C:/Users/mlolita/OneDrive - CGIAR/Alliance - ClimateActionNetZero - 1_Projects/G227-A1712_SAAF/2_Technical & Data/Lolita Emissions Paper/Emission_Analysis/data/weights_unique.csv")






# ==============================================================================

```


---
title: "8_Emission_Ingredient_classification"
output: html_document
date: "2025-09-26"
---

```{r}
library(ERAg)
library(stringr)
library(knitr)
library(dplyr)
library(DT)
library(readxl)
library(tidyr)
library(arrow)
library(ggplot2)
library(data.table)
library(purrr)
library(janitor)
library(ggalt)

ingredients <- readRDS("~/Emission_Analysis/data/ingredients_harmonized_subset.rds")
merged_metadata <- readRDS("~/Emission_Analysis/data/merged_metadata_nutrition_inference.rds")
diet_percentages <- read.csv("~/Emission_Analysis/data/diet_percentages.csv")

diets <- ingredients

#remove salt 
ingredients<-ingredients%>%
  filter(D.Item!="Salt")

```

## 18. Ingredient Classification methods 


| **Method** | **R function** | **Core concept** | **Variables needed** | **One‑sentence rule** |
|------------|----------------|------------------|----------------------|-----------------------|
| **1** | `method1()` | Exact‑window filter | GE, Ash, CP, EE, NDF<br>(*all present*) | Assign to the *first* category in which **every variable** falls inside its strict baseline window. |
| **2** | `method2()` | Exact ± 10 % filter | Same five | Same as M1 but each numeric bound is widened ± 10 %. |
| **3** | `method3()` | Priority‑variable filter (strict) | Only the **priority** variables per category:<br> • I → NDF<br> • II → EE<br> • III–V → CP & NDF<br> • VI → Ash | If all priority variables exist *and* meet their strict windows, assign that category; missing non‑priority data are ignored. |
| **4** | `method4()` | Priority‑variable ± 10 % | Same | Priority windows widened ± 10 %; non‑priority values (if present) still use strict windows and can only disqualify. |
| **5** | `method5()` | Hierarchical decision tree (strict) | Any subset of GE, Ash, CP, EE, NDF | Gates tested in order:<br>`EE ≥ 80 → II` → else `Ash ≥ 50 → VI` → else `CP ≥ 35 & NDF ≤ 30 → III` → else `NDF ≤ 20 → I` → else `NDF ≥ 60 → V` → else `40 ≤ NDF ≤ 50 → IV` → else *unclassified*. |
| **6** | `method6()` | Hierarchical tree ± 10 % | Same | Same gates as M5 but every numeric constant is multiplied by 0.9 (lower) and 1.1 (upper) before testing. |
| **7** | `method7()` | Hierarchical ± 10 % plus text overrides | Same numerics **+** `D.Item`, `D.Type` | Start with Method 6 result, then override:<br> • `oil|tallow|fat|grease` in *D.Item* → **II**<br> • protein‑meal regex (distillers grain, soybean meal, …) → **III**<br> • `D.Type` ∈ “Supplement” *or* matches “supplement” → **VI** |

*All concentration variables are in g·kg⁻¹ DM except GE (MJ·kg⁻¹ DM).*


## 18.1. Hierachical decision tree

```{r,echo=FALSE,warning=FALSE}
# --------------------------------------------------------------
# UPDATED FLOW‑CHART  (no NFC test)  –  Method 5 decision tree
# --------------------------------------------------------------
#  Install DiagrammeR if you do not have it:
#  install.packages("DiagrammeR")

library(DiagrammeR)

feed_tree_nfc_removed <- grViz("
digraph feed_tree {
  graph [layout = dot, rankdir = TB]

  # ----- Default styling -----
  node [shape = rectangle,
        style = filled,
        fillcolor = LightYellow,
        fontname = Helvetica,
        fontsize = 12]

  # ----- Decision nodes -----
  n1  [label = 'EE ≥ 80 ?']
  n3  [label = 'Ash ≥ 50 ?']
  n5  [label = 'CP ≥ 35 &\\nNDF ≤ 30 ?']
  n7  [label = 'NDF ≤ 20 ?']
  n9  [label = 'NDF ≥ 60 ?']
  n11 [label = '40 ≤ NDF ≤ 50 ?']

  # ----- Terminal nodes -----
  node [fillcolor = LightSkyBlue]
  n2  [label = 'Category II\\nHigh‑fat']
  n4  [label = 'Category VI\\nMineral/Vit']
  n6  [label = 'Category III\\nProtein conc.']
  n8  [label = 'Category I\\nHigh‑starch']
  n10 [label = 'Category V\\nPoor forage']
  n12 [label = 'Category IV\\nGood forage']
  n13 [label = 'Unclassified']

  # ----- Edges -----
  n1  -> n2  [label = 'Yes']
  n1  -> n3  [label = 'No']
  n3  -> n4  [label = 'Yes']
  n3  -> n5  [label = 'No']
  n5  -> n6  [label = 'Yes']
  n5  -> n7  [label = 'No']
  n7  -> n8  [label = 'Yes']
  n7  -> n9  [label = 'No']
  n9  -> n10 [label = 'Yes']
  n9  -> n11 [label = 'No']
  n11 -> n12 [label = 'Yes']
  n11 -> n13 [label = 'No']
}
")

# Render in the Viewer or export as needed
feed_tree_nfc_removed

# Example export:
# export_graph(feed_tree_nfc_removed, file_name = "feed_tree_method5.png", file_type = "PNG")


```

this chunck is to harmonize names 
```{r, warning=FALSE,message=FALSE}

# ─────────────────────────────────────────────────────────────
# STEP 0: Define normalization function used consistently
# ─────────────────────────────────────────────────────────────
canonicalize_item <- function(x) {
  x %>%
    tolower() %>%
    stringr::str_squish() %>%
    stringr::str_trim()
}

# ─────────────────────────────────────────────────────────────
# STEP 1: Start from Animals.Diet.Comp and filter down to valid items
# ─────────────────────────────────────────────────────────────
Ing_classif <- merged_metadata$Animals.Diet.Comp %>%
  filter(D.Item %in% ingredients$D.Item) %>%       # keep only items present in ingredients
  filter(!D.Item %in% c("Salt", "Water")) %>%      # remove trivial items
  mutate(D.Item_lc = canonicalize_item(D.Item))    # add normalized column for matching


# ─────────────────────────────────────────────────────────────
# STEP 2: Define and normalize nutrient donor map (variant → donor)
# ─────────────────────────────────────────────────────────────
nutrient_donor_map <- tribble(
  ~variant,                                        ~donor,
  "leucaena leucocephala dried ground",            "leucaena leucocephala leaves ground",
  "sheanut cake boiled dried",                     "sheanut cake ground",
  "maize straw dried ensiled ground urea treated", "maize straw ensiled urea treated",
  "leucaena leucocephala leaves dried",            "leucaena leucocephala leaves ground",
  "gliciridia sepium ground",                      "gliciridia sepium leaves dried ground",
  "sunflower",                                     "sunflower seed",
  "moringa stenopetala leaves dried",              "moringa stenopetala dried",
  "sesbania sesban leaves dried",                  "sesbania sesban leaves and twigs dried",
  "urochloa hybrid mulato ii dried",               "urochloa mosambicensis dried",
  "gliciridia sepium leaves ground",               "gliciridia sepium leaves dried ground",
  "leucaena leucocephala leaves dried ground",     "leucaena leucocephala leaves ground",
  "wheat straw effective microbes",                "wheat straw",
  "maize & wheat offal",                           "maize offal",
  "maize offal ground",                            "maize offal",
  "leucaena leucocephala dried",                   "leucaena leucocephala leaves ground"
) %>%
  mutate(
    variant_lc = canonicalize_item(variant),
    donor_lc   = canonicalize_item(donor)
  )

# ─────────────────────────────────────────────────────────────
# STEP 3: Extract available donor rows from Ing_classif
# ─────────────────────────────────────────────────────────────
donor_profiles <- Ing_classif %>%
  filter(D.Item_lc %in% nutrient_donor_map$donor_lc)

# ─────────────────────────────────────────────────────────────
# STEP 4: Build replacement rows by cloning donor rows
# ─────────────────────────────────────────────────────────────
replacement_rows <- nutrient_donor_map %>%
  inner_join(donor_profiles, by = c("donor_lc" = "D.Item_lc")) %>%
  mutate(
    D.Item_lc = variant_lc,                      # update to the variant
    D.Item    = stringr::str_to_title(variant_lc), # pretty capitalization
    Donor_Used_From = stringr::str_to_title(donor_lc)  # optional traceability column
  )


# ─────────────────────────────────────────────────────────────
# STEP 5: Only drop variants we have replacements for
# ─────────────────────────────────────────────────────────────
variants_replaced <- replacement_rows$D.Item_lc

Ing_classif <- Ing_classif %>%
  filter(!D.Item_lc %in% variants_replaced) %>%                     # drop only replaced variants
  bind_rows(replacement_rows %>% select(names(.)))                 # add replacements


# Convert wide → long for all nutrient values (for classification)
Ing_classif_long <- Ing_classif %>%
  filter(!is.na(DC.Variable), DC.Variable %in% c("GE","Ash","CP","EE","NDF")) %>%
  mutate(
    DC.Value = suppressWarnings(as.numeric(DC.Value)),
    D.Item = canonicalize_item(D.Item),
    B.Code = str_trim(B.Code)
  ) %>%
  select(B.Code, D.Item, DC.Variable, DC.Value,is_entire_diet,is_group)




```




# add items where nutrition estimated by models 
```{r}

# 0) Canonicalizer (match the one you use later)
if (!exists("canonicalize_item")) {
  clean_key <- function(x) x %>% str_trim() %>% str_squish() %>% str_to_lower()
  canonicalize_item <- function(x) {
    clean_key(x) %>%
      str_replace("^unspecified\\s+molasses$", "molasses") %>%
      str_replace_all("\\bbran\\b", "offal")
  }
}

# 1) Point to your CSV (edit the path as needed)
# csv_path <- file.choose()
csv_path <- "~/Emission_Analysis/data/Ingredients_nutrition_unmatched_GPT.csv"  # <- change if saved elsewhere

# 2) Read & clean the CSV (strip tildes, parse numbers)
csv_raw <- readr::read_csv(csv_path, show_col_types = FALSE)


# 2) Clean + build canonical join key; parse numbers (robust to "NA", "~")
csv_clean <- csv_raw %>%
  mutate(
    D.Item_can = canonicalize_item(D.Item),
    GE  = suppressWarnings(readr::parse_number(as.character(GE))),
    Ash = suppressWarnings(readr::parse_number(as.character(Ash))),
    CP  = suppressWarnings(readr::parse_number(as.character(CP))),
    EE  = suppressWarnings(readr::parse_number(as.character(EE))),
    NDF = suppressWarnings(readr::parse_number(as.character(NDF)))
  ) %>%
  select(D.Item_can, GE, Ash, CP, EE, NDF)

# 3) Long-format replacement table (only non-missing values)
csv_long <- csv_clean %>%
  pivot_longer(
    cols = c(GE, Ash, CP, EE, NDF),
    names_to = "DC.Variable",
    values_to = "DC.Value_new"
  ) %>%
  filter(!is.na(DC.Value_new))

# 4) Prepare Ing_classif with same canonical key
Ing_classif <- Ing_classif_long %>%
  mutate(
    D.Item_can = canonicalize_item(D.Item),
    DC.Value = ifelse(
      DC.Variable %in% c("GE","Ash","CP","EE","NDF"),
      suppressWarnings(as.numeric(DC.Value)),
      DC.Value
    )
  )

# 5) Join and override ONLY where CSV provides a value
Ing_classif <- Ing_classif %>%
  left_join(csv_long, by = c("D.Item_can", "DC.Variable")) %>%
  mutate(
    overridden = !is.na(DC.Value_new),
    DC.Value   = if_else(overridden, DC.Value_new, DC.Value)
  ) %>%
  select(-DC.Value_new)

# (Optional) Quick report: how many values were actually overridden
override_counts <- Ing_classif %>%
  filter(overridden) %>%
  count(DC.Variable, name = "n_overridden")
print(override_counts)

# Drop helper flag
Ing_classif$overridden <- NULL
# ---- end CSV override block ----

  
```


```{r}
# --- Helpers ---------------------------------------------------------------
clean_key <- function(x) x %>% str_trim() %>% str_squish() %>% str_to_lower()


# Canonicalize names so duplicates collapse:
#   "unspecified molasses" → "molasses"
#   any "bran"             → "offal"
canonicalize_item <- function(x) {
  clean_key(x) %>%
    str_replace("^unspecified\\s+molasses$", "molasses") %>%
    str_replace_all("\\bbran\\b", "offal")
}

# Robust logical checks for columns stored as logical or "TRUE"/"FALSE"
is_false_or_na <- function(x) is.na(x) | x == FALSE | x == "FALSE"
is_true        <- function(x) !is.na(x) & (x == TRUE | x == "TRUE")

# Global D.Item → D.Type (built on canonical names)
type_lookup <- ingredients %>% 
  transmute(
    D.Item = canonicalize_item(D.Item),
    D.Type = str_trim(D.Type)
  ) %>%
  distinct(D.Item, .keep_all = TRUE)

# Canonicalize Ing_classif once
Ing_base <- Ing_classif %>%
  mutate(
    B.Code     = str_trim(B.Code),
    D.Item_raw = D.Item,
    D.Item     = canonicalize_item(D.Item)
  )

ingredients <- ingredients %>%
  mutate(
    B.Code     = str_trim(B.Code),
    D.Item_raw = D.Item,
    D.Item     = canonicalize_item(D.Item)
  )

diet_percentages <- diet_percentages %>%
  mutate(
    B.Code     = str_trim(B.Code),
    D.Item_raw = D.Item,
    D.Item     = canonicalize_item(D.Item)
  )

# Build (pivot-wide + attach D.Type; optional back-fill from global item means)
build_nutr_table <- function(df_long, type_lookup, backfill_by_item = TRUE) {
  target_vars <- c("CP","EE","NDF","Ash","GE")

  nutr <- df_long %>%
    filter(DC.Variable %in% target_vars) %>%
    mutate(DC.Value = suppressWarnings(as.numeric(DC.Value))) %>%
    pivot_wider(
      id_cols     = c(B.Code, D.Item),
      names_from  = DC.Variable,
      values_from = DC.Value,
      values_fn   = ~ mean(.x, na.rm = TRUE),
      values_fill = NA
    ) %>%
    left_join(type_lookup, by = "D.Item")

  if (backfill_by_item) {
    global_means <- df_long %>%
      filter(DC.Variable %in% target_vars) %>%
      mutate(DC.Value = suppressWarnings(as.numeric(DC.Value))) %>%
      group_by(D.Item, DC.Variable) %>%
      summarise(Value = mean(DC.Value, na.rm = TRUE), .groups = "drop") %>%
      pivot_wider(names_from = DC.Variable, values_from = Value)

    nutr <- nutr %>%
      left_join(global_means, by = "D.Item", suffix = c("", ".global")) %>%
      mutate(
        GE  = coalesce(GE,  GE.global),
        Ash = coalesce(Ash, Ash.global),
        CP  = coalesce(CP,  CP.global),
        EE  = coalesce(EE,  EE.global),
        NDF = coalesce(NDF, NDF.global)
      ) %>%
      select(-ends_with(".global"))
  }

  nutr
}

# Ingredients subset (non-entire, non-group) — WITH back-fill
Ing_ingredients_long <- Ing_base %>%
  filter(is_false_or_na(is_entire_diet)) %>%
  filter(is_false_or_na(is_group))

nutr_ing <- build_nutr_table(Ing_ingredients_long, type_lookup, backfill_by_item = TRUE) %>%
  mutate(scope = "ingredient") %>%
  relocate(scope, .before = B.Code)




# ── Canonical mean per ingredient (collapse to one row per D.Item) ──────────
canon_ing <- nutr_ing %>%
  group_by(D.Item) %>%
  summarise(
    GE  = mean(GE,  na.rm = TRUE),
    Ash = mean(Ash, na.rm = TRUE),
    CP  = mean(CP,  na.rm = TRUE),
    EE  = mean(EE,  na.rm = TRUE),
    NDF = mean(NDF, na.rm = TRUE),
    D.Type = first(D.Type),
    .groups = "drop"
  )

# Numeric windows (g/kg DM; GE in MJ/kg DM)
win <- list(
  GE  = list(I=c(17,19), II=c(30,38), III=c(18,20), IV=c(16,18), V=c(15,17)),
  Ash = list(I=c(20,40),   II=c(0,10),   III=c(50,80),   IV=c(70,100),  V=c(60,100), VI=c(500,1000)),
  CP  = list(I=c(80,120),  II=c(0,50),   III=c(350,500), IV=c(120,200), V=c(30,80)),
  EE  = list(I=c(20,50),   II=c(80,990), III=c(20,60),   IV=c(10,30),   V=c(0,20)),
  NDF = list(I=c(100,200), II=c(0,50),   III=c(100,300), IV=c(400,500), V=c(600,750))
)
expand10 <- function(x) c(x[1]*0.9, x[2]*1.1)
inside   <- function(x, rng) !is.na(x) & x >= rng[1] & x <= rng[2]

# Priority variables
priority <- list(
  I  = c("NDF"),
  II = c("EE"),
  III= c("CP","NDF"),
  IV = c("NDF","CP"),
  V  = c("NDF","CP"),
  VI = c("Ash")
)

# M1 strict all-five
method1 <- function(df, w = win){
  df %>% mutate(
    M1_Category = case_when(
      inside(GE,w$GE$I)   & inside(Ash,w$Ash$I)  & inside(CP,w$CP$I)   & inside(EE,w$EE$I)   & inside(NDF,w$NDF$I)   ~ "I",
      inside(GE,w$GE$II)  & inside(Ash,w$Ash$II) & inside(CP,w$CP$II)  & inside(EE,w$EE$II)  & inside(NDF,w$NDF$II)  ~ "II",
      inside(GE,w$GE$III) & inside(Ash,w$Ash$III)& inside(CP,w$CP$III) & inside(EE,w$EE$III) & inside(NDF,w$NDF$III) ~ "III",
      inside(GE,w$GE$IV)  & inside(Ash,w$Ash$IV) & inside(CP,w$CP$IV)  & inside(EE,w$EE$IV)  & inside(NDF,w$NDF$IV)  ~ "IV",
      inside(GE,w$GE$V)   & inside(Ash,w$Ash$V)  & inside(CP,w$CP$V)   & inside(EE,w$EE$V)   & inside(NDF,w$NDF$V)   ~ "V",
      inside(Ash,w$Ash$VI) ~ "VI",
      TRUE ~ NA_character_
    )
  )
}

# M2 ±10% all-five
method2 <- function(df){
  w10 <- map(win, ~ map(.x, expand10))
  method1(df, w10) %>% rename(M2_Category = M1_Category)
}

# Priority helper
method_priority <- function(df, w, out_name){
  df %>% rowwise() %>% mutate(
    "{out_name}" := {
      dat <- c(CP=CP, EE=EE, NDF=NDF, Ash=Ash, GE=GE)
      cat <- NA_character_
      for (cl in names(priority)) {
        req <- priority[[cl]]
        if (all(!is.na(dat[req])) &&
            all(map2_lgl(dat[req], req, \(v,r) inside(v, w[[r]][[cl]])))) {
          cat <- cl; break
        }
      }
      cat
    }
  ) %>% ungroup()
}
method3 <- function(df) method_priority(df, win,  "M3_Category")
method4 <- function(df){ w10 <- map(win, ~ map(.x, expand10)); method_priority(df, w10, "M4_Category") }

# Decision tree
tree_decide <- function(df, w){
  df %>% mutate(
    Category = case_when(
      EE  >= w$EE$II[1]                         ~ "II",
      Ash >= w$Ash$VI[1]                        ~ "VI",
      CP  >= w$CP$III[1] & NDF <= w$NDF$III[2]  ~ "III",
      NDF <= w$NDF$I[2]                         ~ "I",
      NDF >= w$NDF$V[1]                         ~ "V",
      NDF >= w$NDF$IV[1] & NDF <= w$NDF$IV[2]   ~ "IV",
      TRUE                                      ~ NA_character_
    )
  )
}
method5 <- function(df) tree_decide(df, win) %>% rename(M5_Category = Category)
method6 <- function(df){ w10 <- map(win, ~ map(.x, expand10)); tree_decide(df, w10) %>% rename(M6_Category = Category) }

# Method 7: start from M6 and apply name/type overrides
method7 <- function(df){
  out <- if ("M6_Category" %in% names(df)) df else method6(df)
  out$M7_Category <- out$M6_Category

  # normalize item names
  item_norm <- canonicalize_item(out$D.Item)

  # --- Category II: fats/oils ---
  oil_pat <- "\\b(oil|tallow|grease|lard)\\b"
  is_oil  <- str_detect(item_norm, regex(oil_pat, ignore_case = TRUE))
  out$M7_Category[is_oil] <- "II"

  # --- Category III: protein sources ---
  protein_pat <- "\\b(distillers?.*grain|soybean ground|canola meal|fish ground|blood ground)\\b"
  is_pmeal    <- str_detect(item_norm, regex(protein_pat, ignore_case = TRUE))
  is_fish     <- str_detect(item_norm, regex("\\bfish\\b", ignore_case = TRUE)) &
                 !str_detect(item_norm, regex("\\bfish\\s*oil\\b", ignore_case = TRUE))
  is_animprot <- str_detect(item_norm, regex("\\b(feather|larvae|snail|termite|shrimp|hydrolysate)\\b",
                                             ignore_case = TRUE))
  out$M7_Category[is_pmeal | is_fish | is_animprot] <- "III"

  # --- Category I: byproducts (bread waste only) ---
  is_bread <- str_detect(item_norm, regex("\\bbread waste\\b", ignore_case = TRUE))
  out$M7_Category[is_bread] <- "I"

  # --- Category VI: supplements / additives ---
  sup_types   <- c("Supplement", "Non-ERA Feed")
  vi_type_hit <- !is.na(out$D.Type) &
                 (out$D.Type %in% sup_types |
                  str_detect(out$D.Type, regex("supplement", ignore_case = TRUE)))
  is_shell    <- str_detect(item_norm, regex("\\boyster\\s*shells?\\b", ignore_case = TRUE))
  is_cellulose <- str_detect(
    item_norm,
    regex("\\b(cellulose|micro\\s*-?crystalline\\s+cellulose|carboxy\\s*methyl\\s*cellulose|\\bMCC\\b|\\bCMC\\b)\\b",
          ignore_case = TRUE)
  )
  is_nonfeed <- str_detect(item_norm,
                           regex("\\b(cement|polyethylene|humate|probiotic|solution|mixture|axtra xap)\\b",
                                 ignore_case = TRUE))
  out$M7_Category[vi_type_hit | is_shell | is_cellulose | is_nonfeed] <- "VI"

  out
}



# Run all methods so we can inspect coverage; M7 uses M6 base + overrides
classif_ing <- canon_ing %>%   # ← use canonical means for INGREDIENTS
  method1() %>% method2() %>% method3() %>% method4() %>%
  method5() %>% method6() %>% method7()

```

```{r}
# Helper to build coverage/counts/samples/unclassified per table
build_reports <- function(df){
  method_cols <- grep("^M[1-7]_Category$", names(df), value = TRUE)

  coverage_tbl <- purrr::map_dfr(method_cols, function(mc){
    tibble(
      Method   = sub("_Category$", "", mc),
      Total    = nrow(df),
      Assigned = sum(!is.na(df[[mc]])),
      Coverage = round(Assigned / Total * 100, 1)
    )
  })

  counts_tbl <- df %>%
    pivot_longer(all_of(method_cols), names_to = "Method", values_to = "Category") %>%
    filter(!is.na(Category)) %>%
    mutate(Method = sub("_Category$", "", Method)) %>%
    count(Method, Category, name = "n") %>%
    arrange(Method, desc(n))

  set.seed(123)
sample_tbl <- df %>%
  pivot_longer(all_of(method_cols), names_to = "Method", values_to = "Category") %>%
  filter(!is.na(Category)) %>%
  mutate(Method = sub("_Category$", "", Method)) %>%
  group_by(Method, Category) %>%
  # take distinct items per (Method,Category), sample up to 10 per group
  group_modify(function(.x, .y) {
    .x %>%
      distinct(D.Item, .keep_all = TRUE) %>%
      slice_sample(n = min(10, nrow(.)))
  }) %>%
  # still grouped by Method,Category here → summarise keeps those cols
  summarise(Examples = paste(D.Item, collapse = "; "), .groups = "drop") %>%
  arrange(Method, Category)


  unclassified_tbl <- df %>%
    pivot_longer(all_of(method_cols), names_to = "Method", values_to = "Category") %>%
    filter(is.na(Category)) %>%
    mutate(Method = sub("_Category$", "", Method)) %>%
    count(Method, D.Item, sort = TRUE) %>%
    group_by(Method) %>%
    slice_max(n, n = 10, with_ties = FALSE) %>%
    ungroup()

  list(coverage = coverage_tbl, counts = counts_tbl,
       samples = sample_tbl, unclassified = unclassified_tbl)
}

rep_ing  <- build_reports(classif_ing)

# Display (ingredients)
datatable(classif_ing %>% arrange(M7_Category),
          caption = "INGREDIENTS: Classified rows (sorted by M7)",
          rownames = FALSE, options = list(pageLength = 30, dom = "tip"))
datatable(rep_ing$coverage,    caption = "INGREDIENTS: Coverage by method",    options = list(pageLength = 10, dom = "tip"))
datatable(rep_ing$counts,      caption = "INGREDIENTS: Counts per category",   options = list(pageLength = 25, dom = "tip"))
datatable(rep_ing$samples,     caption = "INGREDIENTS: Random examples",       options = list(pageLength = 25, dom = "tip"))
datatable(rep_ing$unclassified,caption = "INGREDIENTS: Top-10 unclassified",   options = list(pageLength = 25, dom = "tip"))


```


```{r}
# Canonicalize D.Item and A.Level.Name in ingredients before joining
ingredients_joinable <- ingredients %>%
  mutate(
    D.Item = canonicalize_item(D.Item),
    A.Level.Name = canonicalize_item(A.Level.Name)
  )

# Simplify classification tables (already canonicalized)
classif_ing_simple <- classif_ing %>%
  select(D.Item, Ingredient_Category = M7_Category)



# Join the classifications
ingredients<- ingredients_joinable %>%
  left_join(classif_ing_simple,  by = "D.Item")%>%
  distinct()

# --- Final polish: map Roman numerals -> full names in ingredients ---
roman_to_name <- function(x) dplyr::recode(
  x,
  "I"   = "High-starch",
  "II"  = "High-fat",
  "III" = "Protein",
  "IV"  = "Good forage",
  "V"   = "Poor forage",
  "VI"  = "Mineral/Vitamin",
  .default = x,
  .missing = NA_character_
)

# Update the ingredient database
ingredients <- ingredients %>%
  dplyr::mutate(
    Ingredient_Category = roman_to_name(Ingredient_Category))
    # If you also keep a diet-level tag, uncomment:
    # , Diet_Category = roman_to_name(Diet_Category)
  

```


```{r}
library(dplyr)
library(readr)
library(stringr)

# 1) Read the classification file
csv_path <- "~/Emission_Analysis/classified_ingredients_model.csv"
ingredient_additional_classif <- read_csv(csv_path, show_col_types = FALSE)

# 2) Clean up text and convert categories
roman_to_name <- function(x) recode(
  x,
  "I"   = "High-starch",
  "II"  = "High-fat",
  "III" = "Protein",
  "IV"  = "Good forage",
  "V"   = "Poor forage",
  "VI"  = "Mineral/Vitamin",
  .default = x,
  .missing = NA_character_
)

ingredient_additional_classif <- ingredient_additional_classif %>%
  mutate(
    D.Item = D.Item %>%
      str_to_lower() %>%
      str_replace_all("[^a-z0-9 ]", " ") %>%  # remove punctuation
      str_squish(),
    Predicted_Category = roman_to_name(Predicted_Category)
  )

# 3) Clean and prepare main dataset (replace ingredient_df with your data)
ingredients <- ingredients %>%
  mutate(
    D.Item_raw = D.Item_raw %>%
      str_to_lower() %>%
      str_replace_all("[^a-z0-9 ]", " ") %>%
      str_squish()
  )

# 4) Join and fill missing Ingredient_Category
ingredients <- ingredients %>%
  left_join(
    ingredient_additional_classif %>% select(D.Item, Predicted_Category),
    by = c("D.Item_raw" = "D.Item")
  ) %>%
  mutate(
    Ingredient_Category = coalesce(Ingredient_Category, Predicted_Category)
  ) %>%
  select(-Predicted_Category)


classif_ing <- classif_ing %>%
  mutate(
    D.Item = D.Item%>%
      str_to_lower() %>%
      str_replace_all("[^a-z0-9 ]", " ") %>%
      str_squish()
  )

# 4) Join and fill missing Ingredient_Category
classif_ing <- classif_ing %>%
  left_join(
    ingredient_additional_classif %>% select(D.Item, Predicted_Category),
    by = c("D.Item")
  ) %>%
  mutate(
    M7_Category = coalesce(M7_Category, Predicted_Category)
  ) %>%
  select(-Predicted_Category)

classif_ing_simple <- classif_ing %>%
  select(D.Item, Ingredient_Category = M7_Category)%>%
  mutate(Ingredient_Category=roman_to_name(Ingredient_Category))



```


```{r}
ingredients <-ingredients%>%
  filter(D.Item!="salt")

unmatched_ing_m7 <- ingredients %>%
  filter(is.na(Ingredient_Category)) %>%
  distinct(D.Item) %>%
  left_join(canon_ing, by = "D.Item") %>%
  arrange(D.Item)
```

### k means for ingredients 
```{r}


# ---------- Windows & priority (your spec) ----------
win <- list(
  GE  = list(I=c(17,19), II=c(30,38), III=c(18,20), IV=c(16,18), V=c(15,17)),
  Ash = list(I=c(20,40),   II=c(0,10),   III=c(50,80),   IV=c(70,100),  V=c(60,100), VI=c(500,1000)),
  CP  = list(I=c(80,120),  II=c(0,50),   III=c(350,500), IV=c(120,200), V=c(30,80)),
  EE  = list(I=c(20,50),   II=c(80,990), III=c(20,60),   IV=c(10,30),   V=c(0,20)),
  NDF = list(I=c(100,200), II=c(0,50),   III=c(100,300), IV=c(400,500), V=c(600,750))
)
priority <- list(
  I  = c("NDF","CP"),
  II = c("EE"),
  III= c("CP","NDF"),
  IV = c("NDF","CP"),
  V  = c("NDF","CP"),
  VI = c("Ash")
)

expand10 <- function(x) c(x[1]*0.9, x[2]*1.1)
mid      <- function(r) mean(r, na.rm = TRUE)
w10 <- map(win, ~ map(.x, expand10))  # ±10% windows (Method 6 spirit)

# ---------- 1) Build the working table from *your* dataset ----------
# Expecting unmatched_ing_m7 to already contain D.Item (+ optionally D.Type) and nutrients
unmatched <- unmatched_ing_m7 %>%
  select(any_of(c("D.Item","D.Type","GE","Ash","CP","EE","NDF"))) %>%
  group_by(across(any_of(c("D.Item","D.Type")))) %>%
  summarise(across(c(GE, Ash, CP, EE, NDF),
                   ~ suppressWarnings(mean(as.numeric(.), na.rm = TRUE))),
            .groups = "drop") %>%
  mutate(across(c(GE, Ash, CP, EE, NDF), ~ ifelse(is.nan(.), NA_real_, .))) %>%
  # drop rows where ALL five nutrients are NA
  filter(!(is.na(GE) & is.na(Ash) & is.na(CP) & is.na(EE) & is.na(NDF))) %>%
  mutate(
    n_values = rowSums(!is.na(across(c(GE, Ash, CP, EE, NDF)))),
    Missing  = pmap_chr(select(., GE, Ash, CP, EE, NDF), ~ {
      nm <- c("GE","Ash","CP","EE","NDF"); vv <- c(...); miss <- nm[is.na(vv)]
      if (length(miss)==0) "—" else paste(miss, collapse = ", ")
    })
  )

# ---------- 2) Priority-based score with HARD GATES ----------
# Standardized violation (0 if inside; >0 if outside by fraction of window width)
std_violation <- function(x, rng) {
  if (is.na(x) || any(is.na(rng))) return(NA_real_)
  L <- rng[1]; U <- rng[2]; W <- U - L; if (W <= 0) return(NA_real_)
  if (x < L) (L - x)/W else if (x > U) (x - U)/W else 0
}

cats <- names(priority)
missing_penalty <- 0.75  # penalty if a priority var is missing

scores <- matrix(NA_real_, nrow = nrow(unmatched), ncol = length(cats))
colnames(scores) <- cats

# Hard gates (fixes the “all go to II” issue):
gate_ii_lb  <- w10$EE$II[1]   # 72 (0.9 * 80)
gate_vi_lb  <- w10$Ash$VI[1]  # 450 (0.9 * 500)

for (j in seq_along(cats)) {
  cat <- cats[j]
  req <- priority[[cat]]

  # Per-variable violations for this category
  vlist <- lapply(req, function(v) {
    x   <- unmatched[[v]] %>% as.numeric()
    rng <- w10[[v]][[cat]]
    sapply(x, std_violation, rng = rng)
  })
  vmat <- do.call(cbind, vlist)

  # Replace NA violations (missing values) with bounded penalty
  vmat[is.na(vmat)] <- missing_penalty

  # Mean violation across this category’s priority vars
  s <- rowMeans(vmat)

  # Apply gates:
  if (cat == "II") {
    ee <- unmatched$EE
    s[is.na(ee) | ee < gate_ii_lb] <- Inf
  }
  if (cat == "VI") {
    ash <- unmatched$Ash
    s[is.na(ash) | ash < gate_vi_lb] <- Inf
  }

  scores[, j] <- s
}

best_idx   <- apply(scores, 1, which.min)
second_idx <- apply(scores, 1, function(v) order(v, na.last = TRUE)[2])

Assigned_Category    <- cats[best_idx]
Distance_Closest     <- scores[cbind(seq_len(nrow(scores)), best_idx)]
Second_Best_Category <- cats[second_idx]
Distance_Second      <- scores[cbind(seq_len(nrow(scores)), second_idx)]

# How many priority vars actually present for the chosen cat?
n_used_priority <- map2_int(seq_len(nrow(unmatched)), best_idx, function(i, j) {
  req <- priority[[cats[j]]]
  sum(!is.na(unmatched[i, req]))
})
Priority_vars_used <- map2_chr(seq_len(nrow(unmatched)), best_idx, function(i, j) {
  req <- priority[[cats[j]]]; have <- req[!is.na(unmatched[i, req])]
  if (length(have)==0) "—" else paste(have, collapse = ", ")
})
Priority_vars_missing <- map2_chr(seq_len(nrow(unmatched)), best_idx, function(i, j) {
  req <- priority[[cats[j]]]; miss <- req[is.na(unmatched[i, req])]
  if (length(miss)==0) "—" else paste(miss, collapse = ", ")
})

results <- unmatched %>%
  mutate(
    Assigned_Category    = Assigned_Category,
    Distance_Closest     = round(Distance_Closest, 3),
    Second_Best_Category = Second_Best_Category,
    Distance_Second      = round(Distance_Second, 3),
    n_used_priority      = n_used_priority,
    Priority_vars_used   = Priority_vars_used,
    Priority_vars_missing= Priority_vars_missing
  ) %>%
  arrange(Assigned_Category, Distance_Closest, desc(n_values), D.Item)

DT::datatable(
  results %>% select(D.Item, any_of("D.Type"), GE, Ash, CP, EE, NDF,
                     n_values, Missing,
                     Assigned_Category, Distance_Closest,
                     Second_Best_Category, Distance_Second,
                     n_used_priority, Priority_vars_used, Priority_vars_missing),
  caption = "M7-unclassified (from unmatched_ing_m7) → priority-window assignment (±10%), with gates for II/VI",
  options = list(pageLength = 50, dom = "tip"),
  rownames = FALSE
)

# ---------- 3) Quick plots (centroids midpoints + item segments) ----------
centroids_full <- tibble(
  Category = c("I","II","III","IV","V","VI"),
  GE  = c(mid(win$GE$I),  mid(win$GE$II),  mid(win$GE$III),  mid(win$GE$IV),  mid(win$GE$V),  NA_real_),
  Ash = c(mid(win$Ash$I), mid(win$Ash$II), mid(win$Ash$III), mid(win$Ash$IV), mid(win$Ash$V), mid(win$Ash$VI)),
  CP  = c(mid(win$CP$I),  mid(win$CP$II),  mid(win$CP$III),  mid(win$CP$IV),  mid(win$CP$V),  NA_real_),
  EE  = c(mid(win$EE$I),  mid(win$EE$II),  mid(win$EE$III),  mid(win$EE$IV),  mid(win$EE$V),  NA_real_),
  NDF = c(mid(win$NDF$I), mid(win$NDF$II), mid(win$NDF$III), mid(win$NDF$IV), mid(win$NDF$V), NA_real_)
)

plot_pair <- function(items_df, cents_df, xvar, yvar) {
  items_xy <- items_df %>% filter(!is.na(.data[[xvar]]), !is.na(.data[[yvar]]))
  cents_xy <- cents_df %>% filter(!is.na(.data[[xvar]]), !is.na(.data[[yvar]])) %>%
    transmute(Category, cx = .data[[xvar]], cy = .data[[yvar]])
  items_xy <- items_xy %>% left_join(cents_xy, by = c("Assigned_Category" = "Category"))

  ggplot() +
    geom_point(data = items_xy,
               aes(x = .data[[xvar]], y = .data[[yvar]], color = Assigned_Category),
               size = 2, alpha = 0.9) +
    geom_segment(data = items_xy %>% filter(!is.na(cx), !is.na(cy)),
                 aes(x = .data[[xvar]], y = .data[[yvar]], xend = cx, yend = cy, color = Assigned_Category),
                 alpha = 0.4, linewidth = 0.6) +
    geom_point(data = cents_xy, aes(x = cx, y = cy), shape = 4, size = 4, stroke = 1.1) +
    geom_text(data = cents_xy, aes(x = cx, y = cy, label = Category), vjust = -1, fontface = "bold") +
    labs(x = xvar, y = yvar, color = "Assigned",
         title = paste(xvar, "vs", yvar, "— items and category centroids")) +
    theme_minimal()
}

print(plot_pair(results, centroids_full, "CP", "NDF"))
print(plot_pair(results, centroids_full, "EE", "NDF"))

```


```{r}
# ---- Assign the first (best) category back to `ingredients` ----
# Roman → full name map (keep if you already have it)
if (!exists("roman_to_name")) {
  roman_to_name <- function(x) dplyr::recode(
    x,
    "I"   = "High-starch",
    "II"  = "High-fat",
    "III" = "Protein",
    "IV"  = "Good forage",
    "V"   = "Poor forage",
    "VI"  = "Mineral/Vitamin",
    .default = x, .missing = NA_character_)
}

# Join keys (prefer D.Item + D.Type if you have both)
join_keys <- intersect(c("D.Item"), names(ingredients))

# Make the assignment table unique on the join keys (prevents many-to-many)
assign_tbl <- results %>%
  mutate(Assigned_Category_Name = roman_to_name(Assigned_Category)) %>%
  select(any_of(c("D.Item","D.Type")), Assigned_Category, Assigned_Category_Name) %>%
  group_by(across(all_of(join_keys))) %>%
  summarise(
    Assigned_Category      = dplyr::first(Assigned_Category),
    Assigned_Category_Name = dplyr::first(Assigned_Category_Name),
    .groups = "drop"
  )

# Keep a backup of existing labels the first time you run this
if (!"Ingredient_Category_orig" %in% names(ingredients)) {
  ingredients <- ingredients %>%
    mutate(Ingredient_Category_orig = Ingredient_Category)
}

# Ensure Category_Source exists (so mutate below can reference it)
if (!"Category_Source" %in% names(ingredients)) {
  ingredients <- ingredients %>% mutate(Category_Source = NA_character_)
}



classif_ing_simple <- classif_ing_simple %>%
  mutate(Category_Source = NA_character_) %>%  # ensure column exists
  left_join(assign_tbl, by = "D.Item") %>%
  mutate(
    Ingredient_Category = coalesce(Ingredient_Category, Assigned_Category),
    Category_Source     = if_else(!is.na(Assigned_Category_Name), "Nearest-window", Category_Source)
  ) %>%
  select(-Assigned_Category, -Assigned_Category_Name)


```

```{r}


ingredients <- ingredients %>%
  left_join(
    classif_ing_simple %>% select(D.Item, Ingredient_Category_new = Ingredient_Category, Category_Source),
    by = "D.Item"
  ) %>%
  mutate(
    Ingredient_Category = coalesce(Ingredient_Category, Ingredient_Category_new)
  ) %>%
  select(-Ingredient_Category_new)

# ---- Final polish: convert Roman numerals to readable names ----
ingredients <- ingredients %>%
  mutate(
    Ingredient_Category = roman_to_name(Ingredient_Category)
  )

unmatched_ing<- ingredients %>%
  filter(is.na(Ingredient_Category)) %>%
  distinct(D.Item) %>%
  left_join(canon_ing, by = "D.Item") %>%
  arrange(D.Item)


```

## classifying diets 

```{r}
diets <- merged_metadata$Animals.Diet$A.Level.Name

diet_classif <- merged_metadata$Animals.Diet.Comp %>%
  filter(D.Item %in% diets) 


# Convert wide → long for all nutrient values (for classification)
diet_classif_long <- diet_classif %>%
  filter(!is.na(DC.Variable), DC.Variable %in% c("GE","Ash","CP","EE","NDF")) %>%
  mutate(
    DC.Value = suppressWarnings(as.numeric(DC.Value)),
    B.Code = str_trim(B.Code)
  ) %>%
  select(B.Code, D.Item, DC.Variable, DC.Value,is_entire_diet,is_group)



nutr_diet <- build_nutr_table(diet_classif_long, type_lookup, backfill_by_item = FALSE) %>%
  mutate(scope = "diet") %>%
  relocate(scope, .before = B.Code)

classif_diet <- nutr_diet %>%  # ← keep DIETS per-row (no mean collapse)
  method1() %>% method2() %>% method3() %>% method4() %>%
  method5() %>% method6() %>% method7()

rep_diet <- build_reports(classif_diet)

# Display (diets)
datatable(classif_diet %>% arrange(M7_Category),
          caption = "DIETS: Classified rows (sorted by M7)",
          rownames = FALSE, options = list(pageLength = 30, dom = "tip"))
datatable(rep_diet$coverage,    caption = "DIETS: Coverage by method",   options = list(pageLength = 10, dom = "tip"))
datatable(rep_diet$counts,      caption = "DIETS: Counts per category",  options = list(pageLength = 25, dom = "tip"))
datatable(rep_diet$samples,     caption = "DIETS: Random examples",      options = list(pageLength = 25, dom = "tip"))
datatable(rep_diet$unclassified,caption = "DIETS: Top-10 unclassified",  options = list(pageLength = 25, dom = "tip"))

classif_diet_simple <- classif_diet %>%
  rename(A.Level.Name = D.Item) %>%
  select(A.Level.Name, Diet_Category = M7_Category)


```



```{r}
library(dplyr)


unmatched_diet <- classif_diet %>%
  # standardize the diet key
  # not yet classified by M7
  filter(is.na(M7_Category)) %>%
  select(any_of(c(
    "scope","B.Code","D.Item","CP","NDF","Ash","EE","GE","M7_Category"
  ))) %>%
  distinct()


unmatched_keys <- unmatched_diet %>%
  distinct(B.Code, D.Item)


# 1) Diet % for unmatched diets only (canonical keys + proportions)
diet_perc_unmatched <- diet_percentages %>%
  mutate(
    w_prop       = suppressWarnings(as.numeric(Percentage_of_Diet))/100
  ) %>%
  semi_join(unmatched_keys, by = c("B.Code","A.Level.Name" = "D.Item"))

# 2) Build whole-diet nutrients when ALL ingredients have GE/Ash/CP/EE/NDF
diet_perc_nutr <- diet_perc_unmatched %>%
  left_join(classif_diet %>% select(D.Item, GE, Ash, CP, EE, NDF), by = "D.Item")

diet_ok <- diet_perc_nutr %>%
  group_by(B.Code, A.Level.Name) %>%
  summarise(
    n_ing = n(),
    all_complete = all(!is.na(GE) & !is.na(Ash) & !is.na(CP) & !is.na(EE) & !is.na(NDF) & !is.na(w_prop)),
    .groups = "drop"
  ) %>% filter(all_complete)

diet_nutrients_from_perc_unmatched <- diet_perc_nutr %>%
  semi_join(diet_ok, by = c("B.Code","A.Level.Name")) %>%
  group_by(B.Code, A.Level.Name) %>%
  summarise(
    wsum   = sum(w_prop, na.rm = TRUE),
    GE     = sum(GE  * w_prop, na.rm = TRUE) / wsum,
    Ash    = sum(Ash * w_prop, na.rm = TRUE) / wsum,
    CP     = sum(CP  * w_prop, na.rm = TRUE) / wsum,
    EE     = sum(EE  * w_prop, na.rm = TRUE) / wsum,
    NDF    = sum(NDF * w_prop, na.rm = TRUE) / wsum,
    .groups = "drop"
  ) %>%
  mutate(D.Item = A.Level.Name) %>%
  select(B.Code, D.Item, GE, Ash, CP, EE, NDF)

# 3) M1–M7 on unmatched diets, preferring computed nutrients where available
nutr_diet_unmatched <- unmatched_keys %>%
  left_join(diet_nutrients_from_perc_unmatched, by = c("B.Code","D.Item"))

classif_diet_unmatched <- nutr_diet_unmatched %>%
  method1() %>% method2() %>% method3() %>% method4() %>%
  method5() %>% method6() %>% method7() %>%
  mutate(Patch_Method = if_else(!is.na(M7_Category), "M7_numeric_from_perc", NA_character_))

# 4) Fallback for any still NA: most prevalent ingredient category (no thresholds)
ing_cat_map <- classif_ing %>%
  select(D.Item, Ingredient_Category=M7_Category) %>%
  distinct()

topcat_unmatched <- diet_perc_unmatched %>%
  left_join(ing_cat_map, by = "D.Item") %>%
  filter(!is.na(Ingredient_Category), !is.na(w_prop)) %>%
  group_by(B.Code, A.Level.Name, Ingredient_Category) %>%
  summarise(prop = sum(w_prop, na.rm = TRUE), .groups = "drop") %>%
  group_by(B.Code, A.Level.Name) %>%
  slice_max(prop, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  transmute(
    B.Code,
    D.Item = A.Level.Name,
    M7_Category_fallback = Ingredient_Category,
    Patch_Method_fallback = "by_category_dominance",
    Diet_Category_prop_top = prop
  )

# Apply fallback only where M7 still NA
classif_diet_unmatched <- classif_diet_unmatched %>%
  left_join(topcat_unmatched, by = c("B.Code","D.Item")) %>%
  mutate(
    used_fallback = is.na(M7_Category) & !is.na(M7_Category_fallback),
    M7_Category   = coalesce(M7_Category, M7_Category_fallback),
    Patch_Method  = coalesce(Patch_Method, if_else(used_fallback, Patch_Method_fallback, NA_character_))
  ) %>%
  select(-used_fallback, -any_of(c("M7_Category_fallback","Patch_Method_fallback")))

# --- ensure method column exists and stamp initial M7 rows once ---
if (!"Diet_Category_method" %in% names(classif_diet)) {
  classif_diet <- classif_diet %>%
    mutate(Diet_Category_method = if_else(!is.na(M7_Category), "M7_numeric", NA_character_))
}

# 5) Merge the patch back WITHOUT overriding pre-classified diets
classif_diet_2nd <- classif_diet %>%
  left_join(
    classif_diet_unmatched %>%
      select(B.Code, D.Item,
             M7_Category_patch = M7_Category,
             Patch_Method,
             Diet_Category_prop_top),
    by = c("B.Code","D.Item")
  ) %>%
  mutate(
    used_patch  = is.na(M7_Category) & !is.na(M7_Category_patch),
    M7_Category = coalesce(M7_Category, M7_Category_patch),
    Diet_Category_method = case_when(
      used_patch & Patch_Method == "M7_numeric_from_perc"  ~ "M7_numeric_from_perc",
      used_patch & Patch_Method == "by_category_dominance" ~ "by_category_dominance",
      TRUE                                                 ~ Diet_Category_method
    )
  ) %>%
  select(-M7_Category_patch, -Patch_Method) %>%
  relocate(Diet_Category_method, .after = M7_Category)

roman_to_name <- function(x) dplyr::recode(
  x,
  "I"   = "High-starch",
  "II"  = "High-fat",
  "III" = "Protein",
  "IV"  = "Good forage",
  "V"   = "Poor forage",
  "VI"  = "Mineral/Vitamin",
  .default = x, .missing = NA_character_
)

classif_diet_2nd <- classif_diet_2nd %>%
  mutate(across(dplyr::matches("^M[1-7]_Category$"), roman_to_name))

# (Optional) quick coverage report for the patch run
patched_n <- sum(classif_diet_2nd$used_patch, na.rm = TRUE)
message("Patched (newly classified) diets: ", patched_n)
classif_diet$used_patch <- NULL


```
category dominance

```{r}

all_diets <- dplyr::full_join(
  diet_percentages %>%
    dplyr::transmute(B.Code, DietKey = canonicalize_item(A.Level.Name)) %>%
    dplyr::distinct(),
  nutr_diet %>%
    dplyr::transmute(B.Code, DietKey = canonicalize_item(D.Item)) %>%
    dplyr::distinct(),
  by = c("B.Code","DietKey")
) %>% dplyr::distinct()

stage1_flags <- classif_diet %>%
  dplyr::transmute(B.Code,
                   DietKey = canonicalize_item(D.Item),
                   stage1  = !is.na(M7_Category))

stage2_flags <- classif_diet_2nd %>%
  dplyr::transmute(B.Code,
                   DietKey = canonicalize_item(D.Item),
                   stage2  = Diet_Category_method == "M7_numeric_from_perc")

stage3_flags <- classif_diet_2nd %>%
  dplyr::transmute(B.Code,
                   DietKey = canonicalize_item(D.Item),
                   stage3  = Diet_Category_method == "by_category_dominance")

coverage <- all_diets %>%
  dplyr::left_join(stage1_flags, by = c("B.Code","DietKey")) %>%
  dplyr::left_join(stage2_flags, by = c("B.Code","DietKey")) %>%
  dplyr::left_join(stage3_flags, by = c("B.Code","DietKey")) %>%
  dplyr::mutate(dplyr::across(c(stage1, stage2, stage3),
                              ~ tidyr::replace_na(., FALSE))) %>%
  dplyr::summarise(
    diets_total          = dplyr::n(),
    classified_stage1    = sum(stage1),
    pct_stage1           = round(100 * classified_stage1 / diets_total, 1),
    inc_stage2           = sum(!stage1 & stage2),
    cum_stage2           = classified_stage1 + inc_stage2,
    pct_cum_stage2       = round(100 * cum_stage2 / diets_total, 1),
    inc_stage3           = sum(!stage1 & !stage2 & stage3),
    cum_final            = cum_stage2 + inc_stage3,
    pct_cum_final        = round(100 * cum_final / diets_total, 1)
  )

final_method_breakdown <- all_diets %>%
  dplyr::left_join(
    classif_diet_2nd %>%
      dplyr::transmute(B.Code,
                       DietKey = canonicalize_item(D.Item),
                       M7_Category, Diet_Category_method),
    by = c("B.Code","DietKey")
  ) %>%
  dplyr::mutate(method = dplyr::case_when(
    is.na(M7_Category)                              ~ "Unclassified",
    Diet_Category_method == "by_category_dominance" ~ "Fallback: dominance",
    Diet_Category_method == "M7_numeric_from_perc"  ~ "M7 from % nutrients",
    TRUE                                            ~ "M7 initial"
  )) %>%
  dplyr::count(method, name = "n") %>%
  dplyr::mutate(pct = round(100 * n / sum(n), 1)) %>%
  dplyr::arrange(dplyr::desc(n))

print(final_method_breakdown)

cat("Stage1 keys missing in all_diets: ",
    nrow(dplyr::anti_join(stage1_flags, all_diets, by = c("B.Code","DietKey"))), "\n")
cat("Stage2 keys missing in all_diets: ",
    nrow(dplyr::anti_join(stage2_flags, all_diets, by = c("B.Code","DietKey"))), "\n")
cat("Stage3 keys missing in all_diets: ",
    nrow(dplyr::anti_join(stage3_flags, all_diets, by = c("B.Code","DietKey"))), "\n")

```


##k means diet

```{r}
# ─────────────────────────────────────────────────────────────────────────────
# Nearest-window (priority, ±10%, gated II/VI) for remaining unclassified diets
# Works after you have `classif_diet_2nd` (post M7 + % nutrients + dominance).
# ─────────────────────────────────────────────────────────────────────────────

# Reuse windows/priority/helpers if already defined; otherwise define them
if (!exists("win")) {
  win <- list(
    GE  = list(I=c(17,19), II=c(30,38), III=c(18,20), IV=c(16,18), V=c(15,17)),
    Ash = list(I=c(20,40),   II=c(0,10),   III=c(50,80),   IV=c(70,100),  V=c(60,100), VI=c(500,1000)),
    CP  = list(I=c(80,120),  II=c(0,50),   III=c(350,500), IV=c(120,200), V=c(30,80)),
    EE  = list(I=c(20,50),   II=c(80,990), III=c(20,60),   IV=c(10,30),   V=c(0,20)),
    NDF = list(I=c(100,200), II=c(0,50),   III=c(100,300), IV=c(400,500), V=c(600,750))
  )
}
if (!exists("priority")) {
  priority <- list(
    I  = c("NDF","CP"),
    II = c("EE"),
    III= c("CP","NDF"),
    IV = c("NDF","CP"),
    V  = c("NDF","CP"),
    VI = c("Ash")
  )
}
expand10 <- function(x) c(x[1]*0.9, x[2]*1.1)
w10 <- purrr::map(win, ~ purrr::map(.x, expand10))  # ±10% windows

std_violation <- function(x, rng) {
  if (is.na(x) || any(is.na(rng))) return(NA_real_)
  L <- rng[1]; U <- rng[2]; W <- U - L; if (W <= 0) return(NA_real_)
  if (x < L) (L - x)/W else if (x > U) (x - U)/W else 0
}

# 1) Pull remaining unclassified diets that have *some* nutrient info
diets_left <- classif_diet_2nd %>%
  dplyr::filter(is.na(M7_Category)) %>%
  dplyr::mutate(dplyr::across(c(GE, Ash, CP, EE, NDF),
                              ~ suppressWarnings(as.numeric(.)))) %>%
  # drop rows where ALL five are NA
  dplyr::filter(!(is.na(GE) & is.na(Ash) & is.na(CP) & is.na(EE) & is.na(NDF))) %>%
  dplyr::select(B.Code, D.Item, GE, Ash, CP, EE, NDF) %>%
  dplyr::distinct()

# If nothing to do, exit gracefully
if (nrow(diets_left) > 0) {

  # 2) Score each diet against categories (priority variables + gates)
  cats <- names(priority)
  missing_penalty <- 0.75
  gate_ii_lb  <- w10$EE$II[1]   # require EE high enough for cat II
  gate_vi_lb  <- w10$Ash$VI[1]  # require Ash high enough for cat VI

  scores <- matrix(NA_real_, nrow = nrow(diets_left), ncol = length(cats))
  colnames(scores) <- cats

  for (j in seq_along(cats)) {
    cat <- cats[j]
    req <- priority[[cat]]

    vlist <- lapply(req, function(v) {
      x   <- as.numeric(diets_left[[v]])
      rng <- w10[[v]][[cat]]
      vapply(x, std_violation, rng = rng, FUN.VALUE = numeric(1))
    })
    vmat <- do.call(cbind, vlist)
    vmat[is.na(vmat)] <- missing_penalty
    s <- rowMeans(vmat)

    if (cat == "II") {
      ee <- diets_left$EE
      s[is.na(ee) | ee < gate_ii_lb] <- Inf
    }
    if (cat == "VI") {
      ash <- diets_left$Ash
      s[is.na(ash) | ash < gate_vi_lb] <- Inf
    }
    scores[, j] <- s
  }

  best_idx <- apply(scores, 1, which.min)
  second_idx <- apply(scores, 1, function(v) order(v, na.last = TRUE)[2])

  diet_results <- diets_left %>%
    dplyr::mutate(
      Assigned_Category    = cats[best_idx],
      Distance_Closest     = round(scores[cbind(seq_len(nrow(scores)), best_idx)], 3),
      Second_Best_Category = cats[second_idx],
      Distance_Second      = round(scores[cbind(seq_len(nrow(scores)), second_idx)], 3)
    )

  # 3) Merge back *without overriding* any previously assigned categories
  classif_diet_3rd <- classif_diet_2nd %>%
    dplyr::left_join(
      diet_results %>% dplyr::select(B.Code, D.Item, Assigned_Category),
      by = c("B.Code","D.Item")
    ) %>%
    dplyr::mutate(
      used_nearest = is.na(M7_Category) & !is.na(Assigned_Category),
      M7_Category  = dplyr::coalesce(M7_Category, Assigned_Category),
      Diet_Category_method = dplyr::case_when(
        used_nearest ~ "nearest_window_diet",
        TRUE         ~ Diet_Category_method
      )
    ) %>%
    dplyr::select(-Assigned_Category)

  # 4) Optional: add a full-text label for readability
  roman_to_name <- function(x) dplyr::recode(
    x,
    "I"   = "High-starch",
    "II"  = "High-fat",
    "III" = "Protein",
    "IV"  = "Good forage",
    "V"   = "Poor forage",
    "VI"  = "Mineral/Vitamin",
    .default = x, .missing = NA_character_
  )
  classif_diet_3rd <- classif_diet_3rd %>%
    dplyr::mutate(M7_Category_full = roman_to_name(M7_Category))%>%
    mutate(M7_Category=roman_to_name(M7_Category))

  # 5) Replace your working table
  classif_diet_2nd <- classif_diet_3rd

  # 6) Quick message
  newly_classified <- sum(classif_diet_2nd$Diet_Category_method == "nearest_window_diet", na.rm = TRUE)
  message("Nearest-window (diet) classified additional diets: ", newly_classified)
} else {
  message("No remaining unclassified diets with any nutrient info to process.")
}

```

```{r}
# ─────────────────────────────────────────────────────────────────────────────
# Coverage summary after all methods (initial M7, % nutrients, dominance, nearest)
# ─────────────────────────────────────────────────────────────────────────────

# Universe of diets (union of % table and nutrient table)
all_diets <- dplyr::full_join(
  diet_percentages %>%
    dplyr::transmute(B.Code, DietKey = canonicalize_item(A.Level.Name)) %>%
    dplyr::distinct(),
  nutr_diet %>%
    dplyr::transmute(B.Code, DietKey = D.Item) %>%
    dplyr::distinct(),
  by = c("B.Code","DietKey")
) %>% dplyr::distinct()

# Pull method tags from the FINAL table
flags <- all_diets %>%
  dplyr::left_join(
    classif_diet_2nd %>%
      dplyr::transmute(
        B.Code,
        DietKey = D.Item,
        method = Diet_Category_method,
        classified = !is.na(M7_Category)
      ),
    by = c("B.Code","DietKey")
  ) %>%
  dplyr::mutate(
    stage_init = method == "M7_numeric",
    stage_perc = method == "M7_numeric_from_perc",
    stage_dom  = method == "by_category_dominance",
    stage_near = method == "nearest_window_diet"
  ) %>%
  tidyr::replace_na(list(
    stage_init = FALSE, stage_perc = FALSE, stage_dom = FALSE, stage_near = FALSE,
    classified = FALSE
  ))

# Incremental & cumulative coverage
coverage_all <- flags %>%
  dplyr::summarise(
    diets_total    = dplyr::n(),
    # Stage 1 (initial only)
    classified_s1  = sum(stage_init),
    pct_s1         = round(100 * classified_s1 / diets_total, 1),

    # Stage 2 (new, not in stage 1)
    inc_s2         = sum(!stage_init & stage_perc),
    cum_s2         = classified_s1 + inc_s2,
    pct_cum_s2     = round(100 * cum_s2 / diets_total, 1),

    # Stage 3 (new, not in stage 1/2)
    inc_s3         = sum(!stage_init & !stage_perc & stage_dom),
    cum_s3         = cum_s2 + inc_s3,
    pct_cum_s3     = round(100 * cum_s3 / diets_total, 1),

    # Stage 4 (new, not in stage 1/2/3)
    inc_s4         = sum(!stage_init & !stage_perc & !stage_dom & stage_near),
    cum_final      = cum_s3 + inc_s4,
    pct_cum_final  = round(100 * cum_final / diets_total, 1)
  )

print(coverage_all)

# Final method breakdown (how many diets ended up with each path)
final_method_breakdown <- all_diets %>%
  dplyr::left_join(
    classif_diet_2nd %>% dplyr::select(B.Code, DietKey = D.Item, M7_Category, Diet_Category_method),
    by = c("B.Code","DietKey")
  ) %>%
  dplyr::mutate(method_readable = dplyr::case_when(
    is.na(M7_Category)                          ~ "Unclassified",
    Diet_Category_method == "M7_numeric"        ~ "M7 initial",
    Diet_Category_method == "M7_numeric_from_perc"  ~ "M7 from % nutrients",
    Diet_Category_method == "by_category_dominance" ~ "Fallback: dominance",
    Diet_Category_method == "nearest_window_diet"   ~ "Nearest-window diet",
    TRUE ~ Diet_Category_method
  )) %>%
  dplyr::count(method_readable, name = "n") %>%
  dplyr::mutate(pct = round(100 * n / sum(n), 1)) %>%
  dplyr::arrange(dplyr::desc(n))

print(final_method_breakdown)

```


```{r}
write.csv(ingredients, "~/Emission_Analysis/data/ingredients_classified.csv")
write.csv(classif_diet_3rd, "~/Emission_Analysis/data/classif_diet.csv")
write.csv(classif_ing_simple, "~/Emission_Analysis/data/classif_ing_simple.csv")
write.csv(diet_percentages, "~/Emission_Analysis/data/diet_percentages_classif.csv")

```

## number of papers
```{r}
GE_combined <- read.csv("~/Emission_Analysis/data/GE_combined.csv")
# ─────────────────────────────────────────────────────────────


# Ensure species column name matches your GE data
species_col <- "P.Product"

# 1️⃣ Filter emission dataset to keep only papers with CH4 values
ge_with_emissions <- GE_combined %>%
  filter(!is.na(CH4_kg_year)) %>%             # keep rows with CH4 data
  group_by(B.Code, !!sym(species_col)) %>%
  summarise(has_CH4 = any(!is.na(CH4_kg_year)), .groups = "drop") %>%
  rename(Species = !!sym(species_col)) %>%
  filter(has_CH4) %>%
  select(B.Code, Species) %>%
  distinct()

# 2️⃣ Status for ingredients (complete classification)
ing_classified_status <- ingredients %>%
  group_by(B.Code) %>%
  summarise(
    n_ing = n(),
    n_ing_classified = sum(!is.na(Ingredient_Category)),
    all_ing_classified = n_ing > 0 & (n_ing_classified == n_ing),
    .groups = "drop"
  )

# 3️⃣ Status for diets (≥ 2 classified)
diet_classified_status <- classif_diet_3rd %>%
  group_by(B.Code) %>%
  summarise(
    n_diets_classified = sum(!is.na(M7_Category)),
    two_or_more_diets = n_diets_classified >= 2,
    .groups = "drop"
  )

# 4️⃣ Papers with all ingredients classified + CH4 data
papers_all_ing <- ing_classified_status %>%
  filter(all_ing_classified) %>%
  inner_join(ge_with_emissions, by = "B.Code")

summary_ing_by_species <- papers_all_ing %>%
  group_by(Species) %>%
  summarise(
    N_Papers_All_Ingredients = n_distinct(B.Code),
    .groups = "drop"
  )

# 5️⃣ Papers with ≥2 diets classified + CH4 data
papers_two_diets <- diet_classified_status %>%
  filter(two_or_more_diets) %>%
  inner_join(ge_with_emissions, by = "B.Code")

summary_diets_by_species <- papers_two_diets %>%
  group_by(Species) %>%
  summarise(
    N_Papers_TwoPlus_Diets = n_distinct(B.Code),
    .groups = "drop"
  )

# 6️⃣ Combine both summaries
summary_by_species <- full_join(
  summary_ing_by_species,
  summary_diets_by_species,
  by = "Species"
) %>%
  mutate(across(starts_with("N_"), ~ replace_na(., 0))) %>%
  arrange(Species)

# 7️⃣ Print as table
knitr::kable(summary_by_species,
             caption = "Papers with CH₄ data meeting classification criteria, by species")

```


---
title: "8_bis_Emission_Analysis_high_level"
output: html_document
date: "2025-10-28"
---

# A Productivity‚ÄìEmission Relationship Analysis


To characterize the relationship between animal productivity and methane emissions across ruminant production systems, we compiled experimental data from controlled feeding studies reporting both daily product yield and annual methane output per animal. Each observation represented a discrete diet treatment within a study, identified by a unique study identifier code. Productivity metrics were standardized to edible product yield, expressed as either milk yield (kg animal‚Åª¬π day‚Åª¬π) or meat yield derived from carcass composition or growth rate measurements. Methane emissions were standardized to annual production (kg CH‚ÇÑ animal‚Åª¬π yr‚Åª¬π).
Linear regression models were fitted independently for each species √ó product combination to quantify the relationship between productivity and absolute methane emissions. This approach captured within-study scaling relationships while maintaining comparability across experimental contexts. The analysis was restricted to genuine production outputs (milk or meat) to exclude potentially confounding metrics such as live weight gain or feed intake. Each regression coefficient therefore represents the empirical association between productivity and emission intensity across dietary treatments within comparable experimental frameworks.
The resulting relationships (Figure 1) illustrate how improvements in production output correspond to changes in total methane emission at the animal scale, providing cross-species visualization of productivity‚Äìemission trade-offs. By employing experimental contrasts rather than aggregated national inventory data, this analytical framework isolated biological variation in feed efficiency from management- or system-level effects.
```{r include=FALSE}

library(dplyr)
library(tidyr)
library(stringr)
library(readr)
library(ggplot2)
library(forcats)
library(scales)

GE_combined <- read.csv("~/Emission_Analysis/data/GE_Combined.csv")
merged_metadata <- readRDS("~/Emission_Analysis/data/merged_metadata_nutrition_inference.rds")
ingredients <- read.csv("~/Emission_Analysis/data/ingredients_harmonized_subset.csv")
yield_data<- read.csv("~/Emission_Analysis/data/yield_data.csv")%>%select(-c("P.Product"))
diet_percentages <- read.csv("~/Emission_Analysis/data/diet_percentages_classif.csv")
total_amounts <- read.csv("~/Emission_Analysis/data/total_amounts.csv")
ing_classif<-read.csv("~/Emission_Analysis/data/classif_ing_simple.csv")



```


```{r include=FALSE}
clean_key <- function(x) x %>% str_trim() %>% str_squish() %>% str_to_lower()
canonicalize_item <- function(x) {
  clean_key(x) %>%
    str_replace_all("\\bbran\\b", "offal")
}

  
  merged_metadata$Animals.Diet.Comp <- merged_metadata$Animals.Diet.Comp %>%
  mutate(D.Item = canonicalize_item(D.Item)) 
  
    diet_percentages <-diet_percentages %>%
  mutate(D.Item = canonicalize_item(D.Item)) 

```



```{r echo=FALSE,fig.width=12, fig.height=7, out.width='100%', fig.align='center'}

# ============================================================
# Clean merge, filter to real Milk/Meat yields, facet counts,
# and scatter+LM with per-facet (n, codes) labels (top-right)
# ============================================================

# --- 1) Harmonize keys and basic cleaning -------------------
GE_combined_for_merge <- GE_combined %>%
  dplyr::filter(!is.na(CH4_kg_year)) %>%              # keep rows with CH4
  dplyr::rename(A.Level.Name = D.Item) %>%            # align join key
  dplyr::select(-"ED.Mean.T")                         # avoid duplicate yield col

yield_data_clean <- yield_data %>%
  dplyr::filter(!is.na(ED.Mean.T)) %>%                # need yield
  dplyr::filter(Out.Subind != "Meat Yield-Final Body Weight")

# --- 2) Merge yield and emission data -----------------------
yield_with_emissions <- GE_combined_for_merge %>%
  dplyr::left_join(
    yield_data_clean,
    by = c("B.Code", "A.Level.Name")
  ) %>%
  dplyr::filter(!is.na(ED.Mean.T), !is.na(CH4_kg_year)) %>%
  dplyr::distinct()

# --- 3) Optional: distinct B.Code per species ---------------
bcode_per_product <- yield_with_emissions %>%
  dplyr::distinct(P.Product, B.Code) %>%
  dplyr::count(P.Product, name = "n_BCodes")

# --- 4) Keep only true Milk/Meat yield outcomes + parse Product ----
species_order <- c("Cattle", "Goat", "Sheep")  # adjust if needed

yield_with_emissions <- yield_with_emissions %>%
  dplyr::mutate(P.Product = factor(P.Product, levels = species_order)) %>%
  dplyr::filter(
    (
      stringr::str_detect(Out.Subind, stringr::regex("Milk Yield", ignore_case = TRUE)) |
      stringr::str_detect(Out.Subind, stringr::regex("Meat Yield", ignore_case = TRUE))
    ) &
    !stringr::str_detect(Out.Subind, stringr::regex("Body Weight|Final", ignore_case = TRUE))
  ) %>%
  dplyr::mutate(
    Product = dplyr::case_when(
      stringr::str_detect(Out.Subind, stringr::regex("milk", ignore_case = TRUE)) ~ "Milk",
      stringr::str_detect(Out.Subind, stringr::regex("meat", ignore_case = TRUE)) ~ "Meat",
      TRUE ~ NA_character_
    )
  ) %>%
  dplyr::filter(!is.na(Product)) %>%
  # Build a facet label used in both plotting and counting
  dplyr::mutate(facet = interaction(P.Product, Product, sep = " ‚Äì "))

# --- 5) Per-facet counts: n observations & unique B.Codes ---
facet_counts <- yield_with_emissions %>%
  dplyr::group_by(facet) %>%
  dplyr::summarise(
    n_obs   = dplyr::n(),
    n_codes = dplyr::n_distinct(B.Code),
    .groups = "drop"
  ) %>%
  dplyr::mutate(lab = paste0("n=", n_obs, "; papers=", n_codes))

# --- 6) Plot: scatter + LM with per-facet labels ------------
ggplot(yield_with_emissions,
       aes(x = ED.Mean.T, y = CH4_kg_year)) +
  geom_point(color = "grey40", alpha = 0.35, size = 1.8) +
  geom_smooth(
    method = "lm", se = TRUE,
    color = "grey20", linewidth = 0.5,
    fill = scales::alpha("lightblue", 0.991)
  ) +
  facet_wrap(~ facet, scales = "free") +
  # top-right annotation for each facet
  geom_text(
    data = facet_counts,
    aes(x = Inf, y = Inf, label = lab),
    inherit.aes = FALSE,
    hjust = 1.1, vjust = 1.5,
    fontface = "bold", size = 3.5, color = "black"
  ) +
  scale_y_continuous(
    "Annual CH‚ÇÑ emissions (kg CH‚ÇÑ animal‚Åª¬π yr‚Åª¬π)",
    labels = scales::comma_format()
  ) +
  scale_x_continuous(
    "Yield (kg product animal‚Åª¬π day‚Åª¬π)",
    labels = scales::comma_format()
  ) +
  theme_minimal(base_size = 13) +
  theme(
    panel.grid.major = element_line(color = "grey92", linewidth = 0.3),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 12, face = "bold"),
    axis.title = element_text(face = "plain"),
    axis.text  = element_text(color = "black"),
    plot.title = element_text(face = "bold", hjust = 0.5),
    legend.position = "none",
    plot.margin = margin(5.5, 16, 5.5, 5.5)  # a bit more room for labels
  )

# Optional: total unique study codes used after filtering
n_unique_codes <- dplyr::n_distinct(yield_with_emissions$B.Code)
n_unique_codes


```
Figure 1 shows the relationship between annual enteric CH‚ÇÑ emissions and product yield for cattle, goats, and sheep, separated by meat and milk production systems. Across all species, CH‚ÇÑ emissions increase with yield, indicating that higher-producing animals generally emit more methane per year. However, the magnitude and slope of these relationships differ among species. Cattle have the highest absolute CH‚ÇÑ emissions, reflecting their larger size and output levels, while goats and sheep emit less overall but follow similar positive trends. The slope of increase appears steeper in goats and sheep, suggesting that small changes in productivity are associated with relatively larger changes in CH‚ÇÑ output in these smaller ruminants. These species-specific patterns highlight the diversity of emission‚Äìyield dynamics captured in African feeding trials and underscore the need to interpret CH‚ÇÑ responses within the biological and management context of each species.

```{r include=FALSE}
# --- 2) Ensure we have diet_details and diet_shares (built from your data) ----
# If you already have these objects, this block will just reuse them.

# Keep only precise outcomes you compare within-paper
keep_outcomes <- c(
  "Milk Yield","Meat Yield","Meat Yield-Hot Carcass","Meat Yield-Cold Carcass",
  "Meat Yield-Slaughter Body","Meat Yield- Carcass","Meat Yield-Empty Carcass Meat Yield"
)

# Build yield_with_emissions_ranked if not present
if (!exists("yield_with_emissions_ranked")) {
  stopifnot(exists("yield_with_emissions"))  # you said this is available
  yield_with_emissions_ranked <- yield_with_emissions %>%
    filter(Out.Subind %in% keep_outcomes) %>%
    mutate(
      CH4_kg_day = CH4_kg_year/365,
      EI_kgCH4_per_kgProd = CH4_kg_day / ED.Mean.T
    ) %>%
    group_by(P.Product, Product, Out.Subind, B.Code) %>%
    mutate(
      yield_scaled = as.numeric(scale(ED.Mean.T)),
      ch4_scaled   = as.numeric(scale(CH4_kg_year))
    ) %>%
    ungroup()}

# Build diet_details from your ingredient shares
stopifnot(exists("diet_percentages"))
diet_details <- yield_with_emissions_ranked %>%
  select(P.Product, Product, Out.Subind, B.Code, A.Level.Name, ED.Mean.T,
         CH4_kg_year, CH4_kg_day, EI_kgCH4_per_kgProd, T.Control) %>%
  distinct() %>%
  left_join(
    diet_percentages %>%
      rename(
        Ingredient.Name = any_of(c("Ingredient.Name","D.Item")),
        Diet.Percent    = any_of(c("Diet.Percent","Percentage_of_Diet"))
      ) %>%
      mutate(Ingredient.Name = tolower(Ingredient.Name)) %>%
      select(B.Code, A.Level.Name, Ingredient.Name, Diet.Percent),
    by = c("B.Code","A.Level.Name")
  )

# Normalize to shares (sums to 1 per diet)
diet_shares <- diet_details %>%
  mutate(Ingredient.Name = tolower(Ingredient.Name)) %>%
  group_by(B.Code, Out.Subind, A.Level.Name) %>%
  mutate(share = Diet.Percent / sum(Diet.Percent, na.rm = TRUE)) %>%
  ungroup()

# --- 3) Read model-based nutrient data & standardize names (UPPERCASE) ----
# -> file: data/ingredients_high_level_model.csv
model_nutrients <- read_csv("data/ingredients_high_level_model.csv",
                            show_col_types = FALSE) %>%
  mutate(across(everything(), ~ ifelse(. == "", NA, .))) %>%
  mutate(across(where(is.character), tolower))

# normalize column names to lower, then rename to our standards
names(model_nutrients) <- tolower(names(model_nutrients))
model_nutrients <- model_nutrients %>%
  rename(D.Item = any_of(c("ingredient","d.item","item","feed","name"))) %>%
  mutate(D.Item = tolower(D.Item)) %>%
  # force nutrients to UPPERCASE names
  rename_with(~ toupper(.x), .cols = any_of(c("cp","ndf","adf","ee","ash","ge","me"))) %>%
  select(any_of(c("D.Item","CP","NDF","ADF","EE","ASH","GE","ME")))

# ============================================================
# üß© Empirical + Modeled Nutrient Composition (clean + compact)
# ============================================================

# --- 1Ô∏è‚É£ Extract empirical ingredient composition ----
ingredient_compo <- merged_metadata$Animals.Diet.Comp %>%
  filter(is_entire_diet == "FALSE") %>%
  mutate(D.Item = tolower(D.Item)) %>%
  filter(D.Item %in% tolower(diet_details$Ingredient.Name))




# --- 2Ô∏è‚É£ Combine empirical and modeled data ----
ingredient_compo_combined <- ingredient_compo %>%
  mutate(
    DC.Variable = toupper(DC.Variable),
    DC.Value = suppressWarnings(as.numeric(DC.Value))
  ) %>%
  filter(DC.Unit %in% c("g/kg", "MJ/kg"),
         DC.Variable %in% c("CP", "NDF", "ADF", "EE", "ASH", "GE", "ME")) %>%
  group_by(D.Item, DC.Variable) %>%
  summarise(DC.Value = mean(DC.Value, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = DC.Variable, values_from = DC.Value) %>%
  full_join(model_nutrients, by = "D.Item", suffix = c("", "_MODEL")) %>%
  mutate(
    CP  = coalesce(CP,  as.numeric(CP_MODEL)),
    NDF = coalesce(NDF, as.numeric(NDF_MODEL)),
    ADF = coalesce(ADF, as.numeric(ADF_MODEL)),
    EE  = coalesce(EE,  as.numeric(EE_MODEL)),
    ASH = coalesce(ASH, as.numeric(ASH_MODEL)),
    GE  = coalesce(GE,  as.numeric(GE_MODEL)),
    ME  = coalesce(ME,  as.numeric(ME_MODEL))
  ) %>%
  select(D.Item, CP, NDF, ADF, EE, ASH, GE, ME)

# --- 3Ô∏è‚É£ Add representative "molasses" nutrient values ----
molasses_means <- merged_metadata$Animals.Diet.Comp %>%
  filter(is_entire_diet == FALSE) %>%
  mutate(
    D.Item = tolower(D.Item),
    DC.Variable = toupper(DC.Variable),
    DC.Value = suppressWarnings(as.numeric(DC.Value))
  ) %>%
  filter(str_detect(D.Item, "^unspecified\\s*molasse")) %>%
  filter(
    DC.Unit %in% c("g/kg", "MJ/kg"),
    DC.Variable %in% c("CP", "NDF", "ADF", "EE", "ASH", "GE", "ME")
  ) %>%
  group_by(DC.Variable) %>%
  summarise(value = mean(DC.Value, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = DC.Variable, values_from = value) %>%
  mutate(D.Item = "molasses")

# Step 2Ô∏è‚É£ ‚Äì Replace the GE value with the mean GE from *all* molasse-type ingredients
molasses_GE_mean <- merged_metadata$Animals.Diet.Comp %>%
  filter(is_entire_diet == FALSE) %>%
  mutate(D.Item = tolower(D.Item)) %>%
  filter(str_detect(D.Item, "molasse")) %>%
  mutate(DC.Variable = toupper(DC.Variable)) %>%
  filter(DC.Variable == "GE", DC.Unit %in% c("g/kg", "MJ/kg")) %>%
  summarise(GE_mean = mean(as.numeric(DC.Value), na.rm = TRUE)) %>%
  pull(GE_mean)

# Step 3Ô∏è‚É£ ‚Äì Replace GE in the molasses table with the computed mean
molasses_means <- molasses_means %>%
  mutate(GE = molasses_GE_mean)


# Step 4Ô∏è‚É£ ‚Äì Add or replace this entry in the full composition table
ingredient_compo_combined <- ingredient_compo_combined %>%
  filter(D.Item != "molasses") %>%
  bind_rows(molasses_means %>% select(names(ingredient_compo_combined)))


cat("‚úÖ Combined empirical + modeled composition built, with 'molasses' added.\n")


cat("‚úÖ 'molasses' nutrient values set to mean of all ingredients containing 'molasse'.\n")


# --- 6) Nutrient coverage across all (used) ingredients ----
nutrient_coverage <- ingredient_compo_combined %>%
  pivot_longer(cols = c(CP, NDF, ADF, EE, ASH, GE, ME),
               names_to = "DC.Variable", values_to = "DC.Value") %>%
  group_by(DC.Variable) %>%
  summarize(
    n_with_value = sum(!is.na(DC.Value)),
    n_total      = n(),
    coverage_pct = round(100 * n_with_value / n_total, 1),
    .groups = "drop"
  ) %>%
  arrange(desc(coverage_pct))
cat("\n‚úÖ Nutrient coverage (ingredients used in diets):\n")
print(nutrient_coverage)

# --- 7) Define non-nutritional ingredients to ignore for completeness checks ----
non_nutritional_ingredients <- c(
  "salt", "urea", "lime", "cement", "alkali", "sulphur",
  "mineral mix", "minerals and vitamins mix", "mineral lick",
  "dicalcium phosphate", "monocalcium phosphate",
  "bone ground", "protected fat", "supplement",
  "mixture", "commercial feed", "vitamins", "trace minerals",
  "naoh", "ca(oh)2", "phosphate", "ash", "limestone",
  "molasses mineral mix", "salt block"
)

# --- 8) Which ingredients have complete core nutrients? (CP,NDF,ADF,EE,ASH,GE) ----
ingredient_has_data <- ingredient_compo_combined %>%
  filter(!D.Item %in% non_nutritional_ingredients) %>%
  mutate(across(c(CP, NDF, ADF, EE, ASH, ME), ~ !is.na(.))) %>%
  rename_with(~ paste0("HAS_", .), c(CP, NDF, ADF, EE, ASH, ME)) %>%
  mutate(ALL_CORE = if_all(starts_with("HAS_"), ~ .x))

# --- 9) Build ingredient nutrient table for joining (prefix with nut_) ----
ingredient_nut <- ingredient_compo_combined %>%
  filter(!D.Item %in% non_nutritional_ingredients) %>%   # <-- drop non-nutritional items
  rename(
    nut_CP = CP, nut_NDF = NDF, nut_ADF = ADF, nut_EE = EE,
    nut_ASH = ASH, nut_GE = GE, nut_ME = ME
  )

# --- 10) Diet-level nutrient composition (weighted by ingredient share) ----
nut_cols_gkg <- c("nut_CP","nut_NDF","nut_ADF","nut_EE","nut_ASH")
nut_cols_mj  <- c("nut_ME","nut_GE")

diet_nutrient <- diet_shares %>%
  left_join(ingredient_nut, by = c("Ingredient.Name" = "D.Item")) %>%
  group_by(P.Product, Product, Out.Subind, B.Code, A.Level.Name,
           T.Control, ED.Mean.T, CH4_kg_day, EI_kgCH4_per_kgProd) %>%
  summarise(across(
      all_of(c(nut_cols_gkg, nut_cols_mj)),
      ~ if (all(is.na(.x))) NA_real_ else sum(share * .x, na.rm = TRUE),
      .names = "{.col}"),
    n_ing_with_nut = sum(
      !is.na(nut_CP) | !is.na(nut_NDF) | !is.na(nut_ME) |
      !is.na(nut_ADF) | !is.na(nut_EE) | !is.na(nut_ASH)),
    .groups = "drop")



cat("\n‚úÖ Diet-level nutrient table built. N diets:", nrow(diet_nutrient), "\n")


# --- 11) Diet-level nutrient coverage with diagnostics ----

# 1Ô∏è‚É£ Compute diet coverage as before
diet_coverage <- diet_shares %>%
  mutate(Ingredient.Name = tolower(Ingredient.Name)) %>%
  filter(!Ingredient.Name %in% non_nutritional_ingredients) %>%
  left_join(
    ingredient_has_data %>%
      select(D.Item, ALL_CORE, HAS_CP, HAS_NDF, HAS_ADF, HAS_EE, HAS_ASH, HAS_ME),
    by = c("Ingredient.Name" = "D.Item")
  ) %>%
  group_by(B.Code, Out.Subind, P.Product, Product, A.Level.Name) %>%
  summarize(
    n_ing_total = n(),
    n_ing_with_all_nut = sum(ALL_CORE, na.rm = TRUE),
    pct_with_data = round(100 * n_ing_with_all_nut / n_ing_total, 1),
    .groups = "drop"
  )

cat("\nüìä Diet coverage computed for", nrow(diet_coverage), "diets.\n")

# 2Ô∏è‚É£ Identify incomplete diets (<100% nutrient coverage)
incomplete_diets <- diet_coverage %>%
  filter(pct_with_data < 100)

cat("\n‚ùó Incomplete diets found:", nrow(incomplete_diets), "\n")

# 3Ô∏è‚É£ Diagnose *which ingredients* are missing which nutrients
diet_missing_details <- diet_shares %>%
  mutate(Ingredient.Name = tolower(Ingredient.Name)) %>%
  filter(!Ingredient.Name %in% non_nutritional_ingredients) %>%
  left_join(
    ingredient_compo_combined %>%
      select(D.Item, CP, NDF, ADF, EE, ASH, ME),
    by = c("Ingredient.Name" = "D.Item")
  ) %>%
  mutate(
    missing_CP  = is.na(CP),
    missing_NDF = is.na(NDF),
    missing_ADF = is.na(ADF),
    missing_EE  = is.na(EE),
    missing_ASH = is.na(ASH),
    missing_ME  = is.na(ME),
    missing_any = missing_CP | missing_NDF | missing_ADF | missing_EE | missing_ASH | missing_ME
  ) %>%
  filter(missing_any) %>%
  select(
    B.Code, Out.Subind, Product, A.Level.Name, Ingredient.Name,
    missing_CP, missing_NDF, missing_ADF, missing_EE, missing_ASH, missing_ME
  ) %>%
  arrange(B.Code, A.Level.Name, Ingredient.Name)

# 4Ô∏è‚É£ Summary of missing ingredients per diet
missing_summary <- diet_missing_details %>%
  group_by(B.Code, A.Level.Name) %>%
  summarize(
    n_missing_ingredients = n_distinct(Ingredient.Name),
    .groups = "drop"
  ) %>%
  left_join(
    diet_coverage %>% select(B.Code, A.Level.Name, pct_with_data),
    by = c("B.Code", "A.Level.Name")
  ) %>%
  arrange(B.Code, desc(pct_with_data))

# 5Ô∏è‚É£ Display results
cat("\nüîç Missing nutrient details (first 15 rows):\n")
print(head(diet_missing_details, 15))

cat("\nüìà Summary of incomplete diets:\n")
print(missing_summary)

# 6Ô∏è‚É£ Fully covered diets (100% of relevant ingredients have all nutrients)
complete_diets <- diet_coverage %>% filter(pct_with_data == 100)
cat("\n‚úÖ Fully covered diets (relevant ingredients only):", nrow(complete_diets), "\n")

# Optional: Export diagnostics
# write_csv(diet_missing_details, "outputs/diet_missing_details.csv")
# write_csv(missing_summary, "outputs/diet_missing_summary.csv")



complete_diets <- diet_coverage %>% filter(pct_with_data == 100)
cat("\n‚úÖ Fully covered diets (relevant ingredients only):", nrow(complete_diets), "\n")


# --- 12) Reference diet per paper √ó outcome (control if present, else lowest EI) ----
# --- Reference diets: CONTROL else FIRST ROW ------------------------------
library(dplyr)

# Inputs assumed to exist:
#   diet_nutrient, nut_cols_gkg, nut_cols_mj
# Uses columns:
#   B.Code, Out.Subind, A.Level.Name, T.Control,
#   EI_kgCH4_per_kgProd, CH4_kg_day, ED.Mean.T

# ============================================================
# CHUNK A ‚Äî Reference diet + deltas (adds log-ratio outcomes)
# Assumes: diet_nutrient, nut_cols_gkg, nut_cols_mj are available
# Output: ref_diets, ref_full, diet_deltas (with lnCH4, lnY, lnEI)
# ============================================================

library(dplyr)

build_ref_full_control_then_first <- function(diet_nutrient,
                                              nut_cols_gkg,
                                              nut_cols_mj,
                                              order_col = NULL) {
  dn <- diet_nutrient

  # If no explicit ordering column is provided, preserve current row order
  if (is.null(order_col)) {
    dn <- dn %>%
      dplyr::group_by(B.Code, Out.Subind) %>%
      dplyr::mutate(.row_order = dplyr::row_number()) %>%
      dplyr::ungroup()
    order_col <- ".row_order"
  } else if (!order_col %in% names(dn)) {
    stop("order_col not found in diet_nutrient.")
  }

  # Collapse to unique diets within each study √ó outcome
  per_diet <- dn %>%
    dplyr::group_by(B.Code, Out.Subind, A.Level.Name) %>%
    dplyr::summarise(
      order_first = min(.data[[order_col]]),
      EI = dplyr::first(EI_kgCH4_per_kgProd),
      CH4 = dplyr::first(CH4_kg_day),
      Y   = dplyr::first(ED.Mean.T),
      is_control = any(isTRUE(T.Control)),
      .groups = "drop"
    )

  # Choose reference: CONTROL if present, otherwise FIRST SEEN ROW
  ref_diets <- per_diet %>%
    dplyr::group_by(B.Code, Out.Subind) %>%
    dplyr::mutate(any_control = any(isTRUE(is_control))) %>%
    dplyr::arrange(B.Code, Out.Subind, order_first) %>%
    dplyr::mutate(ref_flag = dplyr::if_else(any_control, is_control, order_first == min(order_first))) %>%
    dplyr::filter(ref_flag) %>%
    dplyr::slice_head(n = 1) %>%      # exactly one reference per study √ó outcome
    dplyr::ungroup()

  # Bring nutrient composition for the chosen reference
  ref_full <- ref_diets %>%
    dplyr::left_join(
      dn %>% dplyr::select(B.Code, Out.Subind, A.Level.Name, dplyr::all_of(c(nut_cols_gkg, nut_cols_mj))),
      by = c("B.Code","Out.Subind","A.Level.Name")
    ) %>%
    dplyr::rename(
      A.Level.Name_ref = A.Level.Name,
      EI_ref  = EI,
      CH4_ref = CH4,
      Y_ref   = Y
    ) %>%
    dplyr::rename_with(~ paste0(.x, "_ref"), dplyr::all_of(c(nut_cols_gkg, nut_cols_mj)))

  list(ref_diets = ref_diets, ref_full = ref_full)
}

# Build references
refs       <- build_ref_full_control_then_first(diet_nutrient, nut_cols_gkg, nut_cols_mj)
ref_diets  <- refs$ref_diets
ref_full   <- refs$ref_full

# Deltas + LOG RATIOS (ln of ratios to the reference)
diet_deltas <- diet_nutrient %>%
  dplyr::left_join(ref_full, by = c("B.Code","Out.Subind")) %>%
  dplyr::filter(A.Level.Name != A.Level.Name_ref) %>%
  dplyr::mutate(
    dY       = ED.Mean.T - Y_ref,
    dCH4     = CH4_kg_day - CH4_ref,
    dEI      = EI_kgCH4_per_kgProd - EI_ref,
    dY_pct   = 100 * dY   / Y_ref,
    dCH4_pct = 100 * dCH4 / CH4_ref,
    dEI_pct  = 100 * dEI  / EI_ref,
    # --- LOG RATIOS; protect against non-positive numerators/denominators
    lnCH4 = ifelse(CH4_kg_day > 0 & CH4_ref > 0, log(CH4_kg_day / CH4_ref), NA_real_),
    lnY   = ifelse(ED.Mean.T  > 0 & Y_ref     > 0, log(ED.Mean.T   / Y_ref), NA_real_),
    lnEI  = lnCH4 - lnY     # since EI = CH4 / Y
  ) %>%
  dplyr::mutate(
    dplyr::across(dplyr::all_of(c(nut_cols_gkg, nut_cols_mj)),
                  ~ . - get(paste0(cur_column(), "_ref")),
                  .names = "d{.col}")
  )

cat("\n‚úÖ Delta table (with ln outcomes) built. N within-study pairs:", nrow(diet_deltas), "\n")



# --- 14) Quick reportable counts ----
counts <- list(
  diets_total      = nrow(diet_nutrient),
  papers_total     = dplyr::n_distinct(diet_nutrient$B.Code),
  outcomes_total   = dplyr::n_distinct(diet_nutrient$Out.Subind),
  pairs_total      = nrow(diet_deltas),
  pairs_with_ME    = sum(!is.na(diet_deltas$dnut_ME)),
  pairs_with_NDF   = sum(!is.na(diet_deltas$dnut_NDF)),
  pairs_with_CP    = sum(!is.na(diet_deltas$dnut_CP)),
  pairs_with_EE    = sum(!is.na(diet_deltas$dnut_EE))
)
cat("\n‚úÖ Counts:\n"); print(counts)

# --- 15) FIGURE 1 ‚Äì Coefficient plot (compact) ----
# Uses base lm; broom::tidy() via namespace to avoid attach
# --- 15) MODELS + COUNTS (EI, Yield, CH4) -------------------------------

# helper: rescale nutrient deltas to reporting units
# ============================================================
# CHUNK B ‚Äî Models + counts (LOG outcomes; % transform)
# Builds: coef_all, model_meta (for labels), lab_map
# ============================================================

library(dplyr)
library(broom)

# Rescale predictor deltas to reporting units
scale_vars <- function(df) {
  df %>%
    dplyr::mutate(
      dnut_ME_1    = dnut_ME,         # per 1 MJ/kg DM
      dnut_NDF_100 = dnut_NDF / 100,  # per 100 g/kg DM
      dnut_CP_50   = dnut_CP  / 50,   # per 50 g/kg DM
      dnut_EE_10   = dnut_EE  / 10    # per 10 g/kg DM
    )
}

# Base modeling table with ln outcomes
base_data <- diet_deltas %>%
  scale_vars() %>%
  dplyr::mutate(.row_id = dplyr::row_number()) %>%
  dplyr::select(.row_id, B.Code, P.Product, Product,
                lnEI, lnY, lnCH4,
                dnut_ME_1, dnut_NDF_100, dnut_CP_50, dnut_EE_10)

# Per-outcome subsets and complete-case masks
preds <- c("dnut_ME_1","dnut_NDF_100","dnut_CP_50","dnut_EE_10","P.Product","Product")

mod_ei_data  <- base_data %>% dplyr::filter(!is.na(lnEI))
mod_y_data   <- base_data %>% dplyr::filter(!is.na(lnY))
mod_ch4_data <- base_data %>% dplyr::filter(!is.na(lnCH4))

mask_ei  <- stats::complete.cases(mod_ei_data[,  c("lnEI",  preds)])
mask_y   <- stats::complete.cases(mod_y_data[,   c("lnY",   preds)])
mask_ch4 <- stats::complete.cases(mod_ch4_data[, c("lnCH4", preds)])

# Fit log-outcome models
m_ei_ln  <- lm(lnEI  ~ dnut_ME_1 + dnut_NDF_100 + dnut_CP_50 + dnut_EE_10 + P.Product + Product,
               data = mod_ei_data[mask_ei, ])
m_y_ln   <- lm(lnY   ~ dnut_ME_1 + dnut_NDF_100 + dnut_CP_50 + dnut_EE_10 + P.Product + Product,
               data = mod_y_data[mask_y, ])
m_ch4_ln <- lm(lnCH4 ~ dnut_ME_1 + dnut_NDF_100 + dnut_CP_50 + dnut_EE_10 + P.Product + Product,
               data = mod_ch4_data[mask_ch4, ])

# Counts for labels
model_meta <- tibble::tibble(
  outcome   = c("EI (% change)","Yield (% change)","CH‚ÇÑ (% change)"),
  n_obs     = c(sum(mask_ei), sum(mask_y), sum(mask_ch4)),
  n_papers  = c(
    dplyr::n_distinct(mod_ei_data$B.Code[mask_ei]),
    dplyr::n_distinct(mod_y_data$B.Code[mask_y]),
    dplyr::n_distinct(mod_ch4_data$B.Code[mask_ch4])
  )
)

cat("Obs ‚Äî lnEI:", model_meta$n_obs[1],
    "| lnY:", model_meta$n_obs[2],
    "| lnCH4:", model_meta$n_obs[3], "\n")
cat("Papers ‚Äî lnEI:", model_meta$n_papers[1],
    "| lnY:", model_meta$n_papers[2],
    "| lnCH4:", model_meta$n_papers[3], "\n")

# Tidy ‚Üí transform coefficients to % change = 100*(exp(Œ≤)‚àí1)
coef_df <- function(m, label, data, yvar) {
  used <- data[stats::complete.cases(data[, c(yvar,
                                              "dnut_ME_1","dnut_NDF_100",
                                              "dnut_CP_50","dnut_EE_10",
                                              "P.Product","Product")]), ]
  broom::tidy(m, conf.int = TRUE) %>%
    dplyr::filter(term %in% c("dnut_ME_1","dnut_NDF_100","dnut_CP_50","dnut_EE_10")) %>%
    dplyr::mutate(
      estimate = 100 * (exp(estimate)  - 1),
      conf.low = 100 * (exp(conf.low)  - 1),
      conf.high= 100 * (exp(conf.high) - 1),
      outcome  = label,
      term = dplyr::recode(term,
        "dnut_ME_1"    = "ŒîME (per 1 MJ/kg)",
        "dnut_NDF_100" = "ŒîNDF (per 100 g/kg)",
        "dnut_CP_50"   = "ŒîCP (per 50 g/kg)",
        "dnut_EE_10"   = "ŒîEE (per 10 g/kg)"
      ),
      n_obs    = nrow(used),
      n_papers = dplyr::n_distinct(used$B.Code)
    )
}

coef_all <- dplyr::bind_rows(
  coef_df(m_ei_ln,  "EI (% change)",    mod_ei_data,  "lnEI"),
  coef_df(m_y_ln,   "Yield (% change)", mod_y_data,   "lnY"),
  coef_df(m_ch4_ln, "CH‚ÇÑ (% change)",   mod_ch4_data, "lnCH4")
)

# Label map (facet subtitles)
lab_map <- setNames(
  paste0(model_meta$outcome, " (n=", model_meta$n_obs, ", papers=", model_meta$n_papers, ")"),
  model_meta$outcome
)

# Optional: print table for sanity check
coef_table <- coef_all %>%
  dplyr::select(outcome, term, estimate, conf.low, conf.high,
                std.error, statistic, p.value, n_obs, n_papers) %>%
  dplyr::arrange(outcome, term)
print(coef_table, n = Inf)


# --- 18) PLOT ------------------------------------------------------------
```


```{r include=FALSE}
# ============================================================
# CHUNK C ‚Äî Coefficient plot (from LOG models; % scale)
# Depends on: coef_all and lab_map from previous chunk
# ============================================================

library(ggplot2)
library(forcats)

ggplot(coef_all,
       aes(x = estimate, y = forcats::fct_rev(term),
           xmin = conf.low, xmax = conf.high)) +
  geom_vline(xintercept = 0, linetype = 2) +
  geom_errorbarh(height = 0) +
  geom_point(size = 2) +
  facet_wrap(~ outcome, scales = "free_x",
             labeller = labeller(outcome = lab_map)) +
  labs(
    title = "Within-study nutrient shifts vs outcomes (log-ratio models)",
    subtitle = "Effects shown as % change per unit nutrient (100¬∑[e^Œ≤‚àí1])",
    x = "Estimated % change (95% CI)",
    y = NULL
  ) +
  theme_minimal(base_size = 13)

```





```{r include=FALSE}
# ===== A) LONG TABLE (one row per term √ó outcome) =====
# Assumes `coef_all` already exists from your plotting code.

coef_table_long <- coef_all %>%
  dplyr::select(outcome, term, estimate, conf.low, conf.high, std.error, p.value) %>%
  dplyr::mutate(
    dplyr::across(c(estimate, conf.low, conf.high, std.error), ~ round(., 3)),
    p.value = signif(p.value, 3)
  ) %>%
  dplyr::rename(
    Outcome = outcome,
    `Nutrient term` = term,
    Estimate = estimate,
    `CI low` = conf.low,
    `CI high` = conf.high,
    `Std. Error` = std.error,
    `p-value` = p.value
  ) %>%
  dplyr::arrange(Outcome, `Nutrient term`)

# Print nicely (optional)
if (requireNamespace("knitr", quietly = TRUE)) {
  knitr::kable(coef_table_long, align = "l", caption = "Coefficients used in the plot")
} else {
  print(coef_table_long, n = Inf)
}


```

```{r include=FALSE}
# --- Mean within-paper nutrient changes + distributions -----------------------


# 1Ô∏è‚É£ Remove zero or missing nutrient deltas first
diet_deltas_nonzero <- diet_deltas %>%
  mutate(across(starts_with("dnut_"),
                ~ ifelse(.x == 0, NA, .x))) %>%  # turn zeros to NA
  filter(
    !(is.na(dnut_CP) & is.na(dnut_NDF) & is.na(dnut_ADF) &
      is.na(dnut_EE) & is.na(dnut_ME))
  )

# 2Ô∏è‚É£ Compute mean absolute nutrient changes per paper √ó outcome
nut_delta_summary <- diet_deltas_nonzero %>%
  group_by(B.Code, Out.Subind) %>%
  summarise(
    across(
      c(dnut_CP, dnut_NDF, dnut_ADF, dnut_EE, dnut_ME),
      ~ mean(abs(.x), na.rm = TRUE),
      .names = "mean_abs_{.col}"
    ),
    .groups = "drop"
  ) %>%
  # 3Ô∏è‚É£ Summarise across all papers to get global averages and spread
  summarise(
    across(
      starts_with("mean_abs_"),
      list(
        mean = ~ mean(.x, na.rm = TRUE),
        sd = ~ sd(.x, na.rm = TRUE),
        median = ~ median(.x, na.rm = TRUE),
        q25 = ~ quantile(.x, 0.25, na.rm = TRUE),
        q75 = ~ quantile(.x, 0.75, na.rm = TRUE)
      ),
      .names = "{.col}_{.fn}"
    )
  )

# 4Ô∏è‚É£ Print compact table with units
cat("\nüìä Mean within-paper absolute nutrient changes (excluding zeros):\n")
nut_table <- data.frame(
  Nutrient = c("CP (g/kg DM)", "NDF (g/kg DM)", "ADF (g/kg DM)", "EE (g/kg DM)", "ME (MJ/kg DM)"),
  Mean = round(c(nut_delta_summary$mean_abs_dnut_CP_mean,
                 nut_delta_summary$mean_abs_dnut_NDF_mean,
                 nut_delta_summary$mean_abs_dnut_ADF_mean,
                 nut_delta_summary$mean_abs_dnut_EE_mean,
                 nut_delta_summary$mean_abs_dnut_ME_mean), 2),
  SD = round(c(nut_delta_summary$mean_abs_dnut_CP_sd,
               nut_delta_summary$mean_abs_dnut_NDF_sd,
               nut_delta_summary$mean_abs_dnut_ADF_sd,
               nut_delta_summary$mean_abs_dnut_EE_sd,
               nut_delta_summary$mean_abs_dnut_ME_sd), 2),
  Median = round(c(nut_delta_summary$mean_abs_dnut_CP_median,
                   nut_delta_summary$mean_abs_dnut_NDF_median,
                   nut_delta_summary$mean_abs_dnut_ADF_median,
                   nut_delta_summary$mean_abs_dnut_EE_median,
                   nut_delta_summary$mean_abs_dnut_ME_median), 2),
  Q25 = round(c(nut_delta_summary$mean_abs_dnut_CP_q25,
                nut_delta_summary$mean_abs_dnut_NDF_q25,
                nut_delta_summary$mean_abs_dnut_ADF_q25,
                nut_delta_summary$mean_abs_dnut_EE_q25,
                nut_delta_summary$mean_abs_dnut_ME_q25), 2),
  Q75 = round(c(nut_delta_summary$mean_abs_dnut_CP_q75,
                nut_delta_summary$mean_abs_dnut_NDF_q75,
                nut_delta_summary$mean_abs_dnut_ADF_q75,
                nut_delta_summary$mean_abs_dnut_EE_q75,
                nut_delta_summary$mean_abs_dnut_ME_q75), 2)
)
print(nut_table)

# 5Ô∏è‚É£ Histogram plot (excluding zeros)
diet_deltas_nonzero %>%
  pivot_longer(c(dnut_CP, dnut_NDF, dnut_EE, dnut_ME, dnut_ADF),
               names_to = "nutrient", values_to = "delta") %>%
  filter(!is.na(delta) & delta != 0) %>%
  mutate(nutrient = str_remove(nutrient, "dnut_")) %>%
  ggplot(aes(x = abs(delta))) +
  geom_histogram(bins = 30, fill = "grey70", color = "white") +
  facet_wrap(~ nutrient, scales = "free_x") +
  theme_minimal(base_size = 13) +
  labs(
    title = "Distribution of within-study nutrient differences across diets",
    subtitle = "Zero nutrient changes removed",
    x = "Absolute within-study nutrient change",
    y = "Count"
  )

```


```{r include=FALSE}
# --- Mean and absolute within-study nutrient changes --------------------------
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)

# 1Ô∏è‚É£ Remove zero or missing nutrient deltas (keep only diets that changed)
diet_deltas_nonzero <- diet_deltas %>%
  mutate(across(starts_with("dnut_"), ~ ifelse(.x == 0, NA, .x))) %>%
  filter(
    !(is.na(dnut_CP) & is.na(dnut_NDF) & is.na(dnut_ADF) &
      is.na(dnut_EE) & is.na(dnut_ME))
  )

# 2Ô∏è‚É£ Compute within-study nutrient changes (mean per paper √ó outcome)
nut_deltas_summary <- diet_deltas_nonzero %>%
  group_by(B.Code, Out.Subind) %>%
  summarise(
    across(
      c(dnut_CP, dnut_NDF, dnut_ADF, dnut_EE, dnut_ME),
      list(
        mean = ~ mean(.x, na.rm = TRUE),
        abs_mean = ~ mean(abs(.x), na.rm = TRUE)
      ),
      .names = "{.col}_{.fn}"
    ),
    .groups = "drop"
  )

# 3Ô∏è‚É£ Aggregate across studies to global summaries (mean, sd, median, IQR)
nut_delta_global <- nut_deltas_summary %>%
  select(where(is.numeric)) %>%
  summarise(
    across(
      everything(),
      list(
        mean = ~ mean(.x, na.rm = TRUE),
        sd   = ~ sd(.x, na.rm = TRUE),
        median = ~ median(.x, na.rm = TRUE),
        q25 = ~ quantile(.x, 0.25, na.rm = TRUE),
        q75 = ~ quantile(.x, 0.75, na.rm = TRUE)
      ),
      .names = "{.col}_{.fn}"
    )
  )

# 4Ô∏è‚É£ Build compact summary tables
## Absolute changes
nut_table_abs <- data.frame(
  Nutrient = c("CP (g/kg DM)", "NDF (g/kg DM)", "ADF (g/kg DM)",
               "EE (g/kg DM)", "ME (MJ/kg DM)"),
  Mean_abs = round(c(nut_delta_global$dnut_CP_abs_mean_mean,
                     nut_delta_global$dnut_NDF_abs_mean_mean,
                     nut_delta_global$dnut_ADF_abs_mean_mean,
                     nut_delta_global$dnut_EE_abs_mean_mean,
                     nut_delta_global$dnut_ME_abs_mean_mean), 2),
  SD_abs = round(c(nut_delta_global$dnut_CP_abs_mean_sd,
                   nut_delta_global$dnut_NDF_abs_mean_sd,
                   nut_delta_global$dnut_ADF_abs_mean_sd,
                   nut_delta_global$dnut_EE_abs_mean_sd,
                   nut_delta_global$dnut_ME_abs_mean_sd), 2),
  Median_abs = round(c(nut_delta_global$dnut_CP_abs_mean_median,
                       nut_delta_global$dnut_NDF_abs_mean_median,
                       nut_delta_global$dnut_ADF_abs_mean_median,
                       nut_delta_global$dnut_EE_abs_mean_median,
                       nut_delta_global$dnut_ME_abs_mean_median), 2),
  Q25_abs = round(c(nut_delta_global$dnut_CP_abs_mean_q25,
                    nut_delta_global$dnut_NDF_abs_mean_q25,
                    nut_delta_global$dnut_ADF_abs_mean_q25,
                    nut_delta_global$dnut_EE_abs_mean_q25,
                    nut_delta_global$dnut_ME_abs_mean_q25), 2),
  Q75_abs = round(c(nut_delta_global$dnut_CP_abs_mean_q75,
                    nut_delta_global$dnut_NDF_abs_mean_q75,
                    nut_delta_global$dnut_ADF_abs_mean_q75,
                    nut_delta_global$dnut_EE_abs_mean_q75,
                    nut_delta_global$dnut_ME_abs_mean_q75), 2)
)

## Signed changes
nut_table_signed <- data.frame(
  Nutrient = c("CP (g/kg DM)", "NDF (g/kg DM)", "ADF (g/kg DM)",
               "EE (g/kg DM)", "ME (MJ/kg DM)"),
  Mean_signed = round(c(nut_delta_global$dnut_CP_mean_mean,
                        nut_delta_global$dnut_NDF_mean_mean,
                        nut_delta_global$dnut_ADF_mean_mean,
                        nut_delta_global$dnut_EE_mean_mean,
                        nut_delta_global$dnut_ME_mean_mean), 2),
  SD_signed = round(c(nut_delta_global$dnut_CP_mean_sd,
                      nut_delta_global$dnut_NDF_mean_sd,
                      nut_delta_global$dnut_ADF_mean_sd,
                      nut_delta_global$dnut_EE_mean_sd,
                      nut_delta_global$dnut_ME_mean_sd), 2),
  Median_signed = round(c(nut_delta_global$dnut_CP_mean_median,
                          nut_delta_global$dnut_NDF_mean_median,
                          nut_delta_global$dnut_ADF_mean_median,
                          nut_delta_global$dnut_EE_mean_median,
                          nut_delta_global$dnut_ME_mean_median), 2),
  Q25_signed = round(c(nut_delta_global$dnut_CP_mean_q25,
                       nut_delta_global$dnut_NDF_mean_q25,
                       nut_delta_global$dnut_ADF_mean_q25,
                       nut_delta_global$dnut_EE_mean_q25,
                       nut_delta_global$dnut_ME_mean_q25), 2),
  Q75_signed = round(c(nut_delta_global$dnut_CP_mean_q75,
                       nut_delta_global$dnut_NDF_mean_q75,
                       nut_delta_global$dnut_ADF_mean_q75,
                       nut_delta_global$dnut_EE_mean_q75,
                       nut_delta_global$dnut_ME_mean_q75), 2)
)

# 5Ô∏è‚É£ Print both tables
cat("\nüìä Mean absolute within-study nutrient changes (excluding zeros):\n")
print(nut_table_abs)
cat("\nüìà Mean signed within-study nutrient changes (directional, excluding zeros):\n")
print(nut_table_signed)

# 6Ô∏è‚É£ Optional histogram for visual check (zeros removed)
diet_deltas_nonzero %>%
  pivot_longer(c(dnut_CP, dnut_NDF, dnut_EE, dnut_ME, dnut_ADF),
               names_to = "nutrient", values_to = "delta") %>%
  filter(!is.na(delta) & delta != 0) %>%
  mutate(nutrient = str_remove(nutrient, "dnut_")) %>%
  ggplot(aes(x = delta)) +
  geom_histogram(bins = 30, fill = "grey75", color = "white") +
  facet_wrap(~ nutrient, scales = "free_x") +
  theme_minimal(base_size = 13) +
  labs(
    title = "Distribution of within-study nutrient shifts (zeros excluded)",
    x = "Within-study change (signed, g/kg or MJ/kg DM)",
    y = "Count"
  )

```

# B Nutrient‚ÄìResponse Model Development

## Within-Study Comparative Framework

We quantify how **observed diet shifts** affect **enteric methane (CH‚ÇÑ), product yield (Y), and emission intensity (EI = CH‚ÇÑ/Y)** using a strictly **within-study** design that controls for all between-study differences (genetics, climate, management, instrumentation). For each study √ó outcome, we select a **single reference diet** using a transparent rule:

1) If any treatment is flagged **CONTROL**, that treatment is the reference;  
2) Otherwise, the **first reported** treatment is used.

All other treatments in that study are then expressed **relative to the reference**. This produces paired within-study contrasts for responses:

- **Percent changes**: ŒîCH‚ÇÑ (%) = 100¬∑(CH‚ÇÑ ‚àí CH‚ÇÑ\_ref)/CH‚ÇÑ\_ref;  
  ŒîY (%) = 100¬∑(Y ‚àí Y\_ref)/Y\_ref;  
  ŒîEI (%) = 100¬∑(EI ‚àí EI\_ref)/EI\_ref,
- **Log-ratios (recommended primary scale)**:  
  lnCH‚ÇÑ = ln(CH‚ÇÑ/CH‚ÇÑ\_ref), lnY = ln(Y/Y\_ref), and  
  **lnEI = lnCH‚ÇÑ ‚àí lnY** (by identity, since EI = CH‚ÇÑ/Y).

Log-ratios provide **scale invariance**, symmetric up/down effects, and naturally map coefficients back to **percent changes** via \(100\,[\exp(\beta) - 1]\).

For predictors, we compute within-study **nutrient deltas** between each diet and the reference for:
metabolizable energy (ME), neutral detergent fibre (NDF), crude protein (CP), and ether extract (EE). To ensure interpretable slopes and to reflect realistic formulation steps in the dataset, we **standardize units** as:
- **ŒîME** per **1 MJ¬∑kg‚Åª¬π DM**,  
- **ŒîNDF** per **100 g¬∑kg‚Åª¬π DM**,  
- **ŒîCP** per **50 g¬∑kg‚Åª¬π DM**,  
- **ŒîEE** per **10 g¬∑kg‚Åª¬π DM**.

This normalization means each coefficient can be read as the expected change in the outcome for a **typical, feasible** change in diet composition.

---

## Statistical Modeling Approach (Linear Models)

We fit ordinary least-squares (OLS) models **separately within each species √ó product stratum** (cattle/sheep/goat √ó milk/meat) to preserve species- and system-specific biology. For each stratum and each outcome, we estimate two closely related specifications:

1) **Percent-change model (Œî-scale):**  
\[
\Delta\% \;=\; \beta_0 + \beta_{\text{ME}}\Delta\text{ME} + \beta_{\text{NDF}}\Delta\text{NDF} + \beta_{\text{CP}}\Delta\text{CP} + \beta_{\text{EE}}\Delta\text{EE} + \varepsilon.
\]

2) **Log-ratio model (primary, recommended):**  
\[
\ln R \;=\; \beta_0 + \beta_{\text{ME}}\Delta\text{ME} + \beta_{\text{NDF}}\Delta\text{NDF} + \beta_{\text{CP}}\Delta\text{CP} + \beta_{\text{EE}}\Delta\text{EE} + \varepsilon,
\]
where \(R \in \{\mathrm{CH_4}, Y, \mathrm{EI}\}\) and **\(\ln \mathrm{EI} = \ln \mathrm{CH_4} - \ln Y\)**. 

Key implementation details:

- **Reference selection updated:** models are built after re-anchoring each study to **CONTROL** where available, otherwise **first diet**‚Äîensuring a consistent baseline across studies.
- **Complete-case analysis:** only contrasts with complete information on the outcome and the included nutrient deltas enter each fit.
- **Interpretation on % scale:** for log-ratio models, we convert coefficients to **% change per unit delta** via \(100\,[\exp(\beta) - 1]\) and report **95% Wald intervals**.
- **Panel-wise sample sizes and \(R^2\):** for every species √ó product √ó outcome panel we display the number of usable contrasts (n) and the \(R^2\), aiding assessment of fit and data support.
- **Guardrails for small n:** strata with too few complete contrasts are not plotted to avoid unstable estimates.

This linear-on-logs approach retains the **design-based control** of the within-study framework while yielding **directly interpretable elasticities**: e.g., the coefficient on ŒîME gives the **percent change** in CH‚ÇÑ (or Y, or EI) for a +1 MJ¬∑kg‚Åª¬π DM shift in ME relative to the study‚Äôs reference diet.

---

## Presentation of Species- and System-Specific Patterns

Results are presented as compact coefficient plots:

- **One column per species**, **one row per outcome** (CH‚ÇÑ, EI, Yield).  
- Separate figures for **Milk** and **Meat** systems.  
- Independent x-axis ranges per facet to preserve true effect magnitudes.  
- Points are median (or OLS point) effects; bars are **95% CIs**.  
- A small **\(R^2\)** label appears in each facet, alongside the **n** used.

Because all effects are estimated from **within-study** contrasts, coefficients reflect **biological response to diet composition** rather than confounding from study-level context. Unit scaling (ME: +1; NDF: +100; CP: +50; EE: +10) aligns with observed contrasts in African feeding trials, ensuring results correspond to **feasible formulation moves**.

---

## Why the Log-Ratio Linear Model is Preferred

While percent-change models are intuitive, the **log-ratio specification** is preferred for three reasons:

1) **Symmetry and coherence:** proportional increases and decreases are treated symmetrically; compounding is handled correctly.  
2) **Scale invariance:** coefficients are comparable across studies with different baselines.  
3) **Direct EI identity:** modeling lnCH‚ÇÑ and lnY implies lnEI **by construction** (\(\ln\mathrm{EI}=\ln\mathrm{CH_4}-\ln Y\)), enhancing internal consistency.

Together, the updated **reference-aware** contrasts and the **log-ratio linear models** deliver estimates that are **comparable, interpretable, and robust** to between-study heterogeneity‚Äîideal for extracting policy-relevant patterns from heterogeneous experimental evidence.


```{r,echo=FALSE,fig.width=12, fig.height=7, out.width='100%', fig.align='center'}
# ============================================================
# CHUNK D ‚Äî Species √ó Product panels with R¬≤ (LOG outcomes; %)
# Adds right-hand row labels ("CH‚ÇÑ", "EI", "Yield") using patchwork
# Produces: final_plot
# ============================================================

library(dplyr)
library(tidyr)
library(ggplot2)
library(forcats)
library(broom)
library(purrr)
library(patchwork)
library(ggforce)
library(grid)
library(gridExtra)   # <- needed for arrangeGrob used to place right-side labels

# ---- Helper: scale predictors; outcomes are already on ln-ratio scale ----
scale_vars <- function(df) {
  df %>%
    mutate(
      dnut_ME_1    = dnut_ME,         # per 1 MJ/kg
      dnut_NDF_100 = dnut_NDF / 100,  # per 100 g/kg
      dnut_CP_50   = dnut_CP  / 50,   # per 50 g/kg
      dnut_EE_10   = dnut_EE  / 10    # per 10 g/kg
    )
}

# ---- Base data for modeling ----
base_data <- diet_deltas %>%
  scale_vars() %>%
  transmute(
    B.Code,
    Species = factor(P.Product, levels = c("Cattle", "Sheep", "Goat")),
    Product = factor(Product,  levels = c("Milk", "Meat")),
    lnEI, lnY, lnCH4,                           # log-ratio outcomes
    dnut_ME_1, dnut_NDF_100, dnut_CP_50, dnut_EE_10
  )

# ---- Fit per Species √ó Product; return % change coefficients + R¬≤ ----
fit_one <- function(sp, prd, n_min = 20) {
  dat <- base_data %>% filter(Species == sp, Product == prd)
  if (nrow(dat) < n_min) return(NULL)

  fit_outcome <- function(y, label) {
    preds <- c("dnut_ME_1","dnut_NDF_100","dnut_CP_50","dnut_EE_10")
    keep  <- stats::complete.cases(dat[, c(y, preds)])
    d     <- dat[keep, , drop = FALSE]
    if (nrow(d) < n_min) return(NULL)

    m <- lm(stats::as.formula(paste0(y, " ~ ", paste(preds, collapse = " + "))), data = d)
    r2_val <- summary(m)$r.squared

    broom::tidy(m, conf.int = TRUE) %>%
      filter(term %in% preds) %>%
     mutate(
  # convert log-ratio slopes to % change
  estimate  = 100 * (exp(estimate)  - 1),
  conf.low  = 100 * (exp(conf.low)  - 1),
  conf.high = 100 * (exp(conf.high) - 1),
  Species = sp,
  Product = prd,
  outcome = label,
  R2 = round(r2_val, 3),
  term = dplyr::recode(
    term,
    dnut_ME_1    = "ŒîME (per 1 MJ/kg)",
    dnut_NDF_100 = "ŒîNDF (per 100 g/kg)",
    dnut_CP_50   = "ŒîCP (per 50 g/kg)",
    dnut_EE_10   = "ŒîEE (per 10 g/kg)",
    .default = term
  )
)
  }

  bind_rows(
    fit_outcome("lnCH4", "CH‚ÇÑ (% change)"),
    fit_outcome("lnEI",  "EI (% change)"),
    fit_outcome("lnY",   "Yield (% change)")
  )
}

# ---- Run models across Species √ó Product ----
all_combos <- tidyr::expand_grid(
  Species = levels(base_data$Species),
  Product = levels(base_data$Product)
)

coef_species_prod <- purrr::pmap_dfr(list(all_combos$Species, all_combos$Product),
                                     ~ fit_one(..1, ..2))
stopifnot(nrow(coef_species_prod) > 0)

coef_species_prod <- coef_species_prod %>%
  mutate(
    outcome = factor(outcome, levels = c("CH‚ÇÑ (% change)", "EI (% change)", "Yield (% change)")),
    panel   = interaction(Product, outcome, sep = " ‚Äì ", drop = TRUE)
  )

# ---- Split by Species for plotting ----
cattle_df <- coef_species_prod %>% filter(Species == "Cattle")
sheep_df  <- coef_species_prod %>% filter(Species == "Sheep")
goat_df   <- coef_species_prod %>% filter(Species == "Goat")

# ---- Aesthetic mapping for nutrients ----
nutrient_colors <- c(
  "ŒîCP (per 50 g/kg)"   = "blue4",
  "ŒîEE (per 10 g/kg)"   = "darkorange",
  "ŒîME (per 1 MJ/kg)"   = "seagreen3",
  "ŒîNDF (per 100 g/kg)" = "plum2"
)

# ---- Plot helper (no y-strip text; we‚Äôll add row labels at far right) ----
plot_species <- function(data, sp_name, show_y = TRUE) {
  r2_labels <- data %>%
    group_by(Product, outcome) %>%
    summarise(R2 = unique(R2), .groups = "drop")

  ggplot(data,
         aes(x = estimate, y = fct_rev(term), color = term)) +
    geom_vline(xintercept = 0, linetype = 2, color = "grey70") +
    geom_errorbarh(aes(xmin = conf.low, xmax = conf.high),
                   height = 0.15, linewidth = 1.1, alpha = 0.7) +
    geom_point(size = 3.2, alpha = 0.8) +
    # R¬≤ badge in each facet
    geom_text(
      data = r2_labels,
      aes(label = paste0("R¬≤ = ", sprintf("%.2f", R2))),
      x = Inf, y = Inf, hjust = 1.2, vjust = 1.5,
      color = "black", fontface = "bold",
      inherit.aes = FALSE
    ) +
    facet_grid(rows = vars(outcome), cols = vars(Product), scales = "free_x") +
    scale_color_manual(values = nutrient_colors) +
    labs(subtitle = sp_name, x = "Estimated % change (95% CI)", y = NULL) +
    theme_minimal(base_size = 13) +
    theme(
      strip.text.x  = element_text(face = "bold", size = 11),
      strip.text.y  = element_blank(),                 # <- remove default y-strip labels
      strip.placement = "outside",
      panel.spacing  = unit(1.2, "lines"),
      plot.subtitle  = element_text(face = "bold", size = 13, hjust = 0.5),
      axis.text.y    = if (show_y) element_text(face = "bold") else element_blank(),
      axis.ticks.y   = if (show_y) element_line() else element_blank(),
      legend.position = "none"
    )
}

# ---- Build three species panels ----
p_cattle <- plot_species(cattle_df, "Cattle", show_y = TRUE)
p_sheep  <- plot_species(sheep_df,  "Sheep",  show_y = FALSE)
p_goat   <- plot_species(goat_df,   "Goat",   show_y = FALSE)

# ---- Combine panels horizontally ----
species_panel <- p_cattle | p_sheep | p_goat

# ---- Add ONE column of row labels at the far right (this is what you asked) ----
# Order must match the facet row order above
row_labels <- c("CH4", "EI", "Yield")

label_grobs <- lapply(row_labels, function(lbl) {
  grid::textGrob(lbl, rot = -90, gp = grid::gpar(fontface = "bold"))
})

label_stack <- patchwork::wrap_elements(
  full = grid::grobTree(
    gridExtra::arrangeGrob(grobs = label_grobs, ncol = 1, heights = c(1, 1, 1))
  )
)

# Pull the labels closer to the rightmost panels
label_stack <- label_stack + theme(plot.margin = margin(0, 0, 0, -60))

# ---- Final assembly with right-side row labels ----
final_plot <- species_panel | label_stack +
  plot_layout(widths = c(3, 0.05)) +
  plot_annotation(
    title = "Within-study nutrient shifts vs outcomes (log-ratio models)",
    subtitle = "One column per species; coefficients are % change per unit nutrient"
  )

final_plot

```



```{r,echo=FALSE,fig.width=12, fig.height=7, out.width='100%', fig.align='center'}
# ============================================================
# CHUNK F ‚Äî Milk-only panels (LOG outcomes; % transform)
# Produces: final_milk_plot
# Notes:
#   ‚Ä¢ Matches CHUNK D layout: three species panels combined horizontally
#     PLUS a single right-hand column of row labels ("CH4", "EI", "Yield")
#   ‚Ä¢ Uses dplyr::recode() explicitly (avoids car::recode clash)
#   ‚Ä¢ Coefficients are % change per reporting unit of nutrient
# ============================================================

# --- Libraries ------------------------------------------------------------
library(dplyr)
library(tidyr)
library(ggplot2)
library(forcats)
library(broom)
library(purrr)
library(patchwork)
library(grid)
library(gridExtra)   # for arrangeGrob in right-side row labels

# --- Build base data (Milk only) with log-ratio outcomes -------------------
base_data_milk <- diet_deltas %>%
  dplyr::mutate(
    Species = factor(P.Product, levels = c("Cattle", "Sheep", "Goat")),
    Product = factor(Product, levels = c("Milk", "Meat"))
  ) %>%
  dplyr::filter(Product == "Milk") %>%
  dplyr::mutate(
    dnut_ME_1    = dnut_ME,          # per 1 MJ/kg
    dnut_NDF_100 = dnut_NDF / 100,   # per 100 g/kg
    dnut_CP_50   = dnut_CP  / 50,    # per 50 g/kg
    dnut_EE_10   = dnut_EE  / 10     # per 10 g/kg
  ) %>%
  dplyr::select(
    B.Code, Species, Product,
    lnEI, lnY, lnCH4,
    dnut_ME_1, dnut_NDF_100, dnut_CP_50, dnut_EE_10
  )

# --- Fit log-outcome models for one species; return % effects + R¬≤ ----------
fit_one_milk <- function(sp, n_min = 5) {
  dat <- base_data_milk %>% dplyr::filter(Species == sp)
  if (nrow(dat) < n_min) return(NULL)

  fit_outcome <- function(y, label) {
    preds <- c("dnut_ME_1","dnut_NDF_100","dnut_CP_50","dnut_EE_10")
    keep  <- stats::complete.cases(dat[, c(y, preds)])
    d     <- dat[keep, , drop = FALSE]
    if (nrow(d) < n_min) return(NULL)

    m <- lm(stats::as.formula(paste0(y, " ~ ", paste(preds, collapse = " + "))), data = d)
    r2_val <- summary(m)$r.squared

    broom::tidy(m, conf.int = TRUE) %>%
      dplyr::filter(term %in% preds) %>%
      dplyr::mutate(
        # convert log-ratio slopes to % change
        estimate  = 100 * (exp(estimate)  - 1),
        conf.low  = 100 * (exp(conf.low)  - 1),
        conf.high = 100 * (exp(conf.high) - 1),
        Species   = sp,
        Product   = "Milk",
        outcome   = label,
        R2        = round(r2_val, 3),
        # IMPORTANT: explicit dplyr::recode, keep unmapped if any
        term = dplyr::recode(
          term,
          dnut_ME_1    = "ŒîME (per 1 MJ/kg)",
          dnut_NDF_100 = "ŒîNDF (per 100 g/kg)",
          dnut_CP_50   = "ŒîCP (per 50 g/kg)",
          dnut_EE_10   = "ŒîEE (per 10 g/kg)",
          .default = term
        )
      )
  }

  dplyr::bind_rows(
    fit_outcome("lnCH4", "CH4"),
    fit_outcome("lnEI",  "EI"),
    fit_outcome("lnY",   "Yield")
  )
}

# --- Run models for each Milk species --------------------------------------
milk_species <- levels(base_data_milk$Species)
coef_species_milk <- purrr::map_dfr(milk_species, fit_one_milk)
stopifnot(nrow(coef_species_milk) > 0)

coef_species_milk <- coef_species_milk %>%
  dplyr::mutate(outcome = factor(outcome, levels = c("CH4", "EI", "Yield")))

# --- Split for plotting -----------------------------------------------------
cattle_df <- coef_species_milk %>% dplyr::filter(Species == "Cattle")
sheep_df  <- coef_species_milk %>% dplyr::filter(Species == "Sheep")
goat_df   <- coef_species_milk %>% dplyr::filter(Species == "Goat")

# --- Colors for nutrient terms ---------------------------------------------
nutrient_colors <- c(
  "ŒîCP (per 50 g/kg)"   = "blue4",
  "ŒîEE (per 10 g/kg)"   = "darkorange",
  "ŒîME (per 1 MJ/kg)"   = "seagreen3",
  "ŒîNDF (per 100 g/kg)" = "plum2"
)

# --- Plot helper: one species panel; no built-in row strips on left ---------
#     (we add a single right-hand label column with patchwork, below)
plot_species_milk <- function(data, sp_name, show_y = TRUE) {
  r2_labels <- data %>%
    dplyr::group_by(outcome) %>%
    dplyr::summarise(R2 = unique(R2), .groups = "drop")

  ggplot(data,
         aes(x = estimate, y = forcats::fct_rev(term), color = term)) +
    geom_vline(xintercept = 0, linetype = 2, color = "grey70") +
    geom_errorbarh(aes(xmin = conf.low, xmax = conf.high),
                   height = 0.15, linewidth = 1.1, alpha = 0.7) +
    geom_point(size = 3.2, alpha = 0.8) +
    geom_text(
      data = r2_labels,
      aes(label = paste0("R¬≤ = ", sprintf("%.2f", R2))),
      x = Inf, y = Inf, hjust = 1.2, vjust = 1.5,
      color = "black", fontface = "bold",
      inherit.aes = FALSE
    ) +
    facet_grid(rows = vars(outcome), scales = "free_x") +
    scale_color_manual(values = nutrient_colors) +
    labs(subtitle = sp_name, x = "Estimated % change (95% CI)", y = NULL) +
    theme_minimal(base_size = 13) +
    theme(
      strip.text.y    = element_blank(),                 # remove default row labels
      strip.placement = "outside",
      panel.spacing   = unit(1.2, "lines"),
      plot.subtitle   = element_text(face = "bold", size = 13, hjust = 0.5),
      axis.text.y     = if (show_y) element_text(face = "bold") else element_blank(),
      axis.ticks.y    = if (show_y) element_line() else element_blank(),
      legend.position = "none"
    )
}

# --- Build the three species panels ----------------------------------------
p_cattle <- plot_species_milk(cattle_df, "Cattle (Milk)", show_y = TRUE)
p_sheep  <- plot_species_milk(sheep_df,  "Sheep (Milk)",  show_y = FALSE)
p_goat   <- plot_species_milk(goat_df,   "Goat (Milk)",   show_y = FALSE)

# --- Combine panels horizontally -------------------------------------------
species_panel_milk <- p_cattle | p_sheep | p_goat

# --- Add ONE column of row labels at far right (order matches facet rows) ---
row_labels <- c("CH4", "EI", "Yield")
label_grobs <- lapply(row_labels, function(lbl) {
  grid::textGrob(lbl, rot = -90, gp = grid::gpar(fontface = "bold"))
})

label_stack <- patchwork::wrap_elements(
  full = grid::grobTree(
    gridExtra::arrangeGrob(grobs = label_grobs, ncol = 1, heights = c(1, 1, 1))
  )
)

# Pull the labels closer to the rightmost panels (negative right margin)
label_stack <- label_stack + theme(plot.margin = margin(0, 0, 0, -60))

# --- Final assembly with right-side row labels ------------------------------
final_milk_plot <- species_panel_milk | label_stack +
  plot_layout(widths = c(3, 0.05)) +
  plot_annotation(
    title = "Within-study nutrient shifts vs outcomes (Milk; log-ratio models)",
    subtitle = "One column per species; coefficients are % change per unit nutrient"
  )

# --- Render -----------------------------------------------------------------
final_milk_plot


```

## b.1 Number of observations for models 

```{r echo=FALSE}
# ============================================================
# UNIQUE counts per Nutrient √ó Outcome √ó Species √ó Product
# Counts:
#   ‚Ä¢ n_obs_unique    = number of UNIQUE observations (distinct original rows)
#   ‚Ä¢ n_papers_unique = number of UNIQUE papers (distinct B.Code)
# Method:
#   ‚Ä¢ Pivot outcomes and nutrients to long form,
#     keep rows where BOTH the chosen outcome and nutrient are non-missing,
#     then count uniques by Species √ó Product √ó Outcome √ó Nutrient.
# ============================================================

library(dplyr)
library(tidyr)

# 1) Base table with ln outcomes and scaled nutrient predictors
base_cases <- diet_deltas %>%
  mutate(
    Species       = factor(P.Product, levels = c("Cattle","Sheep","Goat")),
    Product       = factor(Product,   levels = c("Milk","Meat")),
    dnut_ME_1     = dnut_ME,          # per 1 MJ/kg
    dnut_NDF_100  = dnut_NDF / 100,   # per 100 g/kg
    dnut_CP_50    = dnut_CP  / 50,    # per 50 g/kg
    dnut_EE_10    = dnut_EE  / 10,    # per 10 g/kg
    .row_id       = dplyr::row_number()  # unique row id for "unique obs" counting
  ) %>%
  select(
    .row_id, B.Code, Species, Product,
    lnCH4, lnEI, lnY,
    dnut_ME_1, dnut_NDF_100, dnut_CP_50, dnut_EE_10
  )

# 2) Label dictionaries
outcome_labels <- c(
  lnCH4 = "CH‚ÇÑ (log-ratio)",
  lnEI  = "EI (log-ratio)",
  lnY   = "Yield (log-ratio)"
)

nutrient_labels <- c(
  dnut_ME_1     = "ŒîME (per 1 MJ/kg)",
  dnut_NDF_100  = "ŒîNDF (per 100 g/kg)",
  dnut_CP_50    = "ŒîCP (per 50 g/kg)",
  dnut_EE_10    = "ŒîEE (per 10 g/kg)"
)

# 3) Pivot outcomes and nutrients to long form, then complete-case filter
long_counts <- base_cases %>%
  pivot_longer(
    cols = c(lnCH4, lnEI, lnY),
    names_to = "outcome_var", values_to = "outcome_value"
  ) %>%
  pivot_longer(
    cols = c(dnut_ME_1, dnut_NDF_100, dnut_CP_50, dnut_EE_10),
    names_to = "nutrient_var", values_to = "nutrient_value"
  ) %>%
  # keep pairs where BOTH the chosen outcome and nutrient are present
  filter(!is.na(outcome_value), !is.na(nutrient_value)) %>%
  mutate(
    Outcome  = outcome_labels[outcome_var],
    Nutrient = nutrient_labels[nutrient_var]
  )

# 4) Count UNIQUE observations (.row_id) and UNIQUE papers (B.Code)
summary_counts_unique <- long_counts %>%
  group_by(Species, Product, Outcome, Nutrient) %>%
  summarise(
    n_obs_unique    = dplyr::n_distinct(.row_id),
    n_papers_unique = dplyr::n_distinct(B.Code),
    .groups = "drop"
  ) %>%
  arrange(Species, Product, Outcome, Nutrient)

# 5) (Optional) Ensure all combos appear, filling zeros where absent
summary_counts_unique <- summary_counts_unique %>%
  complete(
    Species,
    Product,
    Outcome  = unique(unname(outcome_labels)),
    Nutrient = unique(unname(nutrient_labels)),
    fill = list(n_obs_unique = 0L, n_papers_unique = 0L)
  ) %>%
  arrange(Species, Product, Outcome, Nutrient)

# 6) Split views (Milk / Meat) if helpful
summary_counts_unique_milk <- summary_counts_unique %>% filter(Product == "Milk")
summary_counts_unique_meat <- summary_counts_unique %>% filter(Product == "Meat")

# 7) Display
if (requireNamespace("knitr", quietly = TRUE)) {
  knitr::kable(summary_counts_unique,
               caption = "UNIQUE counts per Nutrient √ó Outcome √ó Species √ó Product (log outcomes)")
} else {
  print(summary_counts_unique, n = Inf)
}

# # Optional: export
# readr::write_csv(summary_counts_unique, "outputs/summary_counts_unique.csv")


```



#C. Bayesian model 

Here we use a Bayesian multilevel model (fit with brms) that treats diets as nested within studies via random intercepts and random nutrient-response slopes, while estimating pooled fixed effects for nutrients (and species/products). Compared with a single-level OLS, this hierarchy respects the study design, applies partial pooling (shrinking noisy study estimates toward the overall mean), and remains stable under unbalanced contrasts across species and products. Weakly informative priors regularize coefficients, reducing overfitting and improving out-of-sample performance. Crucially, we obtain full posterior distributions, so effects are reported as percent changes 100‚ãÖ(exp‚Å°(Œ≤)‚àí1)100\cdot(\exp(\beta)-1)100‚ãÖ(exp(Œ≤)‚àí1) with honest credible intervals that incorporate between-study uncertainty. The generative fit supports posterior predictive checks, Bayes R2R^2R2, and straightforward extensions (e.g., species√ónutrient interactions) that borrow strength across studies while yielding biologically interpretable, study-aware estimates.

```{r eval=FALSE, include=FALSE}
# ============================================================
# BRMS: Species-specific nutrient effects (3√ó3 per Product)
#  - Within-study log ratios (lnCH4, lnEI, lnY)
#  - Random intercepts + random nutrient slopes by study (B.Code)
#  - Species-specific slopes via interactions: nutrients * Species
#  - Two figures: Meat (3x3), Milk (3x3)
# ============================================================

# --- Packages ------------------------------------------------
library(dplyr)
library(tidyr)
library(forcats)
library(ggplot2)
library(brms)
library(posterior)  # as_draws_df
library(purrr)
# optional: faster backend & parallelism
# options(brms.backend = "cmdstanr")
options(mc.cores = max(1, parallel::detectCores() - 1))

# --- Data prep: keep within-study deltas/ratios --------------
dd <- diet_deltas %>%
  mutate(
    Species = factor(P.Product, levels = c("Cattle","Sheep","Goat")),
    Product = factor(Product,   levels = c("Meat","Milk")),
    dnut_ME_1    = dnut_ME,         # per 1 MJ/kg DM
    dnut_NDF_100 = dnut_NDF/100,    # per 100 g/kg DM
    dnut_CP_50   = dnut_CP/50,      # per 50 g/kg DM
    dnut_EE_10   = dnut_EE/10       # per 10 g/kg DM
  ) %>%
  select(B.Code, Species, Product,
         lnCH4, lnEI, lnY,
         dnut_ME_1, dnut_NDF_100, dnut_CP_50, dnut_EE_10)

nut_terms <- c("dnut_ME_1","dnut_NDF_100","dnut_CP_50","dnut_EE_10")

# --- Priors --------------------------------------------------
pri <- c(
  prior(normal(0, 0.2), class = "b"),        # weakly-informative (log scale)
  prior(student_t(3, 0, 0.5), class = "sd"), # RE SDs (int + slopes)
  prior(lkj(2), class = "cor"),              # regularize RE correlations
  prior(student_t(3, 0, 1.0), class = "sigma")
)

# --- Helper: fit one product √ó outcome with species interactions ------------
# Rows with all-needed cols only; guard against tiny subsets
fit_one <- function(prod, yvar) {
  d <- dd %>%
    filter(Product == prod) %>%
    drop_na(all_of(c(yvar, nut_terms, "Species", "B.Code")))
  if (nrow(d) < 40) return(NULL)

  # Formula:
  #  - Species-specific slopes via (nutrients * Species)
  #  - Study-level RE: intercept + all nutrient slopes
  f <- bf(reformulate(
    termlabels = c(
      "0 + Species",                                       # per-species intercepts
      "(dnut_ME_1 + dnut_NDF_100 + dnut_CP_50 + dnut_EE_10) * Species",
      "(1 + dnut_ME_1 + dnut_NDF_100 + dnut_CP_50 + dnut_EE_10 | B.Code)"
    ),
    response = yvar
  ))

  brm(
    f, data = d, prior = pri, family = gaussian(),
    chains = 4, iter = 4000,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    seed = 123
  )
}

# --- Fit models (per Product √ó Outcome) ----------------------
m_meat_ch4 <- fit_one("Meat", "lnCH4")
m_meat_ei  <- fit_one("Meat", "lnEI")
m_meat_y   <- fit_one("Meat", "lnY")

m_milk_ch4 <- fit_one("Milk", "lnCH4")
m_milk_ei  <- fit_one("Milk", "lnEI")
m_milk_y   <- fit_one("Milk", "lnY")

# --- Helper: extract species-specific slopes & Bayes R2 ---------------------
# This computes, for each Species and nutrient, the posterior of the slope:
#   slope_sp = b_dnut + b_(dnut:SpeciesSheep/Goat)  (Cattle is baseline)
# Returns % effect per unit nutrient: 100*(exp(beta)-1)

summarise_model_species <- function(m, outcome_label, product_label) {
  stopifnot(inherits(m, "brmsfit"))

  draws <- posterior::as_draws_df(m) %>% tibble::as_tibble()
  sp_levels <- c("Cattle","Sheep","Goat")

  # Safe getter: return 0 if term missing (e.g., baseline w/o interaction)
  get_col <- function(nm) {
    if (nm %in% names(draws)) draws[[nm]] else rep(0, nrow(draws))
  }

  # Build species-specific slope draws for each nutrient
  one_term <- function(nut_raw, nice_label) {
    base  <- get_col(paste0("b_", nut_raw))
    add_Sheep <- get_col(paste0("b_", nut_raw, ":SpeciesSheep")) + get_col(paste0("b_SpeciesSheep:", nut_raw))
    add_Goat  <- get_col(paste0("b_", nut_raw, ":SpeciesGoat"))  + get_col(paste0("b_SpeciesGoat:",  nut_raw))

    tibble::tibble(
      Species = rep(sp_levels, each = length(base)),
      beta = c(base, base + add_Sheep, base + add_Goat)
    ) %>%
      mutate(
        pct  = 100 * (exp(beta) - 1),
        term = nice_label
      )
  }

  draws_long <- bind_rows(
    one_term("dnut_ME_1",    "ŒîME (per 1 MJ/kg)"),
    one_term("dnut_NDF_100", "ŒîNDF (per 100 g/kg)"),
    one_term("dnut_CP_50",   "ŒîCP (per 50 g/kg)"),
    one_term("dnut_EE_10",   "ŒîEE (per 10 g/kg)")
  )

  coef_sp <- draws_long %>%
    group_by(Species, term) %>%
    summarise(
      estimate = median(pct, na.rm = TRUE),
      conf.low = quantile(pct, 0.025, na.rm = TRUE),
      conf.high= quantile(pct, 0.975, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(outcome = outcome_label, Product = product_label)

  # Species-specific Bayes R¬≤ (robust; falls back to NA if not supported)
  safe_r2_species <- function(sp) {
    nd <- dd %>%
      filter(Product == product_label, Species == sp) %>%
      drop_na(all_of(c(
        dplyr::case_match(outcome_label,
          "CH4"   ~ "lnCH4",
          "EI"    ~ "lnEI",
          "Yield" ~ "lnY"
        ),
        nut_terms
      )))
    if (nrow(nd) < 10) return(NA_real_)
    r2 <- try(brms::bayes_R2(m, newdata = nd, summary = FALSE), silent = TRUE)
    if (inherits(r2, "try-error")) return(NA_real_) else mean(r2[, 1], na.rm = TRUE)
  }

  r2_sp <- tibble::tibble(
    Species = sp_levels,
    R2 = purrr::map_dbl(sp_levels, safe_r2_species),
    outcome = outcome_label,
    Product = product_label
  )

  list(coef = coef_sp, r2 = r2_sp)
}

# --- Summaries for all six models ------------------------------------------
sum_list <- list(
  if (!is.null(m_meat_ch4)) summarise_model_species(m_meat_ch4, "CH4",   "Meat"),
  if (!is.null(m_meat_ei))  summarise_model_species(m_meat_ei,  "EI",    "Meat"),
  if (!is.null(m_meat_y))   summarise_model_species(m_meat_y,   "Yield", "Meat"),
  if (!is.null(m_milk_ch4)) summarise_model_species(m_milk_ch4, "CH4",   "Milk"),
  if (!is.null(m_milk_ei))  summarise_model_species(m_milk_ei,  "EI",    "Milk"),
  if (!is.null(m_milk_y))   summarise_model_species(m_milk_y,   "Yield", "Milk")
) %>% compact()

coef_sp_all <- bind_rows(map(sum_list, "coef"))
r2_sp_all   <- bind_rows(map(sum_list, "r2")) %>%
  mutate(R2_lab = ifelse(is.na(R2), "R¬≤ = NA", paste0("R¬≤ = ", sprintf("%.2f", R2))))

# --- Plot helper: 3√ó3 per Product (rows = outcomes; cols = Species) ----------
nutrient_colors <- c(
  "ŒîCP (per 50 g/kg)"   = "blue4",
  "ŒîEE (per 10 g/kg)"   = "darkorange",
  "ŒîME (per 1 MJ/kg)"   = "seagreen3",
  "ŒîNDF (per 100 g/kg)" = "plum2"
)

plot_product_3x3 <- function(product_name) {
  dat <- coef_sp_all %>%
    filter(Product == product_name) %>%
    mutate(
      outcome = factor(outcome, levels = c("CH4","EI","Yield")),
      Species = factor(Species, levels = c("Cattle","Sheep","Goat"))
    )

  r2_lab <- r2_sp_all %>%
    filter(Product == product_name) %>%
    mutate(
      outcome = factor(outcome, levels = c("CH4","EI","Yield")),
      Species = factor(Species, levels = c("Cattle","Sheep","Goat"))
    )

  ggplot(dat,
         aes(x = estimate, y = fct_rev(term), color = term)) +
    geom_vline(xintercept = 0, linetype = 2, color = "grey70") +
    geom_errorbarh(aes(xmin = conf.low, xmax = conf.high),
                   height = 0.15, linewidth = 1.1, alpha = 0.8) +
    geom_point(size = 3.2, alpha = 0.9) +
    facet_grid(rows = vars(outcome), cols = vars(Species),
               scales = "free_x", switch = "y") +
    scale_color_manual(values = nutrient_colors) +
    labs(
      title = paste("Within-study nutrient shifts ‚Äî", product_name),
      subtitle = "BRMS with study random intercepts & slopes; species-specific nutrient effects",
      x = "Estimated % change per unit nutrient (95% CrI)",
      y = NULL
    ) +
    theme_minimal(base_size = 13) +
    theme(
      strip.text.y       = element_text(face = "bold"),
      strip.placement    = "outside",
      strip.clip         = "off",
      plot.margin        = margin(5.5, 20, 5.5, 5.5),
      legend.position    = "none"
    ) +
    # Put an R¬≤ in the top-right of each facet (per row √ó col)
    geom_text(
      data = r2_lab,
      aes(label = paste0("R¬≤ = ", ifelse(is.na(R2), "NA", sprintf('%.2f', R2)))),
      x = Inf, y = Inf,
      hjust = 1.2, vjust = 1.5, color = "black",
      inherit.aes = FALSE, fontface = "bold"
    )
}

# --- Build & print the two 3√ó3 figures -------------------------------------
final_brm_meat_species_plot <- plot_product_3x3("Meat")
final_brm_milk_species_plot <- plot_product_3x3("Milk")

final_brm_meat_species_plot
final_brm_milk_species_plot

```



